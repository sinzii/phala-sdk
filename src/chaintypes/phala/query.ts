// Generated by dedot cli

import type { GenericChainStorage, GenericStorageQuery, Callback, RpcVersion } from 'dedot/types'
import type {
  AccountId32,
  AccountId32Like,
  H256,
  Bytes,
  Digest,
  Phase,
  FixedBytes,
  FixedU128,
  BytesLike,
  Data,
  U256,
} from 'dedot/codecs'
import type {
  FrameSystemAccountInfo,
  FrameSupportDispatchPerDispatchClass,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  PalletMultisigMultisig,
  PalletProxyProxyDefinition,
  PalletProxyAnnouncement,
  PalletVestingVestingInfo,
  PalletVestingReleases,
  PalletSchedulerScheduled,
  PalletPreimageOldRequestStatus,
  PalletPreimageRequestStatus,
  PolkadotParachainPrimitivesPrimitivesId,
  CumulusPalletParachainSystemUnincludedSegmentAncestor,
  CumulusPalletParachainSystemUnincludedSegmentSegmentTracker,
  PolkadotPrimitivesV6PersistedValidationData,
  PolkadotPrimitivesV6UpgradeRestriction,
  PolkadotPrimitivesV6UpgradeGoAhead,
  SpTrieStorageProof,
  CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot,
  PolkadotPrimitivesV6AbridgedHostConfiguration,
  CumulusPrimitivesParachainInherentMessageQueueChain,
  PolkadotCorePrimitivesOutboundHrmpMessage,
  SpWeightsWeightV2Weight,
  CumulusPalletParachainSystemCodeUpgradeAuthorization,
  CumulusPalletXcmpQueueInboundChannelDetails,
  CumulusPalletXcmpQueueOutboundChannelDetails,
  CumulusPalletXcmpQueueQueueConfigData,
  CumulusPalletDmpQueueConfigData,
  CumulusPalletDmpQueuePageIndexData,
  PalletXcmQueryStatus,
  StagingXcmVersionedMultiLocation,
  PalletXcmVersionMigrationStage,
  PalletXcmRemoteLockedFungibleRecord,
  StagingXcmVersionedAssetId,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesReserveData,
  PalletBalancesIdAmount,
  PalletBalancesIdAmount002,
  PalletTransactionPaymentReleases,
  PalletAssetsAssetDetails,
  PalletAssetsAssetAccount,
  PalletAssetsApproval,
  PalletAssetsAssetMetadata,
  PalletCollatorSelectionCandidateInfo,
  PhalaParachainRuntimeOpaqueSessionKeys,
  SpCoreCryptoKeyTypeId,
  SpConsensusAuraSr25519AppSr25519Public,
  SpConsensusSlotsSlot,
  PalletIdentityRegistration,
  PalletIdentityRegistrarInfo,
  FrameSupportPreimagesBounded,
  PalletDemocracyReferendumInfo,
  PalletDemocracyVoteVoting,
  PalletDemocracyVoteThreshold,
  PalletDemocracyMetadataOwner,
  PhalaParachainRuntimeRuntimeCall,
  PalletCollectiveVotes,
  PalletTreasuryProposal,
  PalletBountiesBounty,
  PalletLotteryLotteryConfig,
  PalletElectionsPhragmenSeatHolder,
  PalletElectionsPhragmenVoter,
  PalletTipsOpenTip,
  PalletChildBountiesChildBounty,
  SubbridgePalletsChainbridgePalletProposalVotes,
  PhalaParachainRuntimeRuntimeCallLike,
  SubbridgePalletsChainbridgePalletBridgeEvent,
  StagingXcmV3MultilocationMultiLocation,
  AssetsRegistryAssetRegistryInfo,
  PhalaMqMessageOrigin,
  PhalaMqMessage,
  SpCoreSr25519Public,
  PhalaPalletsRegistryPalletWorkerInfoV2,
  PhalaTypesVersionedWorkerEndpoints,
  PhalaPalletsRegistryPalletKnownConsensusVersion,
  PhalaTypesMessagingTokenomicParameters,
  PhalaPalletsComputeComputationPalletSessionInfo,
  PhalaPalletsStakePoolPalletPoolInfo,
  PhalaPalletsStakePoolPalletUserStakeInfo,
  PhalaPalletsComputeWrappedBalancesPalletFinanceAccount,
  PhalaPalletsComputePoolProxy,
  PhalaPalletsPhatPalletBasicContractInfo,
  PhalaTypesContractClusterInfo,
  PalletUniquesCollectionDetails,
  PalletUniquesItemDetails,
  PalletUniquesCollectionMetadata,
  PalletUniquesItemMetadata,
  RmrkTraitsCollectionCollectionInfo,
  RmrkTraitsNftNftInfo,
  RmrkTraitsResourceResourceInfo,
  RmrkTraitsNftNftChild,
  PhantomType,
  RmrkTraitsBaseBaseInfo,
  RmrkTraitsPartPartType,
  PalletRmrkMarketListInfo,
  PalletRmrkMarketOffer,
  StagingXcmV3MultiassetAssetId,
  SygmaTraitsMpcAddress,
  SygmaFeeHandlerRouterFeeHandlerType,
  PalletIndexDepositInfo,
} from './types'

export interface ChainStorage<Rv extends RpcVersion> extends GenericChainStorage<Rv> {
  /**
   * Pallet `System`'s storage queries
   **/
  system: {
    /**
     * The full account information for a particular account ID.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<FrameSystemAccountInfo> =} callback
     **/
    account: GenericStorageQuery<Rv, (arg: AccountId32Like) => FrameSystemAccountInfo, AccountId32>

    /**
     * Total extrinsics count for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    extrinsicCount: GenericStorageQuery<Rv, () => number | undefined>

    /**
     * The current weight for the block.
     *
     * @param {Callback<FrameSupportDispatchPerDispatchClass> =} callback
     **/
    blockWeight: GenericStorageQuery<Rv, () => FrameSupportDispatchPerDispatchClass>

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    allExtrinsicsLen: GenericStorageQuery<Rv, () => number | undefined>

    /**
     * Map of block numbers to block hashes.
     *
     * @param {number} arg
     * @param {Callback<H256> =} callback
     **/
    blockHash: GenericStorageQuery<Rv, (arg: number) => H256, number>

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    extrinsicData: GenericStorageQuery<Rv, (arg: number) => Bytes, number>

    /**
     * The current block number being processed. Set by `execute_block`.
     *
     * @param {Callback<number> =} callback
     **/
    number: GenericStorageQuery<Rv, () => number>

    /**
     * Hash of the previous block.
     *
     * @param {Callback<H256> =} callback
     **/
    parentHash: GenericStorageQuery<Rv, () => H256>

    /**
     * Digest of the current block, also part of the block header.
     *
     * @param {Callback<Digest> =} callback
     **/
    digest: GenericStorageQuery<Rv, () => Digest>

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     *
     * @param {Callback<Array<FrameSystemEventRecord>> =} callback
     **/
    events: GenericStorageQuery<Rv, () => Array<FrameSystemEventRecord>>

    /**
     * The number of events in the `Events<T>` list.
     *
     * @param {Callback<number> =} callback
     **/
    eventCount: GenericStorageQuery<Rv, () => number>

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     *
     * @param {H256} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    eventTopics: GenericStorageQuery<Rv, (arg: H256) => Array<[number, number]>, H256>

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     *
     * @param {Callback<FrameSystemLastRuntimeUpgradeInfo | undefined> =} callback
     **/
    lastRuntimeUpgrade: GenericStorageQuery<Rv, () => FrameSystemLastRuntimeUpgradeInfo | undefined>

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToU32RefCount: GenericStorageQuery<Rv, () => boolean>

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToTripleRefCount: GenericStorageQuery<Rv, () => boolean>

    /**
     * The execution phase of the block.
     *
     * @param {Callback<Phase | undefined> =} callback
     **/
    executionPhase: GenericStorageQuery<Rv, () => Phase | undefined>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Timestamp`'s storage queries
   **/
  timestamp: {
    /**
     * The current time for the current block.
     *
     * @param {Callback<bigint> =} callback
     **/
    now: GenericStorageQuery<Rv, () => bigint>

    /**
     * Whether the timestamp has been updated in this block.
     *
     * This value is updated to `true` upon successful submission of a timestamp by a node.
     * It is then checked at the end of each block execution in the `on_finalize` hook.
     *
     * @param {Callback<boolean> =} callback
     **/
    didUpdate: GenericStorageQuery<Rv, () => boolean>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `RandomnessCollectiveFlip`'s storage queries
   **/
  randomnessCollectiveFlip: {
    /**
     * Series of block headers from the last 81 blocks that acts as random seed material. This
     * is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of
     * the oldest hash.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    randomMaterial: GenericStorageQuery<Rv, () => Array<H256>>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Multisig`'s storage queries
   **/
  multisig: {
    /**
     * The set of open multisig operations.
     *
     * @param {[AccountId32Like, FixedBytes<32>]} arg
     * @param {Callback<PalletMultisigMultisig | undefined> =} callback
     **/
    multisigs: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, FixedBytes<32>]) => PalletMultisigMultisig | undefined,
      [AccountId32, FixedBytes<32>]
    >

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Proxy`'s storage queries
   **/
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyProxyDefinition>, bigint]> =} callback
     **/
    proxies: GenericStorageQuery<Rv, (arg: AccountId32Like) => [Array<PalletProxyProxyDefinition>, bigint], AccountId32>

    /**
     * The announcements made by the proxy (key).
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyAnnouncement>, bigint]> =} callback
     **/
    announcements: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyAnnouncement>, bigint],
      AccountId32
    >

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Vesting`'s storage queries
   **/
  vesting: {
    /**
     * Information regarding the vesting of a given account.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletVestingVestingInfo> | undefined> =} callback
     **/
    vesting: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<PalletVestingVestingInfo> | undefined, AccountId32>

    /**
     * Storage version of the pallet.
     *
     * New networks start with latest version, as determined by the genesis build.
     *
     * @param {Callback<PalletVestingReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<Rv, () => PalletVestingReleases>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Scheduler`'s storage queries
   **/
  scheduler: {
    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    incompleteSince: GenericStorageQuery<Rv, () => number | undefined>

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletSchedulerScheduled | undefined>> =} callback
     **/
    agenda: GenericStorageQuery<Rv, (arg: number) => Array<PalletSchedulerScheduled | undefined>, number>

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    lookup: GenericStorageQuery<Rv, (arg: FixedBytes<32>) => [number, number] | undefined, FixedBytes<32>>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Preimage`'s storage queries
   **/
  preimage: {
    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageOldRequestStatus | undefined> =} callback
     **/
    statusFor: GenericStorageQuery<Rv, (arg: H256) => PalletPreimageOldRequestStatus | undefined, H256>

    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageRequestStatus | undefined> =} callback
     **/
    requestStatusFor: GenericStorageQuery<Rv, (arg: H256) => PalletPreimageRequestStatus | undefined, H256>

    /**
     *
     * @param {[H256, number]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    preimageFor: GenericStorageQuery<Rv, (arg: [H256, number]) => Bytes | undefined, [H256, number]>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `ParachainInfo`'s storage queries
   **/
  parachainInfo: {
    /**
     *
     * @param {Callback<PolkadotParachainPrimitivesPrimitivesId> =} callback
     **/
    parachainId: GenericStorageQuery<Rv, () => PolkadotParachainPrimitivesPrimitivesId>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `ParachainSystem`'s storage queries
   **/
  parachainSystem: {
    /**
     * Latest included block descendants the runtime accepted. In other words, these are
     * ancestors of the currently executing block which have not been included in the observed
     * relay-chain state.
     *
     * The segment length is limited by the capacity returned from the [`ConsensusHook`] configured
     * in the pallet.
     *
     * @param {Callback<Array<CumulusPalletParachainSystemUnincludedSegmentAncestor>> =} callback
     **/
    unincludedSegment: GenericStorageQuery<Rv, () => Array<CumulusPalletParachainSystemUnincludedSegmentAncestor>>

    /**
     * Storage field that keeps track of bandwidth used by the unincluded segment along with the
     * latest the latest HRMP watermark. Used for limiting the acceptance of new blocks with
     * respect to relay chain constraints.
     *
     * @param {Callback<CumulusPalletParachainSystemUnincludedSegmentSegmentTracker | undefined> =} callback
     **/
    aggregatedUnincludedSegment: GenericStorageQuery<
      Rv,
      () => CumulusPalletParachainSystemUnincludedSegmentSegmentTracker | undefined
    >

    /**
     * In case of a scheduled upgrade, this storage field contains the validation code to be
     * applied.
     *
     * As soon as the relay chain gives us the go-ahead signal, we will overwrite the
     * [`:code`][sp_core::storage::well_known_keys::CODE] which will result the next block process
     * with the new validation code. This concludes the upgrade process.
     *
     * @param {Callback<Bytes> =} callback
     **/
    pendingValidationCode: GenericStorageQuery<Rv, () => Bytes>

    /**
     * Validation code that is set by the parachain and is to be communicated to collator and
     * consequently the relay-chain.
     *
     * This will be cleared in `on_initialize` of each new block if no other pallet already set
     * the value.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    newValidationCode: GenericStorageQuery<Rv, () => Bytes | undefined>

    /**
     * The [`PersistedValidationData`] set for this block.
     * This value is expected to be set only once per block and it's never stored
     * in the trie.
     *
     * @param {Callback<PolkadotPrimitivesV6PersistedValidationData | undefined> =} callback
     **/
    validationData: GenericStorageQuery<Rv, () => PolkadotPrimitivesV6PersistedValidationData | undefined>

    /**
     * Were the validation data set to notify the relay chain?
     *
     * @param {Callback<boolean> =} callback
     **/
    didSetValidationCode: GenericStorageQuery<Rv, () => boolean>

    /**
     * The relay chain block number associated with the last parachain block.
     *
     * @param {Callback<number> =} callback
     **/
    lastRelayChainBlockNumber: GenericStorageQuery<Rv, () => number>

    /**
     * An option which indicates if the relay-chain restricts signalling a validation code upgrade.
     * In other words, if this is `Some` and [`NewValidationCode`] is `Some` then the produced
     * candidate will be invalid.
     *
     * This storage item is a mirror of the corresponding value for the current parachain from the
     * relay-chain. This value is ephemeral which means it doesn't hit the storage. This value is
     * set after the inherent.
     *
     * @param {Callback<PolkadotPrimitivesV6UpgradeRestriction | undefined> =} callback
     **/
    upgradeRestrictionSignal: GenericStorageQuery<Rv, () => PolkadotPrimitivesV6UpgradeRestriction | undefined>

    /**
     * Optional upgrade go-ahead signal from the relay-chain.
     *
     * This storage item is a mirror of the corresponding value for the current parachain from the
     * relay-chain. This value is ephemeral which means it doesn't hit the storage. This value is
     * set after the inherent.
     *
     * @param {Callback<PolkadotPrimitivesV6UpgradeGoAhead | undefined> =} callback
     **/
    upgradeGoAhead: GenericStorageQuery<Rv, () => PolkadotPrimitivesV6UpgradeGoAhead | undefined>

    /**
     * The state proof for the last relay parent block.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     *
     * @param {Callback<SpTrieStorageProof | undefined> =} callback
     **/
    relayStateProof: GenericStorageQuery<Rv, () => SpTrieStorageProof | undefined>

    /**
     * The snapshot of some state related to messaging relevant to the current parachain as per
     * the relay parent.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     *
     * @param {Callback<CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot | undefined> =} callback
     **/
    relevantMessagingState: GenericStorageQuery<
      Rv,
      () => CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot | undefined
    >

    /**
     * The parachain host configuration that was obtained from the relay parent.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     *
     * @param {Callback<PolkadotPrimitivesV6AbridgedHostConfiguration | undefined> =} callback
     **/
    hostConfiguration: GenericStorageQuery<Rv, () => PolkadotPrimitivesV6AbridgedHostConfiguration | undefined>

    /**
     * The last downward message queue chain head we have observed.
     *
     * This value is loaded before and saved after processing inbound downward messages carried
     * by the system inherent.
     *
     * @param {Callback<CumulusPrimitivesParachainInherentMessageQueueChain> =} callback
     **/
    lastDmqMqcHead: GenericStorageQuery<Rv, () => CumulusPrimitivesParachainInherentMessageQueueChain>

    /**
     * The message queue chain heads we have observed per each channel incoming channel.
     *
     * This value is loaded before and saved after processing inbound downward messages carried
     * by the system inherent.
     *
     * @param {Callback<Array<[PolkadotParachainPrimitivesPrimitivesId, CumulusPrimitivesParachainInherentMessageQueueChain]>> =} callback
     **/
    lastHrmpMqcHeads: GenericStorageQuery<
      Rv,
      () => Array<[PolkadotParachainPrimitivesPrimitivesId, CumulusPrimitivesParachainInherentMessageQueueChain]>
    >

    /**
     * Number of downward messages processed in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<number> =} callback
     **/
    processedDownwardMessages: GenericStorageQuery<Rv, () => number>

    /**
     * HRMP watermark that was set in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<number> =} callback
     **/
    hrmpWatermark: GenericStorageQuery<Rv, () => number>

    /**
     * HRMP messages that were sent in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<Array<PolkadotCorePrimitivesOutboundHrmpMessage>> =} callback
     **/
    hrmpOutboundMessages: GenericStorageQuery<Rv, () => Array<PolkadotCorePrimitivesOutboundHrmpMessage>>

    /**
     * Upward messages that were sent in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<Array<Bytes>> =} callback
     **/
    upwardMessages: GenericStorageQuery<Rv, () => Array<Bytes>>

    /**
     * Upward messages that are still pending and not yet send to the relay chain.
     *
     * @param {Callback<Array<Bytes>> =} callback
     **/
    pendingUpwardMessages: GenericStorageQuery<Rv, () => Array<Bytes>>

    /**
     * The number of HRMP messages we observed in `on_initialize` and thus used that number for
     * announcing the weight of `on_initialize` and `on_finalize`.
     *
     * @param {Callback<number> =} callback
     **/
    announcedHrmpMessagesPerCandidate: GenericStorageQuery<Rv, () => number>

    /**
     * The weight we reserve at the beginning of the block for processing XCMP messages. This
     * overrides the amount set in the Config trait.
     *
     * @param {Callback<SpWeightsWeightV2Weight | undefined> =} callback
     **/
    reservedXcmpWeightOverride: GenericStorageQuery<Rv, () => SpWeightsWeightV2Weight | undefined>

    /**
     * The weight we reserve at the beginning of the block for processing DMP messages. This
     * overrides the amount set in the Config trait.
     *
     * @param {Callback<SpWeightsWeightV2Weight | undefined> =} callback
     **/
    reservedDmpWeightOverride: GenericStorageQuery<Rv, () => SpWeightsWeightV2Weight | undefined>

    /**
     * The next authorized upgrade, if there is one.
     *
     * @param {Callback<CumulusPalletParachainSystemCodeUpgradeAuthorization | undefined> =} callback
     **/
    authorizedUpgrade: GenericStorageQuery<Rv, () => CumulusPalletParachainSystemCodeUpgradeAuthorization | undefined>

    /**
     * A custom head data that should be returned as result of `validate_block`.
     *
     * See `Pallet::set_custom_validation_head_data` for more information.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    customValidationHeadData: GenericStorageQuery<Rv, () => Bytes | undefined>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `XcmpQueue`'s storage queries
   **/
  xcmpQueue: {
    /**
     * Status of the inbound XCMP channels.
     *
     * @param {Callback<Array<CumulusPalletXcmpQueueInboundChannelDetails>> =} callback
     **/
    inboundXcmpStatus: GenericStorageQuery<Rv, () => Array<CumulusPalletXcmpQueueInboundChannelDetails>>

    /**
     * Inbound aggregate XCMP messages. It can only be one per ParaId/block.
     *
     * @param {[PolkadotParachainPrimitivesPrimitivesId, number]} arg
     * @param {Callback<Bytes> =} callback
     **/
    inboundXcmpMessages: GenericStorageQuery<
      Rv,
      (arg: [PolkadotParachainPrimitivesPrimitivesId, number]) => Bytes,
      [PolkadotParachainPrimitivesPrimitivesId, number]
    >

    /**
     * The non-empty XCMP channels in order of becoming non-empty, and the index of the first
     * and last outbound message. If the two indices are equal, then it indicates an empty
     * queue and there must be a non-`Ok` `OutboundStatus`. We assume queues grow no greater
     * than 65535 items. Queue indices for normal messages begin at one; zero is reserved in
     * case of the need to send a high-priority signal message this block.
     * The bool is true if there is a signal message waiting to be sent.
     *
     * @param {Callback<Array<CumulusPalletXcmpQueueOutboundChannelDetails>> =} callback
     **/
    outboundXcmpStatus: GenericStorageQuery<Rv, () => Array<CumulusPalletXcmpQueueOutboundChannelDetails>>

    /**
     * The messages outbound in a given XCMP channel.
     *
     * @param {[PolkadotParachainPrimitivesPrimitivesId, number]} arg
     * @param {Callback<Bytes> =} callback
     **/
    outboundXcmpMessages: GenericStorageQuery<
      Rv,
      (arg: [PolkadotParachainPrimitivesPrimitivesId, number]) => Bytes,
      [PolkadotParachainPrimitivesPrimitivesId, number]
    >

    /**
     * Any signal messages waiting to be sent.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<Bytes> =} callback
     **/
    signalMessages: GenericStorageQuery<
      Rv,
      (arg: PolkadotParachainPrimitivesPrimitivesId) => Bytes,
      PolkadotParachainPrimitivesPrimitivesId
    >

    /**
     * The configuration which controls the dynamics of the outbound queue.
     *
     * @param {Callback<CumulusPalletXcmpQueueQueueConfigData> =} callback
     **/
    queueConfig: GenericStorageQuery<Rv, () => CumulusPalletXcmpQueueQueueConfigData>

    /**
     * The messages that exceeded max individual message weight budget.
     *
     * These message stay in this storage map until they are manually dispatched via
     * `service_overweight`.
     *
     * @param {bigint} arg
     * @param {Callback<[PolkadotParachainPrimitivesPrimitivesId, number, Bytes] | undefined> =} callback
     **/
    overweight: GenericStorageQuery<
      Rv,
      (arg: bigint) => [PolkadotParachainPrimitivesPrimitivesId, number, Bytes] | undefined,
      bigint
    >

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForOverweight: GenericStorageQuery<Rv, () => number>

    /**
     * The number of overweight messages ever recorded in `Overweight`. Also doubles as the next
     * available free overweight index.
     *
     * @param {Callback<bigint> =} callback
     **/
    overweightCount: GenericStorageQuery<Rv, () => bigint>

    /**
     * Whether or not the XCMP queue is suspended from executing incoming XCMs or not.
     *
     * @param {Callback<boolean> =} callback
     **/
    queueSuspended: GenericStorageQuery<Rv, () => boolean>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `DmpQueue`'s storage queries
   **/
  dmpQueue: {
    /**
     * The configuration.
     *
     * @param {Callback<CumulusPalletDmpQueueConfigData> =} callback
     **/
    configuration: GenericStorageQuery<Rv, () => CumulusPalletDmpQueueConfigData>

    /**
     * The page index.
     *
     * @param {Callback<CumulusPalletDmpQueuePageIndexData> =} callback
     **/
    pageIndex: GenericStorageQuery<Rv, () => CumulusPalletDmpQueuePageIndexData>

    /**
     * The queue pages.
     *
     * @param {number} arg
     * @param {Callback<Array<[number, Bytes]>> =} callback
     **/
    pages: GenericStorageQuery<Rv, (arg: number) => Array<[number, Bytes]>, number>

    /**
     * The overweight messages.
     *
     * @param {bigint} arg
     * @param {Callback<[number, Bytes] | undefined> =} callback
     **/
    overweight: GenericStorageQuery<Rv, (arg: bigint) => [number, Bytes] | undefined, bigint>

    /**
     * Counter for the related counted storage map
     *
     * @param {Callback<number> =} callback
     **/
    counterForOverweight: GenericStorageQuery<Rv, () => number>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PolkadotXcm`'s storage queries
   **/
  polkadotXcm: {
    /**
     * The latest available query index.
     *
     * @param {Callback<bigint> =} callback
     **/
    queryCounter: GenericStorageQuery<Rv, () => bigint>

    /**
     * The ongoing queries.
     *
     * @param {bigint} arg
     * @param {Callback<PalletXcmQueryStatus | undefined> =} callback
     **/
    queries: GenericStorageQuery<Rv, (arg: bigint) => PalletXcmQueryStatus | undefined, bigint>

    /**
     * The existing asset traps.
     *
     * Key is the blake2 256 hash of (origin, versioned `MultiAssets`) pair. Value is the number of
     * times this pair has been trapped (usually just 1 if it exists at all).
     *
     * @param {H256} arg
     * @param {Callback<number> =} callback
     **/
    assetTraps: GenericStorageQuery<Rv, (arg: H256) => number, H256>

    /**
     * Default version to encode XCM when latest version of destination is unknown. If `None`,
     * then the destinations whose XCM version is unknown are considered unreachable.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    safeXcmVersion: GenericStorageQuery<Rv, () => number | undefined>

    /**
     * The Latest versions that we know various locations support.
     *
     * @param {[number, StagingXcmVersionedMultiLocation]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    supportedVersion: GenericStorageQuery<
      Rv,
      (arg: [number, StagingXcmVersionedMultiLocation]) => number | undefined,
      [number, StagingXcmVersionedMultiLocation]
    >

    /**
     * All locations that we have requested version notifications from.
     *
     * @param {[number, StagingXcmVersionedMultiLocation]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    versionNotifiers: GenericStorageQuery<
      Rv,
      (arg: [number, StagingXcmVersionedMultiLocation]) => bigint | undefined,
      [number, StagingXcmVersionedMultiLocation]
    >

    /**
     * The target locations that are subscribed to our version changes, as well as the most recent
     * of our versions we informed them of.
     *
     * @param {[number, StagingXcmVersionedMultiLocation]} arg
     * @param {Callback<[bigint, SpWeightsWeightV2Weight, number] | undefined> =} callback
     **/
    versionNotifyTargets: GenericStorageQuery<
      Rv,
      (arg: [number, StagingXcmVersionedMultiLocation]) => [bigint, SpWeightsWeightV2Weight, number] | undefined,
      [number, StagingXcmVersionedMultiLocation]
    >

    /**
     * Destinations whose latest XCM version we would like to know. Duplicates not allowed, and
     * the `u32` counter is the number of times that a send to the destination has been attempted,
     * which is used as a prioritization.
     *
     * @param {Callback<Array<[StagingXcmVersionedMultiLocation, number]>> =} callback
     **/
    versionDiscoveryQueue: GenericStorageQuery<Rv, () => Array<[StagingXcmVersionedMultiLocation, number]>>

    /**
     * The current migration's stage, if any.
     *
     * @param {Callback<PalletXcmVersionMigrationStage | undefined> =} callback
     **/
    currentMigration: GenericStorageQuery<Rv, () => PalletXcmVersionMigrationStage | undefined>

    /**
     * Fungible assets which we know are locked on a remote chain.
     *
     * @param {[number, AccountId32Like, StagingXcmVersionedAssetId]} arg
     * @param {Callback<PalletXcmRemoteLockedFungibleRecord | undefined> =} callback
     **/
    remoteLockedFungibles: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like, StagingXcmVersionedAssetId]) => PalletXcmRemoteLockedFungibleRecord | undefined,
      [number, AccountId32, StagingXcmVersionedAssetId]
    >

    /**
     * Fungible assets which we know are locked on this chain.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<[bigint, StagingXcmVersionedMultiLocation]> | undefined> =} callback
     **/
    lockedFungibles: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<[bigint, StagingXcmVersionedMultiLocation]> | undefined,
      AccountId32
    >

    /**
     * Global suspension state of the XCM executor.
     *
     * @param {Callback<boolean> =} callback
     **/
    xcmExecutionSuspended: GenericStorageQuery<Rv, () => boolean>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Balances`'s storage queries
   **/
  balances: {
    /**
     * The total units issued in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<Rv, () => bigint>

    /**
     * The total units of outstanding deactivated balance in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    inactiveIssuance: GenericStorageQuery<Rv, () => bigint>

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBalancesAccountData> =} callback
     **/
    account: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletBalancesAccountData, AccountId32>

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesBalanceLock>> =} callback
     **/
    locks: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<PalletBalancesBalanceLock>, AccountId32>

    /**
     * Named reserves on some account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesReserveData>> =} callback
     **/
    reserves: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<PalletBalancesReserveData>, AccountId32>

    /**
     * Holds on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesIdAmount>> =} callback
     **/
    holds: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<PalletBalancesIdAmount>, AccountId32>

    /**
     * Freeze locks on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesIdAmount002>> =} callback
     **/
    freezes: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<PalletBalancesIdAmount002>, AccountId32>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `TransactionPayment`'s storage queries
   **/
  transactionPayment: {
    /**
     *
     * @param {Callback<FixedU128> =} callback
     **/
    nextFeeMultiplier: GenericStorageQuery<Rv, () => FixedU128>

    /**
     *
     * @param {Callback<PalletTransactionPaymentReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<Rv, () => PalletTransactionPaymentReleases>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Assets`'s storage queries
   **/
  assets: {
    /**
     * Details of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetsAssetDetails | undefined> =} callback
     **/
    asset: GenericStorageQuery<Rv, (arg: number) => PalletAssetsAssetDetails | undefined, number>

    /**
     * The holdings of a specific account for a specific asset.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletAssetsAssetAccount | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletAssetsAssetAccount | undefined,
      [number, AccountId32]
    >

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     *
     * @param {[number, AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletAssetsApproval | undefined> =} callback
     **/
    approvals: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like, AccountId32Like]) => PalletAssetsApproval | undefined,
      [number, AccountId32, AccountId32]
    >

    /**
     * Metadata of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetsAssetMetadata> =} callback
     **/
    metadata: GenericStorageQuery<Rv, (arg: number) => PalletAssetsAssetMetadata, number>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Authorship`'s storage queries
   **/
  authorship: {
    /**
     * Author of current block.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    author: GenericStorageQuery<Rv, () => AccountId32 | undefined>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `CollatorSelection`'s storage queries
   **/
  collatorSelection: {
    /**
     * The invulnerable, permissioned collators. This list must be sorted.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    invulnerables: GenericStorageQuery<Rv, () => Array<AccountId32>>

    /**
     * The (community, limited) collation candidates. `Candidates` and `Invulnerables` should be
     * mutually exclusive.
     *
     * @param {Callback<Array<PalletCollatorSelectionCandidateInfo>> =} callback
     **/
    candidates: GenericStorageQuery<Rv, () => Array<PalletCollatorSelectionCandidateInfo>>

    /**
     * Last block authored by collator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number> =} callback
     **/
    lastAuthoredBlock: GenericStorageQuery<Rv, (arg: AccountId32Like) => number, AccountId32>

    /**
     * Desired number of candidates.
     *
     * This should ideally always be less than [`Config::MaxCandidates`] for weights to be correct.
     *
     * @param {Callback<number> =} callback
     **/
    desiredCandidates: GenericStorageQuery<Rv, () => number>

    /**
     * Fixed amount to deposit to become a collator.
     *
     * When a collator calls `leave_intent` they immediately receive the deposit back.
     *
     * @param {Callback<bigint> =} callback
     **/
    candidacyBond: GenericStorageQuery<Rv, () => bigint>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Session`'s storage queries
   **/
  session: {
    /**
     * The current set of validators.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validators: GenericStorageQuery<Rv, () => Array<AccountId32>>

    /**
     * Current index of the session.
     *
     * @param {Callback<number> =} callback
     **/
    currentIndex: GenericStorageQuery<Rv, () => number>

    /**
     * True if the underlying economic identities or weighting behind the validators
     * has changed in the queued validator set.
     *
     * @param {Callback<boolean> =} callback
     **/
    queuedChanged: GenericStorageQuery<Rv, () => boolean>

    /**
     * The queued keys for the next session. When the next session begins, these keys
     * will be used to determine the validator's session keys.
     *
     * @param {Callback<Array<[AccountId32, PhalaParachainRuntimeOpaqueSessionKeys]>> =} callback
     **/
    queuedKeys: GenericStorageQuery<Rv, () => Array<[AccountId32, PhalaParachainRuntimeOpaqueSessionKeys]>>

    /**
     * Indices of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator is
     * disabled using binary search. It gets cleared when `on_session_ending` returns
     * a new set of identities.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    disabledValidators: GenericStorageQuery<Rv, () => Array<number>>

    /**
     * The next session keys for a validator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PhalaParachainRuntimeOpaqueSessionKeys | undefined> =} callback
     **/
    nextKeys: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PhalaParachainRuntimeOpaqueSessionKeys | undefined,
      AccountId32
    >

    /**
     * The owner of a key. The key is the `KeyTypeId` + the encoded key.
     *
     * @param {[SpCoreCryptoKeyTypeId, BytesLike]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    keyOwner: GenericStorageQuery<
      Rv,
      (arg: [SpCoreCryptoKeyTypeId, BytesLike]) => AccountId32 | undefined,
      [SpCoreCryptoKeyTypeId, Bytes]
    >

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Aura`'s storage queries
   **/
  aura: {
    /**
     * The current authority set.
     *
     * @param {Callback<Array<SpConsensusAuraSr25519AppSr25519Public>> =} callback
     **/
    authorities: GenericStorageQuery<Rv, () => Array<SpConsensusAuraSr25519AppSr25519Public>>

    /**
     * The current slot of this block.
     *
     * This will be set in `on_initialize`.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    currentSlot: GenericStorageQuery<Rv, () => SpConsensusSlotsSlot>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `AuraExt`'s storage queries
   **/
  auraExt: {
    /**
     * Serves as cache for the authorities.
     *
     * The authorities in AuRa are overwritten in `on_initialize` when we switch to a new session,
     * but we require the old authorities to verify the seal when validating a PoV. This will
     * always be updated to the latest AuRa authorities in `on_finalize`.
     *
     * @param {Callback<Array<SpConsensusAuraSr25519AppSr25519Public>> =} callback
     **/
    authorities: GenericStorageQuery<Rv, () => Array<SpConsensusAuraSr25519AppSr25519Public>>

    /**
     * Current slot paired with a number of authored blocks.
     *
     * Updated on each block initialization.
     *
     * @param {Callback<[SpConsensusSlotsSlot, number] | undefined> =} callback
     **/
    slotInfo: GenericStorageQuery<Rv, () => [SpConsensusSlotsSlot, number] | undefined>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Identity`'s storage queries
   **/
  identity: {
    /**
     * Information that is pertinent to identify the entity behind an account.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletIdentityRegistration | undefined> =} callback
     **/
    identityOf: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletIdentityRegistration | undefined, AccountId32>

    /**
     * The super-identity of an alternative "sub" identity together with its name, within that
     * context. If the account is not some other account's sub-identity, then just `None`.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[AccountId32, Data] | undefined> =} callback
     **/
    superOf: GenericStorageQuery<Rv, (arg: AccountId32Like) => [AccountId32, Data] | undefined, AccountId32>

    /**
     * Alternative "sub" identities of this account.
     *
     * The first item is the deposit, the second is a vector of the accounts.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[bigint, Array<AccountId32>]> =} callback
     **/
    subsOf: GenericStorageQuery<Rv, (arg: AccountId32Like) => [bigint, Array<AccountId32>], AccountId32>

    /**
     * The set of registrars. Not expected to get very big as can only be added through a
     * special origin (likely a council motion).
     *
     * The index into this can be cast to `RegistrarIndex` to get a valid value.
     *
     * @param {Callback<Array<PalletIdentityRegistrarInfo | undefined>> =} callback
     **/
    registrars: GenericStorageQuery<Rv, () => Array<PalletIdentityRegistrarInfo | undefined>>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Democracy`'s storage queries
   **/
  democracy: {
    /**
     * The number of (public) proposals that have been made so far.
     *
     * @param {Callback<number> =} callback
     **/
    publicPropCount: GenericStorageQuery<Rv, () => number>

    /**
     * The public proposals. Unsorted. The second item is the proposal.
     *
     * @param {Callback<Array<[number, FrameSupportPreimagesBounded, AccountId32]>> =} callback
     **/
    publicProps: GenericStorageQuery<Rv, () => Array<[number, FrameSupportPreimagesBounded, AccountId32]>>

    /**
     * Those who have locked a deposit.
     *
     * TWOX-NOTE: Safe, as increasing integer keys are safe.
     *
     * @param {number} arg
     * @param {Callback<[Array<AccountId32>, bigint] | undefined> =} callback
     **/
    depositOf: GenericStorageQuery<Rv, (arg: number) => [Array<AccountId32>, bigint] | undefined, number>

    /**
     * The next free referendum index, aka the number of referenda started so far.
     *
     * @param {Callback<number> =} callback
     **/
    referendumCount: GenericStorageQuery<Rv, () => number>

    /**
     * The lowest referendum index representing an unbaked referendum. Equal to
     * `ReferendumCount` if there isn't a unbaked referendum.
     *
     * @param {Callback<number> =} callback
     **/
    lowestUnbaked: GenericStorageQuery<Rv, () => number>

    /**
     * Information concerning any given referendum.
     *
     * TWOX-NOTE: SAFE as indexes are not under an attacker’s control.
     *
     * @param {number} arg
     * @param {Callback<PalletDemocracyReferendumInfo | undefined> =} callback
     **/
    referendumInfoOf: GenericStorageQuery<Rv, (arg: number) => PalletDemocracyReferendumInfo | undefined, number>

    /**
     * All votes for a particular voter. We store the balance for the number of votes that we
     * have recorded. The second item is the total amount of delegations, that will be added.
     *
     * TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletDemocracyVoteVoting> =} callback
     **/
    votingOf: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletDemocracyVoteVoting, AccountId32>

    /**
     * True if the last referendum tabled was submitted externally. False if it was a public
     * proposal.
     *
     * @param {Callback<boolean> =} callback
     **/
    lastTabledWasExternal: GenericStorageQuery<Rv, () => boolean>

    /**
     * The referendum to be tabled whenever it would be valid to table an external proposal.
     * This happens when a referendum needs to be tabled and one of two conditions are met:
     * - `LastTabledWasExternal` is `false`; or
     * - `PublicProps` is empty.
     *
     * @param {Callback<[FrameSupportPreimagesBounded, PalletDemocracyVoteThreshold] | undefined> =} callback
     **/
    nextExternal: GenericStorageQuery<
      Rv,
      () => [FrameSupportPreimagesBounded, PalletDemocracyVoteThreshold] | undefined
    >

    /**
     * A record of who vetoed what. Maps proposal hash to a possible existent block number
     * (until when it may not be resubmitted) and who vetoed it.
     *
     * @param {H256} arg
     * @param {Callback<[number, Array<AccountId32>] | undefined> =} callback
     **/
    blacklist: GenericStorageQuery<Rv, (arg: H256) => [number, Array<AccountId32>] | undefined, H256>

    /**
     * Record of all proposals that have been subject to emergency cancellation.
     *
     * @param {H256} arg
     * @param {Callback<boolean> =} callback
     **/
    cancellations: GenericStorageQuery<Rv, (arg: H256) => boolean, H256>

    /**
     * General information concerning any proposal or referendum.
     * The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     *
     * @param {PalletDemocracyMetadataOwner} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    metadataOf: GenericStorageQuery<
      Rv,
      (arg: PalletDemocracyMetadataOwner) => H256 | undefined,
      PalletDemocracyMetadataOwner
    >

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Council`'s storage queries
   **/
  council: {
    /**
     * The hashes of the active proposals.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    proposals: GenericStorageQuery<Rv, () => Array<H256>>

    /**
     * Actual proposal for a given hash, if it's current.
     *
     * @param {H256} arg
     * @param {Callback<PhalaParachainRuntimeRuntimeCall | undefined> =} callback
     **/
    proposalOf: GenericStorageQuery<Rv, (arg: H256) => PhalaParachainRuntimeRuntimeCall | undefined, H256>

    /**
     * Votes on a given proposal, if it is ongoing.
     *
     * @param {H256} arg
     * @param {Callback<PalletCollectiveVotes | undefined> =} callback
     **/
    voting: GenericStorageQuery<Rv, (arg: H256) => PalletCollectiveVotes | undefined, H256>

    /**
     * Proposals so far.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<Rv, () => number>

    /**
     * The current members of the collective. This is stored sorted (just by value).
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>

    /**
     * The prime member that helps determine the default vote behavior in case of absentations.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Treasury`'s storage queries
   **/
  treasury: {
    /**
     * Number of proposals that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<Rv, () => number>

    /**
     * Proposals that have been made.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasuryProposal | undefined> =} callback
     **/
    proposals: GenericStorageQuery<Rv, (arg: number) => PalletTreasuryProposal | undefined, number>

    /**
     * The amount which has been reported as inactive to Currency.
     *
     * @param {Callback<bigint> =} callback
     **/
    deactivated: GenericStorageQuery<Rv, () => bigint>

    /**
     * Proposal indices that have been approved but not yet awarded.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    approvals: GenericStorageQuery<Rv, () => Array<number>>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Bounties`'s storage queries
   **/
  bounties: {
    /**
     * Number of bounty proposals that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    bountyCount: GenericStorageQuery<Rv, () => number>

    /**
     * Bounties that have been made.
     *
     * @param {number} arg
     * @param {Callback<PalletBountiesBounty | undefined> =} callback
     **/
    bounties: GenericStorageQuery<Rv, (arg: number) => PalletBountiesBounty | undefined, number>

    /**
     * The description of each bounty.
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    bountyDescriptions: GenericStorageQuery<Rv, (arg: number) => Bytes | undefined, number>

    /**
     * Bounty indices that have been approved but not yet funded.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    bountyApprovals: GenericStorageQuery<Rv, () => Array<number>>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Lottery`'s storage queries
   **/
  lottery: {
    /**
     *
     * @param {Callback<number> =} callback
     **/
    lotteryIndex: GenericStorageQuery<Rv, () => number>

    /**
     * The configuration for the current lottery.
     *
     * @param {Callback<PalletLotteryLotteryConfig | undefined> =} callback
     **/
    lottery: GenericStorageQuery<Rv, () => PalletLotteryLotteryConfig | undefined>

    /**
     * Users who have purchased a ticket. (Lottery Index, Tickets Purchased)
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[number, Array<[number, number]>]> =} callback
     **/
    participants: GenericStorageQuery<Rv, (arg: AccountId32Like) => [number, Array<[number, number]>], AccountId32>

    /**
     * Total number of tickets sold.
     *
     * @param {Callback<number> =} callback
     **/
    ticketsCount: GenericStorageQuery<Rv, () => number>

    /**
     * Each ticket's owner.
     *
     * May have residual storage from previous lotteries. Use `TicketsCount` to see which ones
     * are actually valid ticket mappings.
     *
     * @param {number} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    tickets: GenericStorageQuery<Rv, (arg: number) => AccountId32 | undefined, number>

    /**
     * The calls stored in this pallet to be used in an active lottery if configured
     * by `Config::ValidateCall`.
     *
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    callIndices: GenericStorageQuery<Rv, () => Array<[number, number]>>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `TechnicalCommittee`'s storage queries
   **/
  technicalCommittee: {
    /**
     * The hashes of the active proposals.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    proposals: GenericStorageQuery<Rv, () => Array<H256>>

    /**
     * Actual proposal for a given hash, if it's current.
     *
     * @param {H256} arg
     * @param {Callback<PhalaParachainRuntimeRuntimeCall | undefined> =} callback
     **/
    proposalOf: GenericStorageQuery<Rv, (arg: H256) => PhalaParachainRuntimeRuntimeCall | undefined, H256>

    /**
     * Votes on a given proposal, if it is ongoing.
     *
     * @param {H256} arg
     * @param {Callback<PalletCollectiveVotes | undefined> =} callback
     **/
    voting: GenericStorageQuery<Rv, (arg: H256) => PalletCollectiveVotes | undefined, H256>

    /**
     * Proposals so far.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<Rv, () => number>

    /**
     * The current members of the collective. This is stored sorted (just by value).
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>

    /**
     * The prime member that helps determine the default vote behavior in case of absentations.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `TechnicalMembership`'s storage queries
   **/
  technicalMembership: {
    /**
     * The current membership, stored as an ordered Vec.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>

    /**
     * The current prime member, if one exists.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PhragmenElection`'s storage queries
   **/
  phragmenElection: {
    /**
     * The current elected members.
     *
     * Invariant: Always sorted based on account id.
     *
     * @param {Callback<Array<PalletElectionsPhragmenSeatHolder>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<PalletElectionsPhragmenSeatHolder>>

    /**
     * The current reserved runners-up.
     *
     * Invariant: Always sorted based on rank (worse to best). Upon removal of a member, the
     * last (i.e. _best_) runner-up will be replaced.
     *
     * @param {Callback<Array<PalletElectionsPhragmenSeatHolder>> =} callback
     **/
    runnersUp: GenericStorageQuery<Rv, () => Array<PalletElectionsPhragmenSeatHolder>>

    /**
     * The present candidate list. A current member or runner-up can never enter this vector
     * and is always implicitly assumed to be a candidate.
     *
     * Second element is the deposit.
     *
     * Invariant: Always sorted based on account id.
     *
     * @param {Callback<Array<[AccountId32, bigint]>> =} callback
     **/
    candidates: GenericStorageQuery<Rv, () => Array<[AccountId32, bigint]>>

    /**
     * The total number of vote rounds that have happened, excluding the upcoming one.
     *
     * @param {Callback<number> =} callback
     **/
    electionRounds: GenericStorageQuery<Rv, () => number>

    /**
     * Votes and locked stake of a particular voter.
     *
     * TWOX-NOTE: SAFE as `AccountId` is a crypto hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletElectionsPhragmenVoter> =} callback
     **/
    voting: GenericStorageQuery<Rv, (arg: AccountId32Like) => PalletElectionsPhragmenVoter, AccountId32>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Tips`'s storage queries
   **/
  tips: {
    /**
     * TipsMap that are not yet completed. Keyed by the hash of `(reason, who)` from the value.
     * This has the insecure enumerable hash function since the key itself is already
     * guaranteed to be a secure hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletTipsOpenTip | undefined> =} callback
     **/
    tips: GenericStorageQuery<Rv, (arg: H256) => PalletTipsOpenTip | undefined, H256>

    /**
     * Simple preimage lookup from the reason's hash to the original data. Again, has an
     * insecure enumerable hash since the key is guaranteed to be the result of a secure hash.
     *
     * @param {H256} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    reasons: GenericStorageQuery<Rv, (arg: H256) => Bytes | undefined, H256>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `ChildBounties`'s storage queries
   **/
  childBounties: {
    /**
     * Number of total child bounties.
     *
     * @param {Callback<number> =} callback
     **/
    childBountyCount: GenericStorageQuery<Rv, () => number>

    /**
     * Number of child bounties per parent bounty.
     * Map of parent bounty index to number of child bounties.
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    parentChildBounties: GenericStorageQuery<Rv, (arg: number) => number, number>

    /**
     * Child bounties that have been added.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletChildBountiesChildBounty | undefined> =} callback
     **/
    childBounties: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletChildBountiesChildBounty | undefined,
      [number, number]
    >

    /**
     * The description of each child-bounty.
     *
     * @param {number} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    childBountyDescriptions: GenericStorageQuery<Rv, (arg: number) => Bytes | undefined, number>

    /**
     * The cumulative child-bounty curator fee for each parent bounty.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    childrenCuratorFees: GenericStorageQuery<Rv, (arg: number) => bigint, number>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `ChainBridge`'s storage queries
   **/
  chainBridge: {
    /**
     *
     * @param {number} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    chainNonces: GenericStorageQuery<Rv, (arg: number) => bigint | undefined, number>

    /**
     *
     * @param {Callback<number> =} callback
     **/
    relayerThreshold: GenericStorageQuery<Rv, () => number>

    /**
     *
     * @param {AccountId32Like} arg
     * @param {Callback<boolean> =} callback
     **/
    relayers: GenericStorageQuery<Rv, (arg: AccountId32Like) => boolean, AccountId32>

    /**
     *
     * @param {Callback<number> =} callback
     **/
    relayerCount: GenericStorageQuery<Rv, () => number>

    /**
     *
     * @param {[number, [bigint, PhalaParachainRuntimeRuntimeCallLike]]} arg
     * @param {Callback<SubbridgePalletsChainbridgePalletProposalVotes | undefined> =} callback
     **/
    votes: GenericStorageQuery<
      Rv,
      (
        arg: [number, [bigint, PhalaParachainRuntimeRuntimeCallLike]]
      ) => SubbridgePalletsChainbridgePalletProposalVotes | undefined,
      [number, [bigint, PhalaParachainRuntimeRuntimeCall]]
    >

    /**
     *
     * @param {Callback<Array<SubbridgePalletsChainbridgePalletBridgeEvent>> =} callback
     **/
    bridgeEvents: GenericStorageQuery<Rv, () => Array<SubbridgePalletsChainbridgePalletBridgeEvent>>

    /**
     *
     * @param {number} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    bridgeFee: GenericStorageQuery<Rv, (arg: number) => bigint | undefined, number>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `XcmBridge`'s storage queries
   **/
  xcmBridge: {
    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `XTransfer`'s storage queries
   **/
  xTransfer: {
    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `AssetsRegistry`'s storage queries
   **/
  assetsRegistry: {
    /**
     * Mapping fungible asset location to corresponding asset id
     *
     * @param {StagingXcmV3MultilocationMultiLocation} arg
     * @param {Callback<number | undefined> =} callback
     **/
    idByLocations: GenericStorageQuery<
      Rv,
      (arg: StagingXcmV3MultilocationMultiLocation) => number | undefined,
      StagingXcmV3MultilocationMultiLocation
    >

    /**
     * Mapping fungible asset resource id to corresponding asset id
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<number | undefined> =} callback
     **/
    idByResourceId: GenericStorageQuery<Rv, (arg: FixedBytes<32>) => number | undefined, FixedBytes<32>>

    /**
     *
     * @param {number} arg
     * @param {Callback<AssetsRegistryAssetRegistryInfo | undefined> =} callback
     **/
    registryInfoByIds: GenericStorageQuery<Rv, (arg: number) => AssetsRegistryAssetRegistryInfo | undefined, number>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PhalaMq`'s storage queries
   **/
  phalaMq: {
    /**
     * The next expected sequence of a ingress message coming from a certain sender (origin)
     *
     * @param {PhalaMqMessageOrigin} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    offchainIngress: GenericStorageQuery<Rv, (arg: PhalaMqMessageOrigin) => bigint | undefined, PhalaMqMessageOrigin>

    /**
     *
     * @param {Callback<Array<PhalaMqMessage> | undefined> =} callback
     **/
    queuedOutboundMessage: GenericStorageQuery<Rv, () => Array<PhalaMqMessage> | undefined>

    /**
     * Outbound messages at the current block.
     *
     * It will be cleared at the beginning of every block.
     *
     * @param {Callback<Array<PhalaMqMessage>> =} callback
     **/
    outboundMessages: GenericStorageQuery<Rv, () => Array<PhalaMqMessage>>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PhalaRegistry`'s storage queries
   **/
  phalaRegistry: {
    /**
     * Gatekeeper pubkey list
     *
     * @param {Callback<Array<SpCoreSr25519Public>> =} callback
     **/
    gatekeeper: GenericStorageQuery<Rv, () => Array<SpCoreSr25519Public>>

    /**
     * Gatekeeper master pubkey
     *
     * @param {Callback<SpCoreSr25519Public | undefined> =} callback
     **/
    gatekeeperMasterPubkey: GenericStorageQuery<Rv, () => SpCoreSr25519Public | undefined>

    /**
     * The block number and unix timestamp when the gatekeeper is launched
     *
     * @param {Callback<[number, bigint] | undefined> =} callback
     **/
    gatekeeperLaunchedAt: GenericStorageQuery<Rv, () => [number, bigint] | undefined>

    /**
     * The rotation counter starting from 1, it always equals to the latest rotation id.
     * The totation id 0 is reserved for the first master key before we introduce the rotation.
     *
     * @param {Callback<bigint> =} callback
     **/
    rotationCounter: GenericStorageQuery<Rv, () => bigint>

    /**
     * Current rotation info including rotation id
     *
     * Only one rotation process is allowed at one time.
     * Since the rotation request is broadcasted to all gatekeepers, it should be finished only if there is one functional
     * gatekeeper.
     *
     * @param {Callback<bigint | undefined> =} callback
     **/
    masterKeyRotationLock: GenericStorageQuery<Rv, () => bigint | undefined>

    /**
     * Mapping from worker pubkey to WorkerInfo
     *
     * @param {SpCoreSr25519Public} arg
     * @param {Callback<PhalaPalletsRegistryPalletWorkerInfoV2 | undefined> =} callback
     **/
    workers: GenericStorageQuery<
      Rv,
      (arg: SpCoreSr25519Public) => PhalaPalletsRegistryPalletWorkerInfoV2 | undefined,
      SpCoreSr25519Public
    >

    /**
     * The first time registered block number for each worker.
     *
     * @param {SpCoreSr25519Public} arg
     * @param {Callback<number | undefined> =} callback
     **/
    workerAddedAt: GenericStorageQuery<Rv, (arg: SpCoreSr25519Public) => number | undefined, SpCoreSr25519Public>

    /**
     * Mapping from contract address to pubkey
     *
     * @param {H256} arg
     * @param {Callback<SpCoreSr25519Public | undefined> =} callback
     **/
    contractKeys: GenericStorageQuery<Rv, (arg: H256) => SpCoreSr25519Public | undefined, H256>

    /**
     *
     * @param {H256} arg
     * @param {Callback<SpCoreSr25519Public | undefined> =} callback
     **/
    clusterKeys: GenericStorageQuery<Rv, (arg: H256) => SpCoreSr25519Public | undefined, H256>

    /**
     * Pubkey for secret topics.
     *
     * @param {BytesLike} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    topicKey: GenericStorageQuery<Rv, (arg: BytesLike) => Bytes | undefined, Bytes>

    /**
     * The number of blocks to run the benchmark
     *
     * @param {Callback<number | undefined> =} callback
     **/
    benchmarkDuration: GenericStorageQuery<Rv, () => number | undefined>

    /**
     * Allow list of pRuntime binary digest
     *
     * Only pRuntime within the list can register.
     *
     * @param {Callback<Array<Bytes>> =} callback
     **/
    pRuntimeAllowList: GenericStorageQuery<Rv, () => Array<Bytes>>

    /**
     * The effective height of pRuntime binary
     *
     * @param {BytesLike} arg
     * @param {Callback<number | undefined> =} callback
     **/
    pRuntimeAddedAt: GenericStorageQuery<Rv, (arg: BytesLike) => number | undefined, Bytes>

    /**
     * Allow list of relaychain genesis
     *
     * Only genesis within the list can do register.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    relaychainGenesisBlockHashAllowList: GenericStorageQuery<Rv, () => Array<H256>>

    /**
     * Mapping from worker pubkey to Phala Network identity
     *
     * @param {SpCoreSr25519Public} arg
     * @param {Callback<PhalaTypesVersionedWorkerEndpoints | undefined> =} callback
     **/
    endpoints: GenericStorageQuery<
      Rv,
      (arg: SpCoreSr25519Public) => PhalaTypesVersionedWorkerEndpoints | undefined,
      SpCoreSr25519Public
    >

    /**
     * Allow list of pRuntime binary digest
     *
     * Only pRuntime within the list can register.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    tempWorkersIterKey: GenericStorageQuery<Rv, () => Bytes | undefined>

    /**
     * PRuntimes whoes version less than MinimumPRuntimeVersion would be forced to quit.
     *
     * @param {Callback<[number, number, number]> =} callback
     **/
    minimumPRuntimeVersion: GenericStorageQuery<Rv, () => [number, number, number]>

    /**
     * The consensus version used by pruntime. PRuntimes would switch some code path according
     * the current consensus version.
     *
     * @param {Callback<number> =} callback
     **/
    pRuntimeConsensusVersion: GenericStorageQuery<Rv, () => number>

    /**
     * The max consensus version that pruntime has report via register_worker
     *
     * @param {Callback<PhalaPalletsRegistryPalletKnownConsensusVersion> =} callback
     **/
    maxKnownPRuntimeConsensusVersion: GenericStorageQuery<Rv, () => PhalaPalletsRegistryPalletKnownConsensusVersion>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PhalaComputation`'s storage queries
   **/
  phalaComputation: {
    /**
     * Tokenomic parameters used by Gatekeepers to compute the V promote.
     *
     * @param {Callback<PhalaTypesMessagingTokenomicParameters | undefined> =} callback
     **/
    tokenomicParameters: GenericStorageQuery<Rv, () => PhalaTypesMessagingTokenomicParameters | undefined>

    /**
     * The scheduled new tokenomic params to update at the end of this block.
     *
     * @param {Callback<PhalaTypesMessagingTokenomicParameters | undefined> =} callback
     **/
    scheduledTokenomicUpdate: GenericStorageQuery<Rv, () => PhalaTypesMessagingTokenomicParameters | undefined>

    /**
     * Total online workers including WorkerIdle and WorkerUnresponsive workers.
     *
     * Increased when a worker is turned to WorkerIdle; decreased when turned to CoolingDown.
     *
     * @param {Callback<number> =} callback
     **/
    onlineWorkers: GenericStorageQuery<Rv, () => number>

    /**
     * The expected heartbeat count at every block (default: 20)
     *
     * @param {Callback<number | undefined> =} callback
     **/
    expectedHeartbeatCount: GenericStorageQuery<Rv, () => number | undefined>

    /**
     * Won't sent heartbeat challenges to the the worker if enabled.
     *
     * @param {Callback<boolean> =} callback
     **/
    heartbeatPaused: GenericStorageQuery<Rv, () => boolean>

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    maxBudgetLimit: GenericStorageQuery<Rv, () => bigint>

    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    budgetUpdateNonce: GenericStorageQuery<Rv, () => bigint>

    /**
     *
     * @param {Callback<number> =} callback
     **/
    lastBudgetUpdateBlock: GenericStorageQuery<Rv, () => number>

    /**
     *
     * @param {Callback<AccountId32> =} callback
     **/
    contractAccount: GenericStorageQuery<Rv, () => AccountId32>

    /**
     * The miner state.
     *
     * The session state is created when a worker is bounded with a session, but it will be kept even
     * if the worker is force unbound. A re-bind of a worker will reset the computing state.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PhalaPalletsComputeComputationPalletSessionInfo | undefined> =} callback
     **/
    sessions: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PhalaPalletsComputeComputationPalletSessionInfo | undefined,
      AccountId32
    >

    /**
     * The bound worker for a session account
     *
     * @param {AccountId32Like} arg
     * @param {Callback<SpCoreSr25519Public | undefined> =} callback
     **/
    sessionBindings: GenericStorageQuery<Rv, (arg: AccountId32Like) => SpCoreSr25519Public | undefined, AccountId32>

    /**
     * The bound worker account for a worker
     *
     * @param {SpCoreSr25519Public} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    workerBindings: GenericStorageQuery<Rv, (arg: SpCoreSr25519Public) => AccountId32 | undefined, SpCoreSr25519Public>

    /**
     * The cool down period (in sec)
     *
     * @param {Callback<bigint> =} callback
     **/
    coolDownPeriod: GenericStorageQuery<Rv, () => bigint>

    /**
     * The next id to assign to a computing session
     *
     * @param {Callback<number> =} callback
     **/
    nextSessionId: GenericStorageQuery<Rv, () => number>

    /**
     * The block number when the computing starts. Used to calculate halving.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    computingStartBlock: GenericStorageQuery<Rv, () => number | undefined>

    /**
     * The interval of halving (75% decay) in block number.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    computingHalvingInterval: GenericStorageQuery<Rv, () => number | undefined>

    /**
     * The stakes of session accounts.
     *
     * Only presents for computing and cooling down sessions.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    stakes: GenericStorageQuery<Rv, (arg: AccountId32Like) => bigint | undefined, AccountId32>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PhalaStakePool`'s storage queries
   **/
  phalaStakePool: {
    /**
     * Mapping from pool id to PoolInfo
     *
     * @param {bigint} arg
     * @param {Callback<PhalaPalletsStakePoolPalletPoolInfo | undefined> =} callback
     **/
    stakePools: GenericStorageQuery<Rv, (arg: bigint) => PhalaPalletsStakePoolPalletPoolInfo | undefined, bigint>

    /**
     * Mapping from (pid, staker) to UserStakeInfo
     *
     * @param {[bigint, AccountId32Like]} arg
     * @param {Callback<PhalaPalletsStakePoolPalletUserStakeInfo | undefined> =} callback
     **/
    poolStakers: GenericStorageQuery<
      Rv,
      (arg: [bigint, AccountId32Like]) => PhalaPalletsStakePoolPalletUserStakeInfo | undefined,
      [bigint, AccountId32]
    >

    /**
     * The number of total pools
     *
     * @param {Callback<bigint> =} callback
     **/
    poolCount: GenericStorageQuery<Rv, () => bigint>

    /**
     * Mapping from workers to the pool they belong to
     *
     * The map entry lasts from `add_worker()` to `remove_worker()` or force unbinding.
     *
     * @param {SpCoreSr25519Public} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    workerAssignments: GenericStorageQuery<Rv, (arg: SpCoreSr25519Public) => bigint | undefined, SpCoreSr25519Public>

    /**
     * (Deprecated)
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    subAccountAssignments: GenericStorageQuery<Rv, (arg: AccountId32Like) => bigint | undefined, AccountId32>

    /**
     * Mapping staker to it's the balance locked in all pools
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    stakeLedger: GenericStorageQuery<Rv, (arg: AccountId32Like) => bigint | undefined, AccountId32>

    /**
     * Mapping from the block timestamp to pools that has withdrawal requests queued in that block
     *
     * @param {bigint} arg
     * @param {Callback<Array<bigint> | undefined> =} callback
     **/
    withdrawalQueuedPools: GenericStorageQuery<Rv, (arg: bigint) => Array<bigint> | undefined, bigint>

    /**
     * Queue that contains all block's timestamp, in that block contains the waiting withdraw reqeust.
     * This queue has a max size of (T::GracePeriod * 8) bytes
     *
     * @param {Callback<Array<bigint>> =} callback
     **/
    withdrawalTimestamps: GenericStorageQuery<Rv, () => Array<bigint>>

    /**
     * Helper storage to track the preimage of the mining sub-accounts. Not used in consensus.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[bigint, SpCoreSr25519Public] | undefined> =} callback
     **/
    subAccountPreimages: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [bigint, SpCoreSr25519Public] | undefined,
      AccountId32
    >

    /**
     * Mapping for pools that specify certain stakers to contribute stakes
     *
     * @param {bigint} arg
     * @param {Callback<Array<AccountId32> | undefined> =} callback
     **/
    poolContributionWhitelists: GenericStorageQuery<Rv, (arg: bigint) => Array<AccountId32> | undefined, bigint>

    /**
     * Mapping for pools that store their descriptions set by owner
     *
     * @param {bigint} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    poolDescriptions: GenericStorageQuery<Rv, (arg: bigint) => Bytes | undefined, bigint>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PhalaStakePoolv2`'s storage queries
   **/
  phalaStakePoolv2: {
    /**
     *
     * @param {[AccountId32Like, bigint]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    legacyRewards: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, bigint]) => bigint | undefined,
      [AccountId32, bigint]
    >

    /**
     * Mapping from workers to the pool they belong to
     *
     * The map entry lasts from `add_worker()` to `remove_worker()` or force unbinding.
     *
     * @param {SpCoreSr25519Public} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    workerAssignments: GenericStorageQuery<Rv, (arg: SpCoreSr25519Public) => bigint | undefined, SpCoreSr25519Public>

    /**
     * (Deprecated)
     *
     * @param {AccountId32Like} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    subAccountAssignments: GenericStorageQuery<Rv, (arg: AccountId32Like) => bigint | undefined, AccountId32>

    /**
     * Helper storage to track the preimage of the computing sub-accounts. Not used in consensus.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[bigint, SpCoreSr25519Public] | undefined> =} callback
     **/
    subAccountPreimages: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [bigint, SpCoreSr25519Public] | undefined,
      AccountId32
    >

    /**
     *
     * @param {Callback<bigint | undefined> =} callback
     **/
    stakepoolIterateStartPos: GenericStorageQuery<Rv, () => bigint | undefined>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PhalaVault`'s storage queries
   **/
  phalaVault: {
    /**
     * Mapping from the vault pid to its owner authority locking status
     *
     * Using to forbid vault's owner to trigger an withdraw for the vault and override the withdraw request issued by `force shutdown`.
     *
     * @param {bigint} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    vaultLocks: GenericStorageQuery<Rv, (arg: bigint) => [] | undefined, bigint>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PhalaWrappedBalances`'s storage queries
   **/
  phalaWrappedBalances: {
    /**
     * Mapping from the vote ids and accounts to the amounts of W-PHA used to approve or oppose to the vote
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<[bigint, bigint] | undefined> =} callback
     **/
    voteAccountMap: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => [bigint, bigint] | undefined,
      [number, AccountId32]
    >

    /**
     * Mapping from the accounts and vote ids to the amounts of W-PHA used to approve or oppose to the vote
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    accountVoteMap: GenericStorageQuery<Rv, (arg: [AccountId32Like, number]) => [] | undefined, [AccountId32, number]>

    /**
     * Mapping for users to their asset status proxys
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PhalaPalletsComputeWrappedBalancesPalletFinanceAccount | undefined> =} callback
     **/
    stakerAccounts: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PhalaPalletsComputeWrappedBalancesPalletFinanceAccount | undefined,
      AccountId32
    >

    /**
     * Collect the unmintable dust
     *
     * @param {Callback<bigint> =} callback
     **/
    unmintableDust: GenericStorageQuery<Rv, () => bigint>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PhalaBasePool`'s storage queries
   **/
  phalaBasePool: {
    /**
     * Mapping from the next self-increased nft ids to collections
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    nextNftId: GenericStorageQuery<Rv, (arg: number) => number, number>

    /**
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    lockIterateStartPos: GenericStorageQuery<Rv, () => [number, number] | undefined>

    /**
     * The number of total pools
     *
     * @param {Callback<bigint> =} callback
     **/
    poolCount: GenericStorageQuery<Rv, () => bigint>

    /**
     * Mapping from collectionids to pids
     *
     * @param {number} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    poolCollections: GenericStorageQuery<Rv, (arg: number) => bigint | undefined, number>

    /**
     * The Next available collectionid to be created
     *
     * @param {Callback<number> =} callback
     **/
    collectionIndex: GenericStorageQuery<Rv, () => number>

    /**
     * Mapping from pids to pools (including stake pools and vaults)
     *
     * @param {bigint} arg
     * @param {Callback<PhalaPalletsComputePoolProxy | undefined> =} callback
     **/
    pools: GenericStorageQuery<Rv, (arg: bigint) => PhalaPalletsComputePoolProxy | undefined, bigint>

    /**
     * Mapping from the NftId to its internal locking status
     *
     * Used to ensure nft attributes can't be read and override when it has already be accessed and haven't updated yet.
     *
     * @param {[number, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    nftLocks: GenericStorageQuery<Rv, (arg: [number, number]) => [] | undefined, [number, number]>

    /**
     * Mapping for pools that specify certain stakers to contribute stakes
     *
     * @param {bigint} arg
     * @param {Callback<Array<AccountId32> | undefined> =} callback
     **/
    poolContributionWhitelists: GenericStorageQuery<Rv, (arg: bigint) => Array<AccountId32> | undefined, bigint>

    /**
     * Mapping for pools that store their descriptions set by owner
     *
     * @param {bigint} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    poolDescriptions: GenericStorageQuery<Rv, (arg: bigint) => Bytes | undefined, bigint>

    /**
     * Claimable reimbursement due to previous on-chain issues.
     *
     * @param {[AccountId32Like, bigint]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    reimbursements: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, bigint]) => bigint | undefined,
      [AccountId32, bigint]
    >

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PhalaPhatContracts`'s storage queries
   **/
  phalaPhatContracts: {
    /**
     *
     * @param {H256} arg
     * @param {Callback<PhalaPalletsPhatPalletBasicContractInfo | undefined> =} callback
     **/
    contracts: GenericStorageQuery<Rv, (arg: H256) => PhalaPalletsPhatPalletBasicContractInfo | undefined, H256>

    /**
     * The contract cluster counter, it always equals to the latest cluster id.
     *
     * @param {Callback<bigint> =} callback
     **/
    clusterCounter: GenericStorageQuery<Rv, () => bigint>

    /**
     *
     * @param {H256} arg
     * @param {Callback<PhalaTypesContractClusterInfo | undefined> =} callback
     **/
    clusters: GenericStorageQuery<Rv, (arg: H256) => PhalaTypesContractClusterInfo | undefined, H256>

    /**
     *
     * @param {H256} arg
     * @param {Callback<Array<H256>> =} callback
     **/
    clusterContracts: GenericStorageQuery<Rv, (arg: H256) => Array<H256>, H256>

    /**
     *
     * @param {H256} arg
     * @param {Callback<Array<SpCoreSr25519Public>> =} callback
     **/
    clusterWorkers: GenericStorageQuery<Rv, (arg: H256) => Array<SpCoreSr25519Public>, H256>

    /**
     *
     * @param {SpCoreSr25519Public} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    clusterByWorkers: GenericStorageQuery<Rv, (arg: SpCoreSr25519Public) => H256 | undefined, SpCoreSr25519Public>

    /**
     * The pink-system contract code used to deploy new clusters
     *
     * @param {Callback<[number, Bytes]> =} callback
     **/
    pinkSystemCode: GenericStorageQuery<Rv, () => [number, Bytes]>

    /**
     * The blake2_256 hash of the pink-system contract code.
     *
     * @param {Callback<H256 | undefined> =} callback
     **/
    pinkSystemCodeHash: GenericStorageQuery<Rv, () => H256 | undefined>

    /**
     * The pink-runtime version used to deploy new clusters.
     * See also: `phactory::storage::pink_runtime_version`.
     *
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    pinkRuntimeVersion: GenericStorageQuery<Rv, () => [number, number] | undefined>

    /**
     * The next pink-system contract code to be applied from the next block
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    nextPinkSystemCode: GenericStorageQuery<Rv, () => Bytes | undefined>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PhalaPhatTokenomic`'s storage queries
   **/
  phalaPhatTokenomic: {
    /**
     * Stake of user to contract
     *
     * @param {[AccountId32Like, H256]} arg
     * @param {Callback<bigint> =} callback
     **/
    contractUserStakes: GenericStorageQuery<Rv, (arg: [AccountId32Like, H256]) => bigint, [AccountId32, H256]>

    /**
     * Map of contracts to their total stakes received
     *
     * @param {H256} arg
     * @param {Callback<bigint> =} callback
     **/
    contractTotalStakes: GenericStorageQuery<Rv, (arg: H256) => bigint, H256>

    /**
     * Minimum allowed stake
     *
     * @param {Callback<bigint> =} callback
     **/
    minStake: GenericStorageQuery<Rv, () => bigint>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `Uniques`'s storage queries
   **/
  uniques: {
    /**
     * Details of a collection.
     *
     * @param {number} arg
     * @param {Callback<PalletUniquesCollectionDetails | undefined> =} callback
     **/
    class: GenericStorageQuery<Rv, (arg: number) => PalletUniquesCollectionDetails | undefined, number>

    /**
     * The collection, if any, of which an account is willing to take ownership.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<number | undefined> =} callback
     **/
    ownershipAcceptance: GenericStorageQuery<Rv, (arg: AccountId32Like) => number | undefined, AccountId32>

    /**
     * The items held by any given account; set out this way so that items owned by a single
     * account can be enumerated.
     *
     * @param {[AccountId32Like, number, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: [AccountId32Like, number, number]) => [] | undefined,
      [AccountId32, number, number]
    >

    /**
     * The collections owned by any given account; set out this way so that collections owned by
     * a single account can be enumerated.
     *
     * @param {[AccountId32Like, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    classAccount: GenericStorageQuery<Rv, (arg: [AccountId32Like, number]) => [] | undefined, [AccountId32, number]>

    /**
     * The items in existence and their ownership details.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletUniquesItemDetails | undefined> =} callback
     **/
    asset: GenericStorageQuery<Rv, (arg: [number, number]) => PalletUniquesItemDetails | undefined, [number, number]>

    /**
     * Metadata of a collection.
     *
     * @param {number} arg
     * @param {Callback<PalletUniquesCollectionMetadata | undefined> =} callback
     **/
    classMetadataOf: GenericStorageQuery<Rv, (arg: number) => PalletUniquesCollectionMetadata | undefined, number>

    /**
     * Metadata of an item.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletUniquesItemMetadata | undefined> =} callback
     **/
    instanceMetadataOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletUniquesItemMetadata | undefined,
      [number, number]
    >

    /**
     * Attributes of a collection.
     *
     * @param {[number, number | undefined, BytesLike]} arg
     * @param {Callback<[Bytes, bigint] | undefined> =} callback
     **/
    attribute: GenericStorageQuery<
      Rv,
      (arg: [number, number | undefined, BytesLike]) => [Bytes, bigint] | undefined,
      [number, number | undefined, Bytes]
    >

    /**
     * Price of an asset instance.
     *
     * @param {[number, number]} arg
     * @param {Callback<[bigint, AccountId32 | undefined] | undefined> =} callback
     **/
    itemPriceOf: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => [bigint, AccountId32 | undefined] | undefined,
      [number, number]
    >

    /**
     * Keeps track of the number of items a collection might have.
     *
     * @param {number} arg
     * @param {Callback<number | undefined> =} callback
     **/
    collectionMaxSupply: GenericStorageQuery<Rv, (arg: number) => number | undefined, number>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `RmrkCore`'s storage queries
   **/
  rmrkCore: {
    /**
     * Stores collections info
     *
     * @param {number} arg
     * @param {Callback<RmrkTraitsCollectionCollectionInfo | undefined> =} callback
     **/
    collections: GenericStorageQuery<Rv, (arg: number) => RmrkTraitsCollectionCollectionInfo | undefined, number>

    /**
     * Stores nft info
     *
     * @param {[number, number]} arg
     * @param {Callback<RmrkTraitsNftNftInfo | undefined> =} callback
     **/
    nfts: GenericStorageQuery<Rv, (arg: [number, number]) => RmrkTraitsNftNftInfo | undefined, [number, number]>

    /**
     * Stores priority info
     *
     * @param {[number, number, number]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    priorities: GenericStorageQuery<Rv, (arg: [number, number, number]) => number | undefined, [number, number, number]>

    /**
     * Stores nft children info
     *
     * @param {[[number, number], [number, number]]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    children: GenericStorageQuery<
      Rv,
      (arg: [[number, number], [number, number]]) => [] | undefined,
      [[number, number], [number, number]]
    >

    /**
     * Stores resource info
     *
     * @param {[number, number, number]} arg
     * @param {Callback<RmrkTraitsResourceResourceInfo | undefined> =} callback
     **/
    resources: GenericStorageQuery<
      Rv,
      (arg: [number, number, number]) => RmrkTraitsResourceResourceInfo | undefined,
      [number, number, number]
    >

    /**
     * Stores the existence of a base for a particular NFT
     * This is populated on `add_composable_resource`, and is
     * used in the rmrk-equip pallet when equipping a resource.
     *
     * @param {[number, number, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    equippableBases: GenericStorageQuery<
      Rv,
      (arg: [number, number, number]) => [] | undefined,
      [number, number, number]
    >

    /**
     * Stores the existence of a Base + Slot for a particular
     * NFT's particular resource. This is populated on
     * `add_slot_resource`, and is used in the rmrk-equip
     * pallet when equipping a resource.
     *
     * @param {[number, number, number, number, number]} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    equippableSlots: GenericStorageQuery<
      Rv,
      (arg: [number, number, number, number, number]) => [] | undefined,
      [number, number, number, number, number]
    >

    /**
     * Arbitrary properties / metadata of an asset.
     *
     * @param {[number, number | undefined, BytesLike]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    properties: GenericStorageQuery<
      Rv,
      (arg: [number, number | undefined, BytesLike]) => Bytes | undefined,
      [number, number | undefined, Bytes]
    >

    /**
     * Lock for NFTs
     *
     * @param {[number, number]} arg
     * @param {Callback<boolean> =} callback
     **/
    lock: GenericStorageQuery<Rv, (arg: [number, number]) => boolean, [number, number]>

    /**
     * This storage is not used by the chain.
     * It is need only for PolkadotJS types generation.
     *
     * The stored types are use in the RPC interface only,
     * PolkadotJS won't generate TS types for them without this storage.
     *
     * @param {Callback<[RmrkTraitsNftNftChild, PhantomType] | undefined> =} callback
     **/
    dummyStorage: GenericStorageQuery<Rv, () => [RmrkTraitsNftNftChild, PhantomType] | undefined>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `RmrkEquip`'s storage queries
   **/
  rmrkEquip: {
    /**
     * Stores Bases info (issuer, base_type, symbol, parts)
     * TODO https://github.com/rmrk-team/rmrk-substrate/issues/98
     * Delete Parts from Bases info, as it's kept in Parts storage
     *
     * @param {number} arg
     * @param {Callback<RmrkTraitsBaseBaseInfo | undefined> =} callback
     **/
    bases: GenericStorageQuery<Rv, (arg: number) => RmrkTraitsBaseBaseInfo | undefined, number>

    /**
     * Stores Parts (either FixedPart or SlotPart)
     * - SlotPart: id, equippable (list), src, z
     * - FixedPart: id, src, z
     *
     * @param {[number, number]} arg
     * @param {Callback<RmrkTraitsPartPartType | undefined> =} callback
     **/
    parts: GenericStorageQuery<Rv, (arg: [number, number]) => RmrkTraitsPartPartType | undefined, [number, number]>

    /**
     * Stores the incrementing NextBaseId
     *
     * @param {Callback<number> =} callback
     **/
    nextBaseId: GenericStorageQuery<Rv, () => number>

    /**
     * Stores the incrementing NextPartId
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    nextPartId: GenericStorageQuery<Rv, (arg: number) => number, number>

    /**
     * Stores Equippings info ((equipper, base, slot), equipped_resource)
     *
     * @param {[[number, number], number, number]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    equippings: GenericStorageQuery<
      Rv,
      (arg: [[number, number], number, number]) => number | undefined,
      [[number, number], number, number]
    >

    /**
     * Stores Theme info ((base, theme name, property key), property value)
     *
     * @param {[number, BytesLike, BytesLike]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    themes: GenericStorageQuery<Rv, (arg: [number, BytesLike, BytesLike]) => Bytes | undefined, [number, Bytes, Bytes]>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `RmrkMarket`'s storage queries
   **/
  rmrkMarket: {
    /**
     * Stores listed NFT price info
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletRmrkMarketListInfo | undefined> =} callback
     **/
    listedNfts: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletRmrkMarketListInfo | undefined,
      [number, number]
    >

    /**
     * Stores offer on a NFT info
     *
     * @param {[[number, number], AccountId32Like]} arg
     * @param {Callback<PalletRmrkMarketOffer | undefined> =} callback
     **/
    offers: GenericStorageQuery<
      Rv,
      (arg: [[number, number], AccountId32Like]) => PalletRmrkMarketOffer | undefined,
      [[number, number], AccountId32]
    >

    /**
     * Stores the marketplace owner account
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    marketplaceOwner: GenericStorageQuery<Rv, () => AccountId32 | undefined>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `SygmaAccessSegregator`'s storage queries
   **/
  sygmaAccessSegregator: {
    /**
     * Mapping signature of extrinsic to account has access
     * (pallet_index, extrinsic_name) => account
     *
     * @param {[number, BytesLike]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    extrinsicAccess: GenericStorageQuery<Rv, (arg: [number, BytesLike]) => AccountId32 | undefined, [number, Bytes]>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `SygmaBasicFeeHandler`'s storage queries
   **/
  sygmaBasicFeeHandler: {
    /**
     * Mapping fungible asset id to corresponding fee amount
     *
     * @param {[number, StagingXcmV3MultiassetAssetId]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    assetFees: GenericStorageQuery<
      Rv,
      (arg: [number, StagingXcmV3MultiassetAssetId]) => bigint | undefined,
      [number, StagingXcmV3MultiassetAssetId]
    >

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `SygmaBridge`'s storage queries
   **/
  sygmaBridge: {
    /**
     * Deposit counter of dest domain
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    depositCounts: GenericStorageQuery<Rv, (arg: number) => bigint, number>

    /**
     * Bridge Pause indicator
     * Bridge is unpaused initially, until pause
     * After mpc address setup, bridge should be paused until ready to unpause
     *
     * @param {number} arg
     * @param {Callback<boolean> =} callback
     **/
    isPaused: GenericStorageQuery<Rv, (arg: number) => boolean, number>

    /**
     * Pre-set MPC address
     *
     * @param {Callback<SygmaTraitsMpcAddress> =} callback
     **/
    mpcAddr: GenericStorageQuery<Rv, () => SygmaTraitsMpcAddress>

    /**
     * Mark whether a deposit nonce was used. Used to mark execution status of a proposal.
     *
     * @param {[number, bigint]} arg
     * @param {Callback<bigint> =} callback
     **/
    usedNonces: GenericStorageQuery<Rv, (arg: [number, bigint]) => bigint, [number, bigint]>

    /**
     * Mark supported dest domainID
     *
     * @param {number} arg
     * @param {Callback<boolean> =} callback
     **/
    destDomainIds: GenericStorageQuery<Rv, (arg: number) => boolean, number>

    /**
     * Mark the pairs for supported dest domainID with its corresponding chainID
     * The chainID is not directly used in pallet, this map is designed more about rechecking the
     * domainID
     *
     * @param {number} arg
     * @param {Callback<U256 | undefined> =} callback
     **/
    destChainIds: GenericStorageQuery<Rv, (arg: number) => U256 | undefined, number>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `SygmaFeeHandlerRouter`'s storage queries
   **/
  sygmaFeeHandlerRouter: {
    /**
     * Return the Fee handler type based on domainID and assetID
     *
     * @param {[number, StagingXcmV3MultiassetAssetId]} arg
     * @param {Callback<SygmaFeeHandlerRouterFeeHandlerType | undefined> =} callback
     **/
    handlerType: GenericStorageQuery<
      Rv,
      (arg: [number, StagingXcmV3MultiassetAssetId]) => SygmaFeeHandlerRouterFeeHandlerType | undefined,
      [number, StagingXcmV3MultiassetAssetId]
    >

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `SygmaWrapper`'s storage queries
   **/
  sygmaWrapper: {
    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `SygmaPercentageFeeHandler`'s storage queries
   **/
  sygmaPercentageFeeHandler: {
    /**
     * Mapping fungible asset id with domain id to fee rate and its lower bound, upperbound
     *
     * @param {[number, StagingXcmV3MultiassetAssetId]} arg
     * @param {Callback<[number, bigint, bigint] | undefined> =} callback
     **/
    assetFeeRate: GenericStorageQuery<
      Rv,
      (arg: [number, StagingXcmV3MultiassetAssetId]) => [number, bigint, bigint] | undefined,
      [number, StagingXcmV3MultiassetAssetId]
    >

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
  /**
   * Pallet `PalletIndex`'s storage queries
   **/
  palletIndex: {
    /**
     * Pre-set index worker account
     *
     * @param {AccountId32Like} arg
     * @param {Callback<boolean> =} callback
     **/
    workers: GenericStorageQuery<Rv, (arg: AccountId32Like) => boolean, AccountId32>

    /**
     * Mapping task_id to the full deposit data
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<PalletIndexDepositInfo | undefined> =} callback
     **/
    depositRecords: GenericStorageQuery<Rv, (arg: FixedBytes<32>) => PalletIndexDepositInfo | undefined, FixedBytes<32>>

    /**
     * Mapping the worker account and its actived task queue
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FixedBytes<32>>> =} callback
     **/
    activedTasks: GenericStorageQuery<Rv, (arg: AccountId32Like) => Array<FixedBytes<32>>, AccountId32>

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>
  }
}

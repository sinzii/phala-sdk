// Generated by dedot cli

import type { GenericChainConsts, RpcVersion } from 'dedot/types'
import type { RuntimeVersion, Permill, FixedBytes, Percent, AccountId32, H160, U256 } from 'dedot/codecs'
import type {
  FrameSystemLimitsBlockWeights,
  FrameSystemLimitsBlockLength,
  SpWeightsRuntimeDbWeight,
  SpWeightsWeightV2Weight,
  FrameSupportPalletId,
  StagingXcmV3MultilocationMultiLocation,
  StagingXcmV3MultiassetAssetId,
} from './types'

export interface ChainConsts<Rv extends RpcVersion> extends GenericChainConsts<Rv> {
  /**
   * Pallet `System`'s constants
   **/
  system: {
    /**
     * Block & extrinsics weights: base values and limits.
     **/
    blockWeights: FrameSystemLimitsBlockWeights

    /**
     * The maximum length of a block (in bytes).
     **/
    blockLength: FrameSystemLimitsBlockLength

    /**
     * Maximum number of block number to block hash mappings to keep (oldest pruned first).
     **/
    blockHashCount: number

    /**
     * The weight of runtime database operations the runtime can invoke.
     **/
    dbWeight: SpWeightsRuntimeDbWeight

    /**
     * Get the chain's current version.
     **/
    version: RuntimeVersion

    /**
     * The designated SS58 prefix of this chain.
     *
     * This replaces the "ss58Format" property declared in the chain spec. Reason is
     * that the runtime should know about the prefix in order to make use of it as
     * an identifier of the chain.
     **/
    ss58Prefix: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Timestamp`'s constants
   **/
  timestamp: {
    /**
     * The minimum period between blocks.
     *
     * Be aware that this is different to the *expected* period that the block production
     * apparatus provides. Your chosen consensus system will generally work with this to
     * determine a sensible block time. For example, in the Aura pallet it will be double this
     * period on default settings.
     **/
    minimumPeriod: bigint

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `RandomnessCollectiveFlip`'s constants
   **/
  randomnessCollectiveFlip: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Utility`'s constants
   **/
  utility: {
    /**
     * The limit on the number of batched calls.
     **/
    batchedCallsLimit: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Multisig`'s constants
   **/
  multisig: {
    /**
     * The base amount of currency needed to reserve for creating a multisig execution or to
     * store a dispatch call for later.
     *
     * This is held for an additional storage item whose value size is
     * `4 + sizeof((BlockNumber, Balance, AccountId))` bytes and whose key size is
     * `32 + sizeof(AccountId)` bytes.
     **/
    depositBase: bigint

    /**
     * The amount of currency needed per unit threshold when creating a multisig execution.
     *
     * This is held for adding 32 bytes more into a pre-existing storage value.
     **/
    depositFactor: bigint

    /**
     * The maximum amount of signatories allowed in the multisig.
     **/
    maxSignatories: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Proxy`'s constants
   **/
  proxy: {
    /**
     * The base amount of currency needed to reserve for creating a proxy.
     *
     * This is held for an additional storage item whose value size is
     * `sizeof(Balance)` bytes and whose key size is `sizeof(AccountId)` bytes.
     **/
    proxyDepositBase: bigint

    /**
     * The amount of currency needed per proxy added.
     *
     * This is held for adding 32 bytes plus an instance of `ProxyType` more into a
     * pre-existing storage value. Thus, when configuring `ProxyDepositFactor` one should take
     * into account `32 + proxy_type.encode().len()` bytes of data.
     **/
    proxyDepositFactor: bigint

    /**
     * The maximum amount of proxies allowed for a single account.
     **/
    maxProxies: number

    /**
     * The maximum amount of time-delayed announcements that are allowed to be pending.
     **/
    maxPending: number

    /**
     * The base amount of currency needed to reserve for creating an announcement.
     *
     * This is held when a new storage item holding a `Balance` is created (typically 16
     * bytes).
     **/
    announcementDepositBase: bigint

    /**
     * The amount of currency needed per announcement made.
     *
     * This is held for adding an `AccountId`, `Hash` and `BlockNumber` (typically 68 bytes)
     * into a pre-existing storage value.
     **/
    announcementDepositFactor: bigint

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Vesting`'s constants
   **/
  vesting: {
    /**
     * The minimum amount transferred to call `vested_transfer`.
     **/
    minVestedTransfer: bigint
    maxVestingSchedules: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Scheduler`'s constants
   **/
  scheduler: {
    /**
     * The maximum weight that may be scheduled per block for any dispatchables.
     **/
    maximumWeight: SpWeightsWeightV2Weight

    /**
     * The maximum number of scheduled calls in the queue for a single block.
     *
     * NOTE:
     * + Dependent pallets' benchmarks might require a higher limit for the setting. Set a
     * higher limit under `runtime-benchmarks` feature.
     **/
    maxScheduledPerBlock: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Preimage`'s constants
   **/
  preimage: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `ParachainInfo`'s constants
   **/
  parachainInfo: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `ParachainSystem`'s constants
   **/
  parachainSystem: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `XcmpQueue`'s constants
   **/
  xcmpQueue: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `CumulusXcm`'s constants
   **/
  cumulusXcm: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `DmpQueue`'s constants
   **/
  dmpQueue: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PolkadotXcm`'s constants
   **/
  polkadotXcm: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Balances`'s constants
   **/
  balances: {
    /**
     * The minimum amount required to keep an account open. MUST BE GREATER THAN ZERO!
     *
     * If you *really* need it to be zero, you can enable the feature `insecure_zero_ed` for
     * this pallet. However, you do so at your own risk: this will open up a major DoS vector.
     * In case you have multiple sources of provider references, you may also get unexpected
     * behaviour if you set this to zero.
     *
     * Bottom line: Do yourself a favour and make it at least one!
     **/
    existentialDeposit: bigint

    /**
     * The maximum number of locks that should exist on an account.
     * Not strictly enforced, but used for weight estimation.
     **/
    maxLocks: number

    /**
     * The maximum number of named reserves that can exist on an account.
     **/
    maxReserves: number

    /**
     * The maximum number of holds that can exist on an account at any time.
     **/
    maxHolds: number

    /**
     * The maximum number of individual freeze locks that can exist on an account at any time.
     **/
    maxFreezes: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `TransactionPayment`'s constants
   **/
  transactionPayment: {
    /**
     * A fee mulitplier for `Operational` extrinsics to compute "virtual tip" to boost their
     * `priority`
     *
     * This value is multipled by the `final_fee` to obtain a "virtual tip" that is later
     * added to a tip component in regular `priority` calculations.
     * It means that a `Normal` transaction can front-run a similarly-sized `Operational`
     * extrinsic (with no tip), by including a tip value greater than the virtual tip.
     *
     * ```rust,ignore
     * // For `Normal`
     * let priority = priority_calc(tip);
     *
     * // For `Operational`
     * let virtual_tip = (inclusion_fee + tip) * OperationalFeeMultiplier;
     * let priority = priority_calc(tip + virtual_tip);
     * ```
     *
     * Note that since we use `final_fee` the multiplier applies also to the regular `tip`
     * sent with the transaction. So, not only does the transaction get a priority bump based
     * on the `inclusion_fee`, but we also amplify the impact of tips applied to `Operational`
     * transactions.
     **/
    operationalFeeMultiplier: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Assets`'s constants
   **/
  assets: {
    /**
     * Max number of items to destroy per `destroy_accounts` and `destroy_approvals` call.
     *
     * Must be configured to result in a weight that makes each call fit in a block.
     **/
    removeItemsLimit: number

    /**
     * The basic amount of funds that must be reserved for an asset.
     **/
    assetDeposit: bigint

    /**
     * The amount of funds that must be reserved for a non-provider asset account to be
     * maintained.
     **/
    assetAccountDeposit: bigint

    /**
     * The basic amount of funds that must be reserved when adding metadata to your asset.
     **/
    metadataDepositBase: bigint

    /**
     * The additional funds that must be reserved for the number of bytes you store in your
     * metadata.
     **/
    metadataDepositPerByte: bigint

    /**
     * The amount of funds that must be reserved when creating a new approval.
     **/
    approvalDeposit: bigint

    /**
     * The maximum length of a name or symbol stored on-chain.
     **/
    stringLimit: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Authorship`'s constants
   **/
  authorship: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `CollatorSelection`'s constants
   **/
  collatorSelection: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Session`'s constants
   **/
  session: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Aura`'s constants
   **/
  aura: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `AuraExt`'s constants
   **/
  auraExt: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Identity`'s constants
   **/
  identity: {
    /**
     * The amount held on deposit for a registered identity
     **/
    basicDeposit: bigint

    /**
     * The amount held on deposit per additional field for a registered identity.
     **/
    fieldDeposit: bigint

    /**
     * The amount held on deposit for a registered subaccount. This should account for the fact
     * that one storage item's value will increase by the size of an account ID, and there will
     * be another trie item whose value is the size of an account ID plus 32 bytes.
     **/
    subAccountDeposit: bigint

    /**
     * The maximum number of sub-accounts allowed per identified account.
     **/
    maxSubAccounts: number

    /**
     * Maximum number of additional fields that may be stored in an ID. Needed to bound the I/O
     * required to access an identity, but can be pretty high.
     **/
    maxAdditionalFields: number

    /**
     * Maxmimum number of registrars allowed in the system. Needed to bound the complexity
     * of, e.g., updating judgements.
     **/
    maxRegistrars: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Democracy`'s constants
   **/
  democracy: {
    /**
     * The period between a proposal being approved and enacted.
     *
     * It should generally be a little more than the unstake period to ensure that
     * voting stakers have an opportunity to remove themselves from the system in the case
     * where they are on the losing side of a vote.
     **/
    enactmentPeriod: number

    /**
     * How often (in blocks) new public referenda are launched.
     **/
    launchPeriod: number

    /**
     * How often (in blocks) to check for new votes.
     **/
    votingPeriod: number

    /**
     * The minimum period of vote locking.
     *
     * It should be no shorter than enactment period to ensure that in the case of an approval,
     * those successful voters are locked into the consequences that their votes entail.
     **/
    voteLockingPeriod: number

    /**
     * The minimum amount to be used as a deposit for a public referendum proposal.
     **/
    minimumDeposit: bigint

    /**
     * Indicator for whether an emergency origin is even allowed to happen. Some chains may
     * want to set this permanently to `false`, others may want to condition it on things such
     * as an upgrade having happened recently.
     **/
    instantAllowed: boolean

    /**
     * Minimum voting period allowed for a fast-track referendum.
     **/
    fastTrackVotingPeriod: number

    /**
     * Period in blocks where an external proposal may not be re-submitted after being vetoed.
     **/
    cooloffPeriod: number

    /**
     * The maximum number of votes for an account.
     *
     * Also used to compute weight, an overly big value can
     * lead to extrinsic with very big weight: see `delegate` for instance.
     **/
    maxVotes: number

    /**
     * The maximum number of public proposals that can exist at any time.
     **/
    maxProposals: number

    /**
     * The maximum number of deposits a public proposal may have at any time.
     **/
    maxDeposits: number

    /**
     * The maximum number of items which can be blacklisted.
     **/
    maxBlacklisted: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Council`'s constants
   **/
  council: {
    /**
     * The maximum weight of a dispatch call that can be proposed and executed.
     **/
    maxProposalWeight: SpWeightsWeightV2Weight

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Treasury`'s constants
   **/
  treasury: {
    /**
     * Fraction of a proposal's value that should be bonded in order to place the proposal.
     * An accepted proposal gets these back. A rejected proposal does not.
     **/
    proposalBond: Permill

    /**
     * Minimum amount of funds that should be placed in a deposit for making a proposal.
     **/
    proposalBondMinimum: bigint

    /**
     * Maximum amount of funds that should be placed in a deposit for making a proposal.
     **/
    proposalBondMaximum: bigint | undefined

    /**
     * Period between successive spends.
     **/
    spendPeriod: number

    /**
     * Percentage of spare funds (if any) that are burnt per spend period.
     **/
    burn: Permill

    /**
     * The treasury's pallet id, used for deriving its sovereign account ID.
     **/
    palletId: FrameSupportPalletId

    /**
     * The maximum number of approvals that can wait in the spending queue.
     *
     * NOTE: This parameter is also used within the Bounties Pallet extension if enabled.
     **/
    maxApprovals: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Bounties`'s constants
   **/
  bounties: {
    /**
     * The amount held on deposit for placing a bounty proposal.
     **/
    bountyDepositBase: bigint

    /**
     * The delay period for which a bounty beneficiary need to wait before claim the payout.
     **/
    bountyDepositPayoutDelay: number

    /**
     * Bounty duration in blocks.
     **/
    bountyUpdatePeriod: number

    /**
     * The curator deposit is calculated as a percentage of the curator fee.
     *
     * This deposit has optional upper and lower bounds with `CuratorDepositMax` and
     * `CuratorDepositMin`.
     **/
    curatorDepositMultiplier: Permill

    /**
     * Maximum amount of funds that should be placed in a deposit for making a proposal.
     **/
    curatorDepositMax: bigint | undefined

    /**
     * Minimum amount of funds that should be placed in a deposit for making a proposal.
     **/
    curatorDepositMin: bigint | undefined

    /**
     * Minimum value for a bounty.
     **/
    bountyValueMinimum: bigint

    /**
     * The amount held on deposit per byte within the tip report reason or bounty description.
     **/
    dataDepositPerByte: bigint

    /**
     * Maximum acceptable reason length.
     *
     * Benchmarks depend on this value, be sure to update weights file when changing this value
     **/
    maximumReasonLength: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Lottery`'s constants
   **/
  lottery: {
    /**
     * The Lottery's pallet id
     **/
    palletId: FrameSupportPalletId

    /**
     * The max number of calls available in a single lottery.
     **/
    maxCalls: number

    /**
     * Number of time we should try to generate a random number that has no modulo bias.
     * The larger this number, the more potential computation is used for picking the winner,
     * but also the more likely that the chosen winner is done fairly.
     **/
    maxGenerateRandom: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `TechnicalCommittee`'s constants
   **/
  technicalCommittee: {
    /**
     * The maximum weight of a dispatch call that can be proposed and executed.
     **/
    maxProposalWeight: SpWeightsWeightV2Weight

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `TechnicalMembership`'s constants
   **/
  technicalMembership: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PhragmenElection`'s constants
   **/
  phragmenElection: {
    /**
     * Identifier for the elections-phragmen pallet's lock
     **/
    palletId: FixedBytes<8>

    /**
     * How much should be locked up in order to submit one's candidacy.
     **/
    candidacyBond: bigint

    /**
     * Base deposit associated with voting.
     *
     * This should be sensibly high to economically ensure the pallet cannot be attacked by
     * creating a gigantic number of votes.
     **/
    votingBondBase: bigint

    /**
     * The amount of bond that need to be locked for each vote (32 bytes).
     **/
    votingBondFactor: bigint

    /**
     * Number of members to elect.
     **/
    desiredMembers: number

    /**
     * Number of runners_up to keep.
     **/
    desiredRunnersUp: number

    /**
     * How long each seat is kept. This defines the next block number at which an election
     * round will happen. If set to zero, no elections are ever triggered and the module will
     * be in passive mode.
     **/
    termDuration: number

    /**
     * The maximum number of candidates in a phragmen election.
     *
     * Warning: This impacts the size of the election which is run onchain. Chose wisely, and
     * consider how it will impact `T::WeightInfo::election_phragmen`.
     *
     * When this limit is reached no more candidates are accepted in the election.
     **/
    maxCandidates: number

    /**
     * The maximum number of voters to allow in a phragmen election.
     *
     * Warning: This impacts the size of the election which is run onchain. Chose wisely, and
     * consider how it will impact `T::WeightInfo::election_phragmen`.
     *
     * When the limit is reached the new voters are ignored.
     **/
    maxVoters: number

    /**
     * Maximum numbers of votes per voter.
     *
     * Warning: This impacts the size of the election which is run onchain. Chose wisely, and
     * consider how it will impact `T::WeightInfo::election_phragmen`.
     **/
    maxVotesPerVoter: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Tips`'s constants
   **/
  tips: {
    /**
     * Maximum acceptable reason length.
     *
     * Benchmarks depend on this value, be sure to update weights file when changing this value
     **/
    maximumReasonLength: number

    /**
     * The amount held on deposit per byte within the tip report reason or bounty description.
     **/
    dataDepositPerByte: bigint

    /**
     * The period for which a tip remains open after is has achieved threshold tippers.
     **/
    tipCountdown: number

    /**
     * The percent of the final tip which goes to the original reporter of the tip.
     **/
    tipFindersFee: Percent

    /**
     * The amount held on deposit for placing a tip report.
     **/
    tipReportDepositBase: bigint

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `ChildBounties`'s constants
   **/
  childBounties: {
    /**
     * Maximum number of child bounties that can be added to a parent bounty.
     **/
    maxActiveChildBountyCount: number

    /**
     * Minimum value for a child-bounty.
     **/
    childBountyValueMinimum: bigint

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `ChainBridge`'s constants
   **/
  chainBridge: {
    /**
     * The identifier for this chain.
     * This must be unique and must not collide with existing IDs within a set of bridged chains.
     **/
    bridgeChainId: number
    proposalLifetime: number

    /**
     * Maximum number of bridge events allowed to exist in a single block
     **/
    bridgeEventLimit: number

    /**
     * Salt used to generation rid
     **/
    resourceIdGenerationSalt: bigint | undefined

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `XcmBridge`'s constants
   **/
  xcmBridge: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `XTransfer`'s constants
   **/
  xTransfer: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `AssetsRegistry`'s constants
   **/
  assetsRegistry: {
    minBalance: bigint
    nativeExecutionPrice: bigint
    resourceIdGenerationSalt: bigint | undefined
    nativeAssetLocation: StagingXcmV3MultilocationMultiLocation
    nativeAssetSygmaResourceId: FixedBytes<32>

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PhalaMq`'s constants
   **/
  phalaMq: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PhalaRegistry`'s constants
   **/
  phalaRegistry: {
    /**
     * Enable None Attestation, SHOULD BE SET TO FALSE ON PRODUCTION !!!
     **/
    noneAttestationEnabled: boolean

    /**
     * Verify attestation
     *
     * SHOULD NOT SET TO FALSE ON PRODUCTION!!!
     **/
    verifyPRuntime: boolean

    /**
     * Verify relaychain genesis
     *
     * SHOULD NOT SET TO FALSE ON PRODUCTION!!!
     **/
    verifyRelaychainGenesisBlockHash: boolean

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PhalaComputation`'s constants
   **/
  phalaComputation: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PhalaStakePool`'s constants
   **/
  phalaStakePool: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PhalaStakePoolv2`'s constants
   **/
  phalaStakePoolv2: {
    minContribution: bigint

    /**
     * The grace period for force withdraw request, in seconds.
     **/
    gracePeriod: bigint

    /**
     * The max allowed workers in a pool
     **/
    maxPoolWorkers: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PhalaVault`'s constants
   **/
  phalaVault: {
    initialPriceCheckPoint: bigint
    vaultQueuePeriod: bigint

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PhalaWrappedBalances`'s constants
   **/
  phalaWrappedBalances: {
    /**
     * W-PHA's asset id
     **/
    wPhaAssetId: number

    /**
     * Pha's global fund pool
     **/
    wrappedBalancesAccountId: AccountId32

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PhalaBasePool`'s constants
   **/
  phalaBasePool: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PhalaPhatContracts`'s constants
   **/
  phalaPhatContracts: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PhalaPhatTokenomic`'s constants
   **/
  phalaPhatTokenomic: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `Uniques`'s constants
   **/
  uniques: {
    /**
     * The basic amount of funds that must be reserved for collection.
     **/
    collectionDeposit: bigint

    /**
     * The basic amount of funds that must be reserved for an item.
     **/
    itemDeposit: bigint

    /**
     * The basic amount of funds that must be reserved when adding metadata to your item.
     **/
    metadataDepositBase: bigint

    /**
     * The basic amount of funds that must be reserved when adding an attribute to an item.
     **/
    attributeDepositBase: bigint

    /**
     * The additional funds that must be reserved for the number of bytes store in metadata,
     * either "normal" metadata or attribute metadata.
     **/
    depositPerByte: bigint

    /**
     * The maximum length of data stored on-chain.
     **/
    stringLimit: number

    /**
     * The maximum length of an attribute key.
     **/
    keyLimit: number

    /**
     * The maximum length of an attribute value.
     **/
    valueLimit: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `RmrkCore`'s constants
   **/
  rmrkCore: {
    /**
     * The maximum resource symbol length
     **/
    resourceSymbolLimit: number

    /**
     * The maximum number of parts each resource may have
     **/
    partsLimit: number

    /**
     * The maximum number of resources that can be included in a setpriority extrinsic
     **/
    maxPriorities: number

    /**
     * The maximum number of properties each can have
     **/
    propertiesLimit: number

    /**
     * The maximum nesting allowed in the pallet extrinsics.
     **/
    nestingBudget: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `RmrkEquip`'s constants
   **/
  rmrkEquip: {
    /**
     * Maximum allowed Parts (either Fixed or Slot) per Base
     **/
    maxPropertiesPerTheme: number

    /**
     * Maximum number of Properties allowed for any Theme
     **/
    maxCollectionsEquippablePerPart: number

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `RmrkMarket`'s constants
   **/
  rmrkMarket: {
    /**
     * Minimum offer amount as a valid offer
     **/
    minimumOfferAmount: bigint

    /**
     * Market fee to be implemented downstream.
     **/
    marketFee: Permill

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `SygmaAccessSegregator`'s constants
   **/
  sygmaAccessSegregator: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `SygmaBasicFeeHandler`'s constants
   **/
  sygmaBasicFeeHandler: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `SygmaBridge`'s constants
   **/
  sygmaBridge: {
    /**
     * Bridge transfer reserve accounts mapping with designated assets
     **/
    transferReserveAccounts: Array<[StagingXcmV3MultiassetAssetId, AccountId32]>

    /**
     * EIP712 Verifying contract address
     * This is used in EIP712 typed data domain
     **/
    destVerifyingContractAddress: H160

    /**
     * Pallet ChainID
     * This is used in EIP712 typed data domain
     **/
    eip712ChainID: U256

    /**
     * Fee reserve account
     **/
    feeReserveAccount: AccountId32

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `SygmaFeeHandlerRouter`'s constants
   **/
  sygmaFeeHandlerRouter: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `SygmaWrapper`'s constants
   **/
  sygmaWrapper: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `SygmaPercentageFeeHandler`'s constants
   **/
  sygmaPercentageFeeHandler: {
    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
  /**
   * Pallet `PalletIndex`'s constants
   **/
  palletIndex: {
    /**
     * Fee reserve account
     **/
    feeReserveAccount: AccountId32

    /**
     * Generic pallet constant
     **/
    [name: string]: any
  }
}

// Generated by dedot cli

import type { GenericRuntimeApis, GenericRuntimeApiMethod, RpcVersion } from 'dedot/types'
import type {
  RuntimeVersion,
  Header,
  DispatchError,
  Result,
  UncheckedExtrinsicLike,
  UncheckedExtrinsic,
  H256,
  Bytes,
  BytesLike,
  AccountId32Like,
} from 'dedot/codecs'
import type {
  SpConsensusSlotsSlotDuration,
  SpConsensusAuraSr25519AppSr25519Public,
  SpRuntimeBlock,
  SpCoreOpaqueMetadata,
  SpRuntimeTransactionValidityTransactionValidityError,
  SpInherentsInherentData,
  SpInherentsCheckInherentsResult,
  SpRuntimeTransactionValidityValidTransaction,
  SpRuntimeTransactionValidityTransactionSource,
  SpCoreCryptoKeyTypeId,
  PalletTransactionPaymentRuntimeDispatchInfo,
  PalletTransactionPaymentFeeDetails,
  SpWeightsWeightV2Weight,
  PhalaMqMessageOrigin,
  CumulusPrimitivesCoreCollationInfo,
  RmrkTraitsCollectionCollectionInfo,
  RmrkTraitsNftNftInfo,
  RmrkTraitsNftNftChild,
  RmrkTraitsPropertyPropertyInfo,
  RmrkTraitsResourceResourceInfo,
  RmrkTraitsBaseBaseInfo,
  RmrkTraitsPartPartType,
  RmrkTraitsTheme,
} from './types'

export interface RuntimeApis<Rv extends RpcVersion> extends GenericRuntimeApis<Rv> {
  /**
   * @runtimeapi: AuraApi - 0xdd718d5cc53262d4
   **/
  auraApi: {
    /**
     * Returns the slot duration for Aura.
     *
     * Currently, only the value provided by this type at genesis will be used.
     *
     * @callname: AuraApi_slot_duration
     **/
    slotDuration: GenericRuntimeApiMethod<Rv, () => Promise<SpConsensusSlotsSlotDuration>>

    /**
     * Return the current set of authorities.
     *
     * @callname: AuraApi_authorities
     **/
    authorities: GenericRuntimeApiMethod<Rv, () => Promise<Array<SpConsensusAuraSr25519AppSr25519Public>>>

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: Core - 0xdf6acb689907609b
   **/
  core: {
    /**
     * Returns the version of the runtime.
     *
     * @callname: Core_version
     **/
    version: GenericRuntimeApiMethod<Rv, () => Promise<RuntimeVersion>>

    /**
     * Execute the given block.
     *
     * @callname: Core_execute_block
     * @param {SpRuntimeBlock} block
     **/
    executeBlock: GenericRuntimeApiMethod<Rv, (block: SpRuntimeBlock) => Promise<[]>>

    /**
     * Initialize a block with the given header.
     *
     * @callname: Core_initialize_block
     * @param {Header} header
     **/
    initializeBlock: GenericRuntimeApiMethod<Rv, (header: Header) => Promise<[]>>

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: Metadata - 0x37e397fc7c91f5e4
   **/
  metadata: {
    /**
     * Returns the metadata of a runtime.
     *
     * @callname: Metadata_metadata
     **/
    metadata: GenericRuntimeApiMethod<Rv, () => Promise<SpCoreOpaqueMetadata>>

    /**
     * Returns the metadata at a given version.
     *
     * If the given `version` isn't supported, this will return `None`.
     * Use [`Self::metadata_versions`] to find out about supported metadata version of the runtime.
     *
     * @callname: Metadata_metadata_at_version
     * @param {number} version
     **/
    metadataAtVersion: GenericRuntimeApiMethod<Rv, (version: number) => Promise<SpCoreOpaqueMetadata | undefined>>

    /**
     * Returns the supported metadata versions.
     *
     * This can be used to call `metadata_at_version`.
     *
     * @callname: Metadata_metadata_versions
     **/
    metadataVersions: GenericRuntimeApiMethod<Rv, () => Promise<Array<number>>>

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: BlockBuilder - 0x40fe3ad401f8959a
   **/
  blockBuilder: {
    /**
     * Apply the given extrinsic.
     *
     * Returns an inclusion outcome which specifies if this extrinsic is included in
     * this block or not.
     *
     * @callname: BlockBuilder_apply_extrinsic
     * @param {UncheckedExtrinsicLike} extrinsic
     **/
    applyExtrinsic: GenericRuntimeApiMethod<
      Rv,
      (
        extrinsic: UncheckedExtrinsicLike
      ) => Promise<Result<Result<[], DispatchError>, SpRuntimeTransactionValidityTransactionValidityError>>
    >

    /**
     * Finish the current block.
     *
     * @callname: BlockBuilder_finalize_block
     **/
    finalizeBlock: GenericRuntimeApiMethod<Rv, () => Promise<Header>>

    /**
     * Generate inherent extrinsics. The inherent data will vary from chain to chain.
     *
     * @callname: BlockBuilder_inherent_extrinsics
     * @param {SpInherentsInherentData} inherent
     **/
    inherentExtrinsics: GenericRuntimeApiMethod<
      Rv,
      (inherent: SpInherentsInherentData) => Promise<Array<UncheckedExtrinsic>>
    >

    /**
     * Check that the inherents are valid. The inherent data will vary from chain to chain.
     *
     * @callname: BlockBuilder_check_inherents
     * @param {SpRuntimeBlock} block
     * @param {SpInherentsInherentData} data
     **/
    checkInherents: GenericRuntimeApiMethod<
      Rv,
      (block: SpRuntimeBlock, data: SpInherentsInherentData) => Promise<SpInherentsCheckInherentsResult>
    >

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: TaggedTransactionQueue - 0xd2bc9897eed08f15
   **/
  taggedTransactionQueue: {
    /**
     * Validate the transaction.
     *
     * This method is invoked by the transaction pool to learn details about given transaction.
     * The implementation should make sure to verify the correctness of the transaction
     * against current state. The given `block_hash` corresponds to the hash of the block
     * that is used as current state.
     *
     * Note that this call may be performed by the pool multiple times and transactions
     * might be verified in any possible order.
     *
     * @callname: TaggedTransactionQueue_validate_transaction
     * @param {SpRuntimeTransactionValidityTransactionSource} source
     * @param {UncheckedExtrinsicLike} tx
     * @param {H256} block_hash
     **/
    validateTransaction: GenericRuntimeApiMethod<
      Rv,
      (
        source: SpRuntimeTransactionValidityTransactionSource,
        tx: UncheckedExtrinsicLike,
        blockHash: H256
      ) => Promise<
        Result<SpRuntimeTransactionValidityValidTransaction, SpRuntimeTransactionValidityTransactionValidityError>
      >
    >

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: OffchainWorkerApi - 0xf78b278be53f454c
   **/
  offchainWorkerApi: {
    /**
     * Starts the off-chain task for given block header.
     *
     * @callname: OffchainWorkerApi_offchain_worker
     * @param {Header} header
     **/
    offchainWorker: GenericRuntimeApiMethod<Rv, (header: Header) => Promise<[]>>

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: SessionKeys - 0xab3c0572291feb8b
   **/
  sessionKeys: {
    /**
     * Generate a set of session keys with optionally using the given seed.
     * The keys should be stored within the keystore exposed via runtime
     * externalities.
     *
     * The seed needs to be a valid `utf8` string.
     *
     * Returns the concatenated SCALE encoded public keys.
     *
     * @callname: SessionKeys_generate_session_keys
     * @param {BytesLike | undefined} seed
     **/
    generateSessionKeys: GenericRuntimeApiMethod<Rv, (seed?: BytesLike | undefined) => Promise<Bytes>>

    /**
     * Decode the given public session keys.
     *
     * Returns the list of public raw public keys + key type.
     *
     * @callname: SessionKeys_decode_session_keys
     * @param {BytesLike} encoded
     **/
    decodeSessionKeys: GenericRuntimeApiMethod<
      Rv,
      (encoded: BytesLike) => Promise<Array<[Bytes, SpCoreCryptoKeyTypeId]> | undefined>
    >

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: AccountNonceApi - 0xbc9d89904f5b923f
   **/
  accountNonceApi: {
    /**
     * Get current account nonce of given `AccountId`.
     *
     * @callname: AccountNonceApi_account_nonce
     * @param {AccountId32Like} account
     **/
    accountNonce: GenericRuntimeApiMethod<Rv, (account: AccountId32Like) => Promise<number>>

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: TransactionPaymentApi - 0x37c8bb1350a9a2a8
   **/
  transactionPaymentApi: {
    /**
     *
     * @callname: TransactionPaymentApi_query_info
     * @param {UncheckedExtrinsicLike} uxt
     * @param {number} len
     **/
    queryInfo: GenericRuntimeApiMethod<
      Rv,
      (uxt: UncheckedExtrinsicLike, len: number) => Promise<PalletTransactionPaymentRuntimeDispatchInfo>
    >

    /**
     *
     * @callname: TransactionPaymentApi_query_fee_details
     * @param {UncheckedExtrinsicLike} uxt
     * @param {number} len
     **/
    queryFeeDetails: GenericRuntimeApiMethod<
      Rv,
      (uxt: UncheckedExtrinsicLike, len: number) => Promise<PalletTransactionPaymentFeeDetails>
    >

    /**
     *
     * @callname: TransactionPaymentApi_query_weight_to_fee
     * @param {SpWeightsWeightV2Weight} weight
     **/
    queryWeightToFee: GenericRuntimeApiMethod<Rv, (weight: SpWeightsWeightV2Weight) => Promise<bigint>>

    /**
     *
     * @callname: TransactionPaymentApi_query_length_to_fee
     * @param {number} length
     **/
    queryLengthToFee: GenericRuntimeApiMethod<Rv, (length: number) => Promise<bigint>>

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: MqApi - 0x3e43e696bccaa34a
   **/
  mqApi: {
    /**
     *
     * @callname: MqApi_sender_sequence
     * @param {PhalaMqMessageOrigin} sender
     **/
    senderSequence: GenericRuntimeApiMethod<Rv, (sender: PhalaMqMessageOrigin) => Promise<bigint | undefined>>

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: CollectCollationInfo - 0xea93e3f16f3d6962
   **/
  collectCollationInfo: {
    /**
     * Collect information about a collation.
     *
     * The given `header` is the header of the built block for that
     * we are collecting the collation info for.
     *
     * @callname: CollectCollationInfo_collect_collation_info
     * @param {Header} header
     **/
    collectCollationInfo: GenericRuntimeApiMethod<Rv, (header: Header) => Promise<CumulusPrimitivesCoreCollationInfo>>

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: RmrkApi - 0x643365445941c5cb
   **/
  rmrkApi: {
    /**
     * Get collection by id
     *
     * @callname: RmrkApi_collection_by_id
     * @param {number} id
     **/
    collectionById: GenericRuntimeApiMethod<
      Rv,
      (id: number) => Promise<Result<RmrkTraitsCollectionCollectionInfo | undefined, DispatchError>>
    >

    /**
     * Get NFT by collection id and NFT id
     *
     * @callname: RmrkApi_nft_by_id
     * @param {number} collection_id
     * @param {number} nft_id
     **/
    nftById: GenericRuntimeApiMethod<
      Rv,
      (collectionId: number, nftId: number) => Promise<Result<RmrkTraitsNftNftInfo | undefined, DispatchError>>
    >

    /**
     * Get tokens owned by an account in a collection
     *
     * @callname: RmrkApi_account_tokens
     * @param {AccountId32Like} account_id
     * @param {number} collection_id
     **/
    accountTokens: GenericRuntimeApiMethod<
      Rv,
      (accountId: AccountId32Like, collectionId: number) => Promise<Result<Array<number>, DispatchError>>
    >

    /**
     * Get NFT children
     *
     * @callname: RmrkApi_nft_children
     * @param {number} collection_id
     * @param {number} nft_id
     **/
    nftChildren: GenericRuntimeApiMethod<
      Rv,
      (collectionId: number, nftId: number) => Promise<Result<Array<RmrkTraitsNftNftChild>, DispatchError>>
    >

    /**
     * Get collection properties
     *
     * @callname: RmrkApi_collection_properties
     * @param {number} collection_id
     * @param {Array<BytesLike> | undefined} filter_keys
     **/
    collectionProperties: GenericRuntimeApiMethod<
      Rv,
      (
        collectionId: number,
        filterKeys?: Array<BytesLike> | undefined
      ) => Promise<Result<Array<RmrkTraitsPropertyPropertyInfo>, DispatchError>>
    >

    /**
     * Get NFT properties
     *
     * @callname: RmrkApi_nft_properties
     * @param {number} collection_id
     * @param {number} nft_id
     * @param {Array<BytesLike> | undefined} filter_keys
     **/
    nftProperties: GenericRuntimeApiMethod<
      Rv,
      (
        collectionId: number,
        nftId: number,
        filterKeys?: Array<BytesLike> | undefined
      ) => Promise<Result<Array<RmrkTraitsPropertyPropertyInfo>, DispatchError>>
    >

    /**
     * Get NFT resources
     *
     * @callname: RmrkApi_nft_resources
     * @param {number} collection_id
     * @param {number} nft_id
     **/
    nftResources: GenericRuntimeApiMethod<
      Rv,
      (collectionId: number, nftId: number) => Promise<Result<Array<RmrkTraitsResourceResourceInfo>, DispatchError>>
    >

    /**
     * Get NFT resource priority
     *
     * @callname: RmrkApi_nft_resource_priority
     * @param {number} collection_id
     * @param {number} nft_id
     * @param {number} resource_id
     **/
    nftResourcePriority: GenericRuntimeApiMethod<
      Rv,
      (collectionId: number, nftId: number, resourceId: number) => Promise<Result<number | undefined, DispatchError>>
    >

    /**
     * Get base info
     *
     * @callname: RmrkApi_base
     * @param {number} base_id
     **/
    base: GenericRuntimeApiMethod<
      Rv,
      (baseId: number) => Promise<Result<RmrkTraitsBaseBaseInfo | undefined, DispatchError>>
    >

    /**
     * Get all Base's parts
     *
     * @callname: RmrkApi_base_parts
     * @param {number} base_id
     **/
    baseParts: GenericRuntimeApiMethod<
      Rv,
      (baseId: number) => Promise<Result<Array<RmrkTraitsPartPartType>, DispatchError>>
    >

    /**
     * Get Base's theme names
     *
     * @callname: RmrkApi_theme_names
     * @param {number} base_id
     **/
    themeNames: GenericRuntimeApiMethod<Rv, (baseId: number) => Promise<Result<Array<Bytes>, DispatchError>>>

    /**
     * Get Theme info -- name, properties, and inherit flag
     *
     * @callname: RmrkApi_theme
     * @param {number} base_id
     * @param {BytesLike} theme_name
     * @param {Array<BytesLike> | undefined} filter_keys
     **/
    theme: GenericRuntimeApiMethod<
      Rv,
      (
        baseId: number,
        themeName: BytesLike,
        filterKeys?: Array<BytesLike> | undefined
      ) => Promise<Result<RmrkTraitsTheme | undefined, DispatchError>>
    >

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: SygmaBridgeApi - 0x7ee4fdd3f4b9d4d0
   **/
  sygmaBridgeApi: {
    /**
     *
     * @callname: SygmaBridgeApi_is_proposal_executed
     * @param {bigint} nonce
     * @param {number} domain_id
     **/
    isProposalExecuted: GenericRuntimeApiMethod<Rv, (nonce: bigint, domainId: number) => Promise<boolean>>

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
  /**
   * @runtimeapi: GenesisBuilder - 0xfbc577b9d747efd6
   **/
  genesisBuilder: {
    /**
     * Creates the default `GenesisConfig` and returns it as a JSON blob.
     *
     * This function instantiates the default `GenesisConfig` struct for the runtime and serializes it into a JSON
     * blob. It returns a `Vec<u8>` containing the JSON representation of the default `GenesisConfig`.
     *
     * @callname: GenesisBuilder_create_default_config
     **/
    createDefaultConfig: GenericRuntimeApiMethod<Rv, () => Promise<Bytes>>

    /**
     * Build `GenesisConfig` from a JSON blob not using any defaults and store it in the storage.
     *
     * This function deserializes the full `GenesisConfig` from the given JSON blob and puts it into the storage.
     * If the provided JSON blob is incorrect or incomplete or the deserialization fails, an error is returned.
     * It is recommended to log any errors encountered during the process.
     *
     * Please note that provided json blob must contain all `GenesisConfig` fields, no defaults will be used.
     *
     * @callname: GenesisBuilder_build_config
     * @param {BytesLike} json
     **/
    buildConfig: GenericRuntimeApiMethod<Rv, (json: BytesLike) => Promise<Result<[], string>>>

    /**
     * Generic runtime api call
     **/
    [method: string]: GenericRuntimeApiMethod<Rv>
  }
}

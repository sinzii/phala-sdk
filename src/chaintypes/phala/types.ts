// Generated by dedot cli

import type {
  Phase,
  H256,
  DispatchInfo,
  DispatchError,
  AccountId32,
  Result,
  FixedBytes,
  Bytes,
  U256,
  BytesLike,
  AccountId32Like,
  MultiAddress,
  MultiAddressLike,
  Data,
  Permill,
  FixedArray,
  Era,
  Header,
  UncheckedExtrinsic,
} from 'dedot/codecs'

export type FrameSystemAccountInfo = {
  nonce: number
  consumers: number
  providers: number
  sufficients: number
  data: PalletBalancesAccountData
}

export type PalletBalancesAccountData = {
  free: bigint
  reserved: bigint
  frozen: bigint
  flags: PalletBalancesExtraFlags
}

export type PalletBalancesExtraFlags = bigint

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight
  operational: SpWeightsWeightV2Weight
  mandatory: SpWeightsWeightV2Weight
}

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint }

export type FrameSystemEventRecord = { phase: Phase; event: PhalaParachainRuntimeRuntimeEvent; topics: Array<H256> }

export type PhalaParachainRuntimeRuntimeEvent =
  | { pallet: 'System'; palletEvent: FrameSystemEvent }
  | { pallet: 'Utility'; palletEvent: PalletUtilityEvent }
  | { pallet: 'Multisig'; palletEvent: PalletMultisigEvent }
  | { pallet: 'Proxy'; palletEvent: PalletProxyEvent }
  | { pallet: 'Vesting'; palletEvent: PalletVestingEvent }
  | { pallet: 'Scheduler'; palletEvent: PalletSchedulerEvent }
  | { pallet: 'Preimage'; palletEvent: PalletPreimageEvent }
  | { pallet: 'ParachainSystem'; palletEvent: CumulusPalletParachainSystemEvent }
  | { pallet: 'XcmpQueue'; palletEvent: CumulusPalletXcmpQueueEvent }
  | { pallet: 'CumulusXcm'; palletEvent: CumulusPalletXcmEvent }
  | { pallet: 'DmpQueue'; palletEvent: CumulusPalletDmpQueueEvent }
  | { pallet: 'PolkadotXcm'; palletEvent: PalletXcmEvent }
  | { pallet: 'Balances'; palletEvent: PalletBalancesEvent }
  | { pallet: 'TransactionPayment'; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: 'Assets'; palletEvent: PalletAssetsEvent }
  | { pallet: 'CollatorSelection'; palletEvent: PalletCollatorSelectionEvent }
  | { pallet: 'Session'; palletEvent: PalletSessionEvent }
  | { pallet: 'Identity'; palletEvent: PalletIdentityEvent }
  | { pallet: 'Democracy'; palletEvent: PalletDemocracyEvent }
  | { pallet: 'Council'; palletEvent: PalletCollectiveEvent }
  | { pallet: 'Treasury'; palletEvent: PalletTreasuryEvent }
  | { pallet: 'Bounties'; palletEvent: PalletBountiesEvent }
  | { pallet: 'Lottery'; palletEvent: PalletLotteryEvent }
  | { pallet: 'TechnicalCommittee'; palletEvent: PalletCollectiveEvent }
  | { pallet: 'TechnicalMembership'; palletEvent: PalletMembershipEvent }
  | { pallet: 'PhragmenElection'; palletEvent: PalletElectionsPhragmenEvent }
  | { pallet: 'Tips'; palletEvent: PalletTipsEvent }
  | { pallet: 'ChildBounties'; palletEvent: PalletChildBountiesEvent }
  | { pallet: 'ChainBridge'; palletEvent: SubbridgePalletsChainbridgePalletEvent }
  | { pallet: 'XcmBridge'; palletEvent: SubbridgePalletsXcmbridgePalletEvent }
  | { pallet: 'XTransfer'; palletEvent: SubbridgePalletsXtransferPalletEvent }
  | { pallet: 'AssetsRegistry'; palletEvent: AssetsRegistryEvent }
  | { pallet: 'PhalaRegistry'; palletEvent: PhalaPalletsRegistryPalletEvent }
  | { pallet: 'PhalaComputation'; palletEvent: PhalaPalletsComputeComputationPalletEvent }
  | { pallet: 'PhalaStakePool'; palletEvent: PhalaPalletsStakePoolPalletEvent }
  | { pallet: 'PhalaStakePoolv2'; palletEvent: PhalaPalletsComputeStakePoolV2PalletEvent }
  | { pallet: 'PhalaVault'; palletEvent: PhalaPalletsComputeVaultPalletEvent }
  | { pallet: 'PhalaWrappedBalances'; palletEvent: PhalaPalletsComputeWrappedBalancesPalletEvent }
  | { pallet: 'PhalaBasePool'; palletEvent: PhalaPalletsComputeBasePoolPalletEvent }
  | { pallet: 'PhalaPhatContracts'; palletEvent: PhalaPalletsPhatPalletEvent }
  | { pallet: 'PhalaPhatTokenomic'; palletEvent: PhalaPalletsPhatTokenomicPalletEvent }
  | { pallet: 'Uniques'; palletEvent: PalletUniquesEvent }
  | { pallet: 'RmrkCore'; palletEvent: PalletRmrkCoreEvent }
  | { pallet: 'RmrkEquip'; palletEvent: PalletRmrkEquipEvent }
  | { pallet: 'RmrkMarket'; palletEvent: PalletRmrkMarketEvent }
  | { pallet: 'SygmaAccessSegregator'; palletEvent: SygmaAccessSegregatorEvent }
  | { pallet: 'SygmaBasicFeeHandler'; palletEvent: SygmaBasicFeehandlerEvent }
  | { pallet: 'SygmaBridge'; palletEvent: SygmaBridgeEvent }
  | { pallet: 'SygmaFeeHandlerRouter'; palletEvent: SygmaFeeHandlerRouterEvent }
  | { pallet: 'SygmaWrapper'; palletEvent: SubbridgePalletsSygmaWrapperPalletEvent }
  | { pallet: 'SygmaPercentageFeeHandler'; palletEvent: SygmaPercentageFeehandlerEvent }
  | { pallet: 'PalletIndex'; palletEvent: PalletIndexEvent }

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | { name: 'ExtrinsicSuccess'; data: { dispatchInfo: DispatchInfo } }
  /**
   * An extrinsic failed.
   **/
  | { name: 'ExtrinsicFailed'; data: { dispatchError: DispatchError; dispatchInfo: DispatchInfo } }
  /**
   * `:code` was updated.
   **/
  | { name: 'CodeUpdated' }
  /**
   * A new account was created.
   **/
  | { name: 'NewAccount'; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: 'KilledAccount'; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: 'Remarked'; data: { sender: AccountId32; hash: H256 } }

export type FrameSupportDispatchDispatchClass = 'Normal' | 'Operational' | 'Mandatory'

export type FrameSupportDispatchPays = 'Yes' | 'No'

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: 'BatchInterrupted'; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: 'BatchCompleted' }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: 'BatchCompletedWithErrors' }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: 'ItemCompleted' }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: 'ItemFailed'; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: 'DispatchedAs'; data: { result: Result<[], DispatchError> } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | { name: 'NewMultisig'; data: { approving: AccountId32; multisig: AccountId32; callHash: FixedBytes<32> } }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: 'MultisigApproval'
      data: {
        approving: AccountId32
        timepoint: PalletMultisigTimepoint
        multisig: AccountId32
        callHash: FixedBytes<32>
      }
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: 'MultisigExecuted'
      data: {
        approving: AccountId32
        timepoint: PalletMultisigTimepoint
        multisig: AccountId32
        callHash: FixedBytes<32>
        result: Result<[], DispatchError>
      }
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: 'MultisigCancelled'
      data: {
        cancelling: AccountId32
        timepoint: PalletMultisigTimepoint
        multisig: AccountId32
        callHash: FixedBytes<32>
      }
    }

export type PalletMultisigTimepoint = { height: number; index: number }

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: 'ProxyExecuted'; data: { result: Result<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: 'PureCreated'
      data: {
        pure: AccountId32
        who: AccountId32
        proxyType: PhalaParachainRuntimeProxyType
        disambiguationIndex: number
      }
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | { name: 'Announced'; data: { real: AccountId32; proxy: AccountId32; callHash: H256 } }
  /**
   * A proxy was added.
   **/
  | {
      name: 'ProxyAdded'
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: PhalaParachainRuntimeProxyType; delay: number }
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: 'ProxyRemoved'
      data: { delegator: AccountId32; delegatee: AccountId32; proxyType: PhalaParachainRuntimeProxyType; delay: number }
    }

export type PhalaParachainRuntimeProxyType =
  | 'Any'
  | 'NonTransfer'
  | 'CancelProxy'
  | 'Governance'
  | 'Collator'
  | 'StakePoolManager'

/**
 * The `Event` enum of this pallet
 **/
export type PalletVestingEvent =
  /**
   * The amount vested has been updated. This could indicate a change in funds available.
   * The balance given is the amount which is left unvested (and thus locked).
   **/
  | { name: 'VestingUpdated'; data: { account: AccountId32; unvested: bigint } }
  /**
   * An \[account\] has become fully vested.
   **/
  | { name: 'VestingCompleted'; data: { account: AccountId32 } }

/**
 * Events type.
 **/
export type PalletSchedulerEvent =
  /**
   * Scheduled some task.
   **/
  | { name: 'Scheduled'; data: { when: number; index: number } }
  /**
   * Canceled some task.
   **/
  | { name: 'Canceled'; data: { when: number; index: number } }
  /**
   * Dispatched some task.
   **/
  | {
      name: 'Dispatched'
      data: { task: [number, number]; id?: FixedBytes<32> | undefined; result: Result<[], DispatchError> }
    }
  /**
   * The call for the provided hash was not found so the task has been aborted.
   **/
  | { name: 'CallUnavailable'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task was unable to be renewed since the agenda is full at that block.
   **/
  | { name: 'PeriodicFailed'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  /**
   * The given task can never be executed since it is overweight.
   **/
  | { name: 'PermanentlyOverweight'; data: { task: [number, number]; id?: FixedBytes<32> | undefined } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletPreimageEvent =
  /**
   * A preimage has been noted.
   **/
  | { name: 'Noted'; data: { hash: H256 } }
  /**
   * A preimage has been requested.
   **/
  | { name: 'Requested'; data: { hash: H256 } }
  /**
   * A preimage has ben cleared.
   **/
  | { name: 'Cleared'; data: { hash: H256 } }

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletParachainSystemEvent =
  /**
   * The validation function has been scheduled to apply.
   **/
  | { name: 'ValidationFunctionStored' }
  /**
   * The validation function was applied as of the contained relay chain block number.
   **/
  | { name: 'ValidationFunctionApplied'; data: { relayChainBlockNum: number } }
  /**
   * The relay-chain aborted the upgrade process.
   **/
  | { name: 'ValidationFunctionDiscarded' }
  /**
   * An upgrade has been authorized.
   **/
  | { name: 'UpgradeAuthorized'; data: { codeHash: H256 } }
  /**
   * Some downward messages have been received and will be processed.
   **/
  | { name: 'DownwardMessagesReceived'; data: { count: number } }
  /**
   * Downward messages were processed using the given weight.
   **/
  | { name: 'DownwardMessagesProcessed'; data: { weightUsed: SpWeightsWeightV2Weight; dmqHead: H256 } }
  /**
   * An upward message was sent to the relay chain.
   **/
  | { name: 'UpwardMessageSent'; data: { messageHash?: FixedBytes<32> | undefined } }

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletXcmpQueueEvent =
  /**
   * Some XCM was executed ok.
   **/
  | {
      name: 'Success'
      data: { messageHash: FixedBytes<32>; messageId: FixedBytes<32>; weight: SpWeightsWeightV2Weight }
    }
  /**
   * Some XCM failed.
   **/
  | {
      name: 'Fail'
      data: {
        messageHash: FixedBytes<32>
        messageId: FixedBytes<32>
        error: StagingXcmV3TraitsError
        weight: SpWeightsWeightV2Weight
      }
    }
  /**
   * Bad XCM version used.
   **/
  | { name: 'BadVersion'; data: { messageHash: FixedBytes<32> } }
  /**
   * Bad XCM format used.
   **/
  | { name: 'BadFormat'; data: { messageHash: FixedBytes<32> } }
  /**
   * An HRMP message was sent to a sibling parachain.
   **/
  | { name: 'XcmpMessageSent'; data: { messageHash: FixedBytes<32> } }
  /**
   * An XCM exceeded the individual message weight budget.
   **/
  | {
      name: 'OverweightEnqueued'
      data: {
        sender: PolkadotParachainPrimitivesPrimitivesId
        sentAt: number
        index: bigint
        required: SpWeightsWeightV2Weight
      }
    }
  /**
   * An XCM from the overweight queue was executed with the given actual weight used.
   **/
  | { name: 'OverweightServiced'; data: { index: bigint; used: SpWeightsWeightV2Weight } }

export type StagingXcmV3TraitsError =
  | { type: 'Overflow' }
  | { type: 'Unimplemented' }
  | { type: 'UntrustedReserveLocation' }
  | { type: 'UntrustedTeleportLocation' }
  | { type: 'LocationFull' }
  | { type: 'LocationNotInvertible' }
  | { type: 'BadOrigin' }
  | { type: 'InvalidLocation' }
  | { type: 'AssetNotFound' }
  | { type: 'FailedToTransactAsset' }
  | { type: 'NotWithdrawable' }
  | { type: 'LocationCannotHold' }
  | { type: 'ExceedsMaxMessageSize' }
  | { type: 'DestinationUnsupported' }
  | { type: 'Transport' }
  | { type: 'Unroutable' }
  | { type: 'UnknownClaim' }
  | { type: 'FailedToDecode' }
  | { type: 'MaxWeightInvalid' }
  | { type: 'NotHoldingFees' }
  | { type: 'TooExpensive' }
  | { type: 'Trap'; value: bigint }
  | { type: 'ExpectationFalse' }
  | { type: 'PalletNotFound' }
  | { type: 'NameMismatch' }
  | { type: 'VersionIncompatible' }
  | { type: 'HoldingWouldOverflow' }
  | { type: 'ExportError' }
  | { type: 'ReanchorFailed' }
  | { type: 'NoDeal' }
  | { type: 'FeesNotMet' }
  | { type: 'LockError' }
  | { type: 'NoPermission' }
  | { type: 'Unanchored' }
  | { type: 'NotDepositable' }
  | { type: 'UnhandledXcmVersion' }
  | { type: 'WeightLimitReached'; value: SpWeightsWeightV2Weight }
  | { type: 'Barrier' }
  | { type: 'WeightNotComputable' }
  | { type: 'ExceedsStackLimit' }

export type PolkadotParachainPrimitivesPrimitivesId = number

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletXcmEvent =
  /**
   * Downward message is invalid XCM.
   * \[ id \]
   **/
  | { name: 'InvalidFormat'; data: FixedBytes<32> }
  /**
   * Downward message is unsupported version of XCM.
   * \[ id \]
   **/
  | { name: 'UnsupportedVersion'; data: FixedBytes<32> }
  /**
   * Downward message executed with the given outcome.
   * \[ id, outcome \]
   **/
  | { name: 'ExecutedDownward'; data: [FixedBytes<32>, StagingXcmV3TraitsOutcome] }

export type StagingXcmV3TraitsOutcome =
  | { type: 'Complete'; value: SpWeightsWeightV2Weight }
  | { type: 'Incomplete'; value: [SpWeightsWeightV2Weight, StagingXcmV3TraitsError] }
  | { type: 'Error'; value: StagingXcmV3TraitsError }

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletDmpQueueEvent =
  /**
   * Downward message is invalid XCM.
   **/
  | { name: 'InvalidFormat'; data: { messageHash: FixedBytes<32> } }
  /**
   * Downward message is unsupported version of XCM.
   **/
  | { name: 'UnsupportedVersion'; data: { messageHash: FixedBytes<32> } }
  /**
   * Downward message executed with the given outcome.
   **/
  | {
      name: 'ExecutedDownward'
      data: { messageHash: FixedBytes<32>; messageId: FixedBytes<32>; outcome: StagingXcmV3TraitsOutcome }
    }
  /**
   * The weight limit for handling downward messages was reached.
   **/
  | {
      name: 'WeightExhausted'
      data: {
        messageHash: FixedBytes<32>
        messageId: FixedBytes<32>
        remainingWeight: SpWeightsWeightV2Weight
        requiredWeight: SpWeightsWeightV2Weight
      }
    }
  /**
   * Downward message is overweight and was placed in the overweight queue.
   **/
  | {
      name: 'OverweightEnqueued'
      data: {
        messageHash: FixedBytes<32>
        messageId: FixedBytes<32>
        overweightIndex: bigint
        requiredWeight: SpWeightsWeightV2Weight
      }
    }
  /**
   * Downward message from the overweight queue was executed.
   **/
  | { name: 'OverweightServiced'; data: { overweightIndex: bigint; weightUsed: SpWeightsWeightV2Weight } }
  /**
   * The maximum number of downward messages was reached.
   **/
  | { name: 'MaxMessagesExhausted'; data: { messageHash: FixedBytes<32> } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletXcmEvent =
  /**
   * Execution of an XCM message was attempted.
   **/
  | { name: 'Attempted'; data: { outcome: StagingXcmV3TraitsOutcome } }
  /**
   * A XCM message was sent.
   **/
  | {
      name: 'Sent'
      data: {
        origin: StagingXcmV3MultilocationMultiLocation
        destination: StagingXcmV3MultilocationMultiLocation
        message: StagingXcmV3Xcm
        messageId: FixedBytes<32>
      }
    }
  /**
   * Query response received which does not match a registered query. This may be because a
   * matching query was never registered, it may be because it is a duplicate response, or
   * because the query timed out.
   **/
  | { name: 'UnexpectedResponse'; data: { origin: StagingXcmV3MultilocationMultiLocation; queryId: bigint } }
  /**
   * Query response has been received and is ready for taking with `take_response`. There is
   * no registered notification call.
   **/
  | { name: 'ResponseReady'; data: { queryId: bigint; response: StagingXcmV3Response } }
  /**
   * Query response has been received and query is removed. The registered notification has
   * been dispatched and executed successfully.
   **/
  | { name: 'Notified'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The registered notification
   * could not be dispatched because the dispatch weight is greater than the maximum weight
   * originally budgeted by this runtime for the query result.
   **/
  | {
      name: 'NotifyOverweight'
      data: {
        queryId: bigint
        palletIndex: number
        callIndex: number
        actualWeight: SpWeightsWeightV2Weight
        maxBudgetedWeight: SpWeightsWeightV2Weight
      }
    }
  /**
   * Query response has been received and query is removed. There was a general error with
   * dispatching the notification call.
   **/
  | { name: 'NotifyDispatchError'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Query response has been received and query is removed. The dispatch was unable to be
   * decoded into a `Call`; this might be due to dispatch function having a signature which
   * is not `(origin, QueryId, Response)`.
   **/
  | { name: 'NotifyDecodeFailed'; data: { queryId: bigint; palletIndex: number; callIndex: number } }
  /**
   * Expected query response has been received but the origin location of the response does
   * not match that expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidResponder'
      data: {
        origin: StagingXcmV3MultilocationMultiLocation
        queryId: bigint
        expectedLocation?: StagingXcmV3MultilocationMultiLocation | undefined
      }
    }
  /**
   * Expected query response has been received but the expected origin location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidResponderVersion'; data: { origin: StagingXcmV3MultilocationMultiLocation; queryId: bigint } }
  /**
   * Received query response has been read and removed.
   **/
  | { name: 'ResponseTaken'; data: { queryId: bigint } }
  /**
   * Some assets have been placed in an asset trap.
   **/
  | {
      name: 'AssetsTrapped'
      data: { hash: H256; origin: StagingXcmV3MultilocationMultiLocation; assets: StagingXcmVersionedMultiAssets }
    }
  /**
   * An XCM version change notification message has been attempted to be sent.
   *
   * The cost of sending it (borne by the chain) is included.
   **/
  | {
      name: 'VersionChangeNotified'
      data: {
        destination: StagingXcmV3MultilocationMultiLocation
        result: number
        cost: StagingXcmV3MultiassetMultiAssets
        messageId: FixedBytes<32>
      }
    }
  /**
   * The supported version of a location has been changed. This might be through an
   * automatic notification or a manual intervention.
   **/
  | { name: 'SupportedVersionChanged'; data: { location: StagingXcmV3MultilocationMultiLocation; version: number } }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * sending the notification to it.
   **/
  | {
      name: 'NotifyTargetSendFail'
      data: { location: StagingXcmV3MultilocationMultiLocation; queryId: bigint; error: StagingXcmV3TraitsError }
    }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * migrating the location to our new XCM format.
   **/
  | { name: 'NotifyTargetMigrationFail'; data: { location: StagingXcmVersionedMultiLocation; queryId: bigint } }
  /**
   * Expected query response has been received but the expected querier location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | { name: 'InvalidQuerierVersion'; data: { origin: StagingXcmV3MultilocationMultiLocation; queryId: bigint } }
  /**
   * Expected query response has been received but the querier location of the response does
   * not match the expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: 'InvalidQuerier'
      data: {
        origin: StagingXcmV3MultilocationMultiLocation
        queryId: bigint
        expectedQuerier: StagingXcmV3MultilocationMultiLocation
        maybeActualQuerier?: StagingXcmV3MultilocationMultiLocation | undefined
      }
    }
  /**
   * A remote has requested XCM version change notification from us and we have honored it.
   * A version information message is sent to them and its cost is included.
   **/
  | {
      name: 'VersionNotifyStarted'
      data: {
        destination: StagingXcmV3MultilocationMultiLocation
        cost: StagingXcmV3MultiassetMultiAssets
        messageId: FixedBytes<32>
      }
    }
  /**
   * We have requested that a remote chain send us XCM version change notifications.
   **/
  | {
      name: 'VersionNotifyRequested'
      data: {
        destination: StagingXcmV3MultilocationMultiLocation
        cost: StagingXcmV3MultiassetMultiAssets
        messageId: FixedBytes<32>
      }
    }
  /**
   * We have requested that a remote chain stops sending us XCM version change
   * notifications.
   **/
  | {
      name: 'VersionNotifyUnrequested'
      data: {
        destination: StagingXcmV3MultilocationMultiLocation
        cost: StagingXcmV3MultiassetMultiAssets
        messageId: FixedBytes<32>
      }
    }
  /**
   * Fees were paid from a location for an operation (often for using `SendXcm`).
   **/
  | {
      name: 'FeesPaid'
      data: { paying: StagingXcmV3MultilocationMultiLocation; fees: StagingXcmV3MultiassetMultiAssets }
    }
  /**
   * Some assets have been claimed from an asset trap
   **/
  | {
      name: 'AssetsClaimed'
      data: { hash: H256; origin: StagingXcmV3MultilocationMultiLocation; assets: StagingXcmVersionedMultiAssets }
    }

export type StagingXcmV3MultilocationMultiLocation = { parents: number; interior: StagingXcmV3Junctions }

export type StagingXcmV3Junctions =
  | { type: 'Here' }
  | { type: 'X1'; value: StagingXcmV3Junction }
  | { type: 'X2'; value: [StagingXcmV3Junction, StagingXcmV3Junction] }
  | { type: 'X3'; value: [StagingXcmV3Junction, StagingXcmV3Junction, StagingXcmV3Junction] }
  | { type: 'X4'; value: [StagingXcmV3Junction, StagingXcmV3Junction, StagingXcmV3Junction, StagingXcmV3Junction] }
  | {
      type: 'X5'
      value: [
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
      ]
    }
  | {
      type: 'X6'
      value: [
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
      ]
    }
  | {
      type: 'X7'
      value: [
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
      ]
    }
  | {
      type: 'X8'
      value: [
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
        StagingXcmV3Junction,
      ]
    }

export type StagingXcmV3Junction =
  | { type: 'Parachain'; value: number }
  | { type: 'AccountId32'; value: { network?: StagingXcmV3JunctionNetworkId | undefined; id: FixedBytes<32> } }
  | { type: 'AccountIndex64'; value: { network?: StagingXcmV3JunctionNetworkId | undefined; index: bigint } }
  | { type: 'AccountKey20'; value: { network?: StagingXcmV3JunctionNetworkId | undefined; key: FixedBytes<20> } }
  | { type: 'PalletInstance'; value: number }
  | { type: 'GeneralIndex'; value: bigint }
  | { type: 'GeneralKey'; value: { length: number; data: FixedBytes<32> } }
  | { type: 'OnlyChild' }
  | { type: 'Plurality'; value: { id: StagingXcmV3JunctionBodyId; part: StagingXcmV3JunctionBodyPart } }
  | { type: 'GlobalConsensus'; value: StagingXcmV3JunctionNetworkId }

export type StagingXcmV3JunctionNetworkId =
  | { type: 'ByGenesis'; value: FixedBytes<32> }
  | { type: 'ByFork'; value: { blockNumber: bigint; blockHash: FixedBytes<32> } }
  | { type: 'Polkadot' }
  | { type: 'Kusama' }
  | { type: 'Westend' }
  | { type: 'Rococo' }
  | { type: 'Wococo' }
  | { type: 'Ethereum'; value: { chainId: bigint } }
  | { type: 'BitcoinCore' }
  | { type: 'BitcoinCash' }

export type StagingXcmV3JunctionBodyId =
  | { type: 'Unit' }
  | { type: 'Moniker'; value: FixedBytes<4> }
  | { type: 'Index'; value: number }
  | { type: 'Executive' }
  | { type: 'Technical' }
  | { type: 'Legislative' }
  | { type: 'Judicial' }
  | { type: 'Defense' }
  | { type: 'Administration' }
  | { type: 'Treasury' }

export type StagingXcmV3JunctionBodyPart =
  | { type: 'Voice' }
  | { type: 'Members'; value: { count: number } }
  | { type: 'Fraction'; value: { nom: number; denom: number } }
  | { type: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { type: 'MoreThanProportion'; value: { nom: number; denom: number } }

export type StagingXcmV3Xcm = Array<StagingXcmV3Instruction>

export type StagingXcmV3Instruction =
  | { type: 'WithdrawAsset'; value: StagingXcmV3MultiassetMultiAssets }
  | { type: 'ReserveAssetDeposited'; value: StagingXcmV3MultiassetMultiAssets }
  | { type: 'ReceiveTeleportedAsset'; value: StagingXcmV3MultiassetMultiAssets }
  | {
      type: 'QueryResponse'
      value: {
        queryId: bigint
        response: StagingXcmV3Response
        maxWeight: SpWeightsWeightV2Weight
        querier?: StagingXcmV3MultilocationMultiLocation | undefined
      }
    }
  | {
      type: 'TransferAsset'
      value: { assets: StagingXcmV3MultiassetMultiAssets; beneficiary: StagingXcmV3MultilocationMultiLocation }
    }
  | {
      type: 'TransferReserveAsset'
      value: {
        assets: StagingXcmV3MultiassetMultiAssets
        dest: StagingXcmV3MultilocationMultiLocation
        xcm: StagingXcmV3Xcm
      }
    }
  | {
      type: 'Transact'
      value: {
        originKind: StagingXcmV2OriginKind
        requireWeightAtMost: SpWeightsWeightV2Weight
        call: StagingXcmDoubleEncoded
      }
    }
  | { type: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { type: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { type: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { type: 'ClearOrigin' }
  | { type: 'DescendOrigin'; value: StagingXcmV3Junctions }
  | { type: 'ReportError'; value: StagingXcmV3QueryResponseInfo }
  | {
      type: 'DepositAsset'
      value: { assets: StagingXcmV3MultiassetMultiAssetFilter; beneficiary: StagingXcmV3MultilocationMultiLocation }
    }
  | {
      type: 'DepositReserveAsset'
      value: {
        assets: StagingXcmV3MultiassetMultiAssetFilter
        dest: StagingXcmV3MultilocationMultiLocation
        xcm: StagingXcmV3Xcm
      }
    }
  | {
      type: 'ExchangeAsset'
      value: { give: StagingXcmV3MultiassetMultiAssetFilter; want: StagingXcmV3MultiassetMultiAssets; maximal: boolean }
    }
  | {
      type: 'InitiateReserveWithdraw'
      value: {
        assets: StagingXcmV3MultiassetMultiAssetFilter
        reserve: StagingXcmV3MultilocationMultiLocation
        xcm: StagingXcmV3Xcm
      }
    }
  | {
      type: 'InitiateTeleport'
      value: {
        assets: StagingXcmV3MultiassetMultiAssetFilter
        dest: StagingXcmV3MultilocationMultiLocation
        xcm: StagingXcmV3Xcm
      }
    }
  | {
      type: 'ReportHolding'
      value: { responseInfo: StagingXcmV3QueryResponseInfo; assets: StagingXcmV3MultiassetMultiAssetFilter }
    }
  | { type: 'BuyExecution'; value: { fees: StagingXcmV3MultiassetMultiAsset; weightLimit: StagingXcmV3WeightLimit } }
  | { type: 'RefundSurplus' }
  | { type: 'SetErrorHandler'; value: StagingXcmV3Xcm }
  | { type: 'SetAppendix'; value: StagingXcmV3Xcm }
  | { type: 'ClearError' }
  | {
      type: 'ClaimAsset'
      value: { assets: StagingXcmV3MultiassetMultiAssets; ticket: StagingXcmV3MultilocationMultiLocation }
    }
  | { type: 'Trap'; value: bigint }
  | { type: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight } }
  | { type: 'UnsubscribeVersion' }
  | { type: 'BurnAsset'; value: StagingXcmV3MultiassetMultiAssets }
  | { type: 'ExpectAsset'; value: StagingXcmV3MultiassetMultiAssets }
  | { type: 'ExpectOrigin'; value?: StagingXcmV3MultilocationMultiLocation | undefined }
  | { type: 'ExpectError'; value?: [number, StagingXcmV3TraitsError] | undefined }
  | { type: 'ExpectTransactStatus'; value: StagingXcmV3MaybeErrorCode }
  | { type: 'QueryPallet'; value: { moduleName: Bytes; responseInfo: StagingXcmV3QueryResponseInfo } }
  | {
      type: 'ExpectPallet'
      value: { index: number; name: Bytes; moduleName: Bytes; crateMajor: number; minCrateMinor: number }
    }
  | { type: 'ReportTransactStatus'; value: StagingXcmV3QueryResponseInfo }
  | { type: 'ClearTransactStatus' }
  | { type: 'UniversalOrigin'; value: StagingXcmV3Junction }
  | {
      type: 'ExportMessage'
      value: { network: StagingXcmV3JunctionNetworkId; destination: StagingXcmV3Junctions; xcm: StagingXcmV3Xcm }
    }
  | {
      type: 'LockAsset'
      value: { asset: StagingXcmV3MultiassetMultiAsset; unlocker: StagingXcmV3MultilocationMultiLocation }
    }
  | {
      type: 'UnlockAsset'
      value: { asset: StagingXcmV3MultiassetMultiAsset; target: StagingXcmV3MultilocationMultiLocation }
    }
  | {
      type: 'NoteUnlockable'
      value: { asset: StagingXcmV3MultiassetMultiAsset; owner: StagingXcmV3MultilocationMultiLocation }
    }
  | {
      type: 'RequestUnlock'
      value: { asset: StagingXcmV3MultiassetMultiAsset; locker: StagingXcmV3MultilocationMultiLocation }
    }
  | { type: 'SetFeesMode'; value: { jitWithdraw: boolean } }
  | { type: 'SetTopic'; value: FixedBytes<32> }
  | { type: 'ClearTopic' }
  | { type: 'AliasOrigin'; value: StagingXcmV3MultilocationMultiLocation }
  | {
      type: 'UnpaidExecution'
      value: { weightLimit: StagingXcmV3WeightLimit; checkOrigin?: StagingXcmV3MultilocationMultiLocation | undefined }
    }

export type StagingXcmV3MultiassetMultiAssets = Array<StagingXcmV3MultiassetMultiAsset>

export type StagingXcmV3MultiassetMultiAsset = {
  id: StagingXcmV3MultiassetAssetId
  fun: StagingXcmV3MultiassetFungibility
}

export type StagingXcmV3MultiassetAssetId =
  | { type: 'Concrete'; value: StagingXcmV3MultilocationMultiLocation }
  | { type: 'Abstract'; value: FixedBytes<32> }

export type StagingXcmV3MultiassetFungibility =
  | { type: 'Fungible'; value: bigint }
  | { type: 'NonFungible'; value: StagingXcmV3MultiassetAssetInstance }

export type StagingXcmV3MultiassetAssetInstance =
  | { type: 'Undefined' }
  | { type: 'Index'; value: bigint }
  | { type: 'Array4'; value: FixedBytes<4> }
  | { type: 'Array8'; value: FixedBytes<8> }
  | { type: 'Array16'; value: FixedBytes<16> }
  | { type: 'Array32'; value: FixedBytes<32> }

export type StagingXcmV3Response =
  | { type: 'Null' }
  | { type: 'Assets'; value: StagingXcmV3MultiassetMultiAssets }
  | { type: 'ExecutionResult'; value?: [number, StagingXcmV3TraitsError] | undefined }
  | { type: 'Version'; value: number }
  | { type: 'PalletsInfo'; value: Array<StagingXcmV3PalletInfo> }
  | { type: 'DispatchResult'; value: StagingXcmV3MaybeErrorCode }

export type StagingXcmV3PalletInfo = {
  index: number
  name: Bytes
  moduleName: Bytes
  major: number
  minor: number
  patch: number
}

export type StagingXcmV3MaybeErrorCode =
  | { type: 'Success' }
  | { type: 'Error'; value: Bytes }
  | { type: 'TruncatedError'; value: Bytes }

export type StagingXcmV2OriginKind = 'Native' | 'SovereignAccount' | 'Superuser' | 'Xcm'

export type StagingXcmDoubleEncoded = { encoded: Bytes }

export type StagingXcmV3QueryResponseInfo = {
  destination: StagingXcmV3MultilocationMultiLocation
  queryId: bigint
  maxWeight: SpWeightsWeightV2Weight
}

export type StagingXcmV3MultiassetMultiAssetFilter =
  | { type: 'Definite'; value: StagingXcmV3MultiassetMultiAssets }
  | { type: 'Wild'; value: StagingXcmV3MultiassetWildMultiAsset }

export type StagingXcmV3MultiassetWildMultiAsset =
  | { type: 'All' }
  | { type: 'AllOf'; value: { id: StagingXcmV3MultiassetAssetId; fun: StagingXcmV3MultiassetWildFungibility } }
  | { type: 'AllCounted'; value: number }
  | {
      type: 'AllOfCounted'
      value: { id: StagingXcmV3MultiassetAssetId; fun: StagingXcmV3MultiassetWildFungibility; count: number }
    }

export type StagingXcmV3MultiassetWildFungibility = 'Fungible' | 'NonFungible'

export type StagingXcmV3WeightLimit = { type: 'Unlimited' } | { type: 'Limited'; value: SpWeightsWeightV2Weight }

export type StagingXcmVersionedMultiAssets =
  | { type: 'V2'; value: StagingXcmV2MultiassetMultiAssets }
  | { type: 'V3'; value: StagingXcmV3MultiassetMultiAssets }

export type StagingXcmV2MultiassetMultiAssets = Array<StagingXcmV2MultiassetMultiAsset>

export type StagingXcmV2MultiassetMultiAsset = {
  id: StagingXcmV2MultiassetAssetId
  fun: StagingXcmV2MultiassetFungibility
}

export type StagingXcmV2MultiassetAssetId =
  | { type: 'Concrete'; value: StagingXcmV2MultilocationMultiLocation }
  | { type: 'Abstract'; value: Bytes }

export type StagingXcmV2MultilocationMultiLocation = { parents: number; interior: StagingXcmV2MultilocationJunctions }

export type StagingXcmV2MultilocationJunctions =
  | { type: 'Here' }
  | { type: 'X1'; value: StagingXcmV2Junction }
  | { type: 'X2'; value: [StagingXcmV2Junction, StagingXcmV2Junction] }
  | { type: 'X3'; value: [StagingXcmV2Junction, StagingXcmV2Junction, StagingXcmV2Junction] }
  | { type: 'X4'; value: [StagingXcmV2Junction, StagingXcmV2Junction, StagingXcmV2Junction, StagingXcmV2Junction] }
  | {
      type: 'X5'
      value: [
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
      ]
    }
  | {
      type: 'X6'
      value: [
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
      ]
    }
  | {
      type: 'X7'
      value: [
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
      ]
    }
  | {
      type: 'X8'
      value: [
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
        StagingXcmV2Junction,
      ]
    }

export type StagingXcmV2Junction =
  | { type: 'Parachain'; value: number }
  | { type: 'AccountId32'; value: { network: StagingXcmV2NetworkId; id: FixedBytes<32> } }
  | { type: 'AccountIndex64'; value: { network: StagingXcmV2NetworkId; index: bigint } }
  | { type: 'AccountKey20'; value: { network: StagingXcmV2NetworkId; key: FixedBytes<20> } }
  | { type: 'PalletInstance'; value: number }
  | { type: 'GeneralIndex'; value: bigint }
  | { type: 'GeneralKey'; value: Bytes }
  | { type: 'OnlyChild' }
  | { type: 'Plurality'; value: { id: StagingXcmV2BodyId; part: StagingXcmV2BodyPart } }

export type StagingXcmV2NetworkId =
  | { type: 'Any' }
  | { type: 'Named'; value: Bytes }
  | { type: 'Polkadot' }
  | { type: 'Kusama' }

export type StagingXcmV2BodyId =
  | { type: 'Unit' }
  | { type: 'Named'; value: Bytes }
  | { type: 'Index'; value: number }
  | { type: 'Executive' }
  | { type: 'Technical' }
  | { type: 'Legislative' }
  | { type: 'Judicial' }
  | { type: 'Defense' }
  | { type: 'Administration' }
  | { type: 'Treasury' }

export type StagingXcmV2BodyPart =
  | { type: 'Voice' }
  | { type: 'Members'; value: { count: number } }
  | { type: 'Fraction'; value: { nom: number; denom: number } }
  | { type: 'AtLeastProportion'; value: { nom: number; denom: number } }
  | { type: 'MoreThanProportion'; value: { nom: number; denom: number } }

export type StagingXcmV2MultiassetFungibility =
  | { type: 'Fungible'; value: bigint }
  | { type: 'NonFungible'; value: StagingXcmV2MultiassetAssetInstance }

export type StagingXcmV2MultiassetAssetInstance =
  | { type: 'Undefined' }
  | { type: 'Index'; value: bigint }
  | { type: 'Array4'; value: FixedBytes<4> }
  | { type: 'Array8'; value: FixedBytes<8> }
  | { type: 'Array16'; value: FixedBytes<16> }
  | { type: 'Array32'; value: FixedBytes<32> }
  | { type: 'Blob'; value: Bytes }

export type StagingXcmVersionedMultiLocation =
  | { type: 'V2'; value: StagingXcmV2MultilocationMultiLocation }
  | { type: 'V3'; value: StagingXcmV3MultilocationMultiLocation }

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: 'Endowed'; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: 'DustLost'; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | { name: 'Transfer'; data: { from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * A balance was set by root.
   **/
  | { name: 'BalanceSet'; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: 'Reserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: 'Unreserved'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: 'ReserveRepatriated'
      data: {
        from: AccountId32
        to: AccountId32
        amount: bigint
        destinationStatus: FrameSupportTokensMiscBalanceStatus
      }
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: 'Deposit'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: 'Withdraw'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: 'Slashed'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: 'Minted'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: 'Burned'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: 'Suspended'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: 'Restored'; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: 'Upgraded'; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: 'Issued'; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: 'Rescinded'; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: 'Locked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: 'Unlocked'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: 'Frozen'; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: 'Thawed'; data: { who: AccountId32; amount: bigint } }

export type FrameSupportTokensMiscBalanceStatus = 'Free' | 'Reserved'

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  { name: 'TransactionFeePaid'; data: { who: AccountId32; actualFee: bigint; tip: bigint } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetsEvent =
  /**
   * Some asset class was created.
   **/
  | { name: 'Created'; data: { assetId: number; creator: AccountId32; owner: AccountId32 } }
  /**
   * Some assets were issued.
   **/
  | { name: 'Issued'; data: { assetId: number; owner: AccountId32; amount: bigint } }
  /**
   * Some assets were transferred.
   **/
  | { name: 'Transferred'; data: { assetId: number; from: AccountId32; to: AccountId32; amount: bigint } }
  /**
   * Some assets were destroyed.
   **/
  | { name: 'Burned'; data: { assetId: number; owner: AccountId32; balance: bigint } }
  /**
   * The management team changed.
   **/
  | { name: 'TeamChanged'; data: { assetId: number; issuer: AccountId32; admin: AccountId32; freezer: AccountId32 } }
  /**
   * The owner changed.
   **/
  | { name: 'OwnerChanged'; data: { assetId: number; owner: AccountId32 } }
  /**
   * Some account `who` was frozen.
   **/
  | { name: 'Frozen'; data: { assetId: number; who: AccountId32 } }
  /**
   * Some account `who` was thawed.
   **/
  | { name: 'Thawed'; data: { assetId: number; who: AccountId32 } }
  /**
   * Some asset `asset_id` was frozen.
   **/
  | { name: 'AssetFrozen'; data: { assetId: number } }
  /**
   * Some asset `asset_id` was thawed.
   **/
  | { name: 'AssetThawed'; data: { assetId: number } }
  /**
   * Accounts were destroyed for given asset.
   **/
  | { name: 'AccountsDestroyed'; data: { assetId: number; accountsDestroyed: number; accountsRemaining: number } }
  /**
   * Approvals were destroyed for given asset.
   **/
  | { name: 'ApprovalsDestroyed'; data: { assetId: number; approvalsDestroyed: number; approvalsRemaining: number } }
  /**
   * An asset class is in the process of being destroyed.
   **/
  | { name: 'DestructionStarted'; data: { assetId: number } }
  /**
   * An asset class was destroyed.
   **/
  | { name: 'Destroyed'; data: { assetId: number } }
  /**
   * Some asset class was force-created.
   **/
  | { name: 'ForceCreated'; data: { assetId: number; owner: AccountId32 } }
  /**
   * New metadata has been set for an asset.
   **/
  | { name: 'MetadataSet'; data: { assetId: number; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean } }
  /**
   * Metadata has been cleared for an asset.
   **/
  | { name: 'MetadataCleared'; data: { assetId: number } }
  /**
   * (Additional) funds have been approved for transfer to a destination account.
   **/
  | { name: 'ApprovedTransfer'; data: { assetId: number; source: AccountId32; delegate: AccountId32; amount: bigint } }
  /**
   * An approval for account `delegate` was cancelled by `owner`.
   **/
  | { name: 'ApprovalCancelled'; data: { assetId: number; owner: AccountId32; delegate: AccountId32 } }
  /**
   * An `amount` was transferred in its entirety from `owner` to `destination` by
   * the approved `delegate`.
   **/
  | {
      name: 'TransferredApproved'
      data: { assetId: number; owner: AccountId32; delegate: AccountId32; destination: AccountId32; amount: bigint }
    }
  /**
   * An asset has had its attributes changed by the `Force` origin.
   **/
  | { name: 'AssetStatusChanged'; data: { assetId: number } }
  /**
   * The min_balance of an asset has been updated by the asset owner.
   **/
  | { name: 'AssetMinBalanceChanged'; data: { assetId: number; newMinBalance: bigint } }
  /**
   * Some account `who` was created with a deposit from `depositor`.
   **/
  | { name: 'Touched'; data: { assetId: number; who: AccountId32; depositor: AccountId32 } }
  /**
   * Some account `who` was blocked.
   **/
  | { name: 'Blocked'; data: { assetId: number; who: AccountId32 } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollatorSelectionEvent =
  /**
   * New Invulnerables were set.
   **/
  | { name: 'NewInvulnerables'; data: { invulnerables: Array<AccountId32> } }
  /**
   * A new Invulnerable was added.
   **/
  | { name: 'InvulnerableAdded'; data: { accountId: AccountId32 } }
  /**
   * An Invulnerable was removed.
   **/
  | { name: 'InvulnerableRemoved'; data: { accountId: AccountId32 } }
  /**
   * The number of desired candidates was set.
   **/
  | { name: 'NewDesiredCandidates'; data: { desiredCandidates: number } }
  /**
   * The candidacy bond was set.
   **/
  | { name: 'NewCandidacyBond'; data: { bondAmount: bigint } }
  /**
   * A new candidate joined.
   **/
  | { name: 'CandidateAdded'; data: { accountId: AccountId32; deposit: bigint } }
  /**
   * A candidate was removed.
   **/
  | { name: 'CandidateRemoved'; data: { accountId: AccountId32 } }
  /**
   * An account was unable to be added to the Invulnerables because they did not have keys
   * registered. Other Invulnerables may have been set.
   **/
  | { name: 'InvalidInvulnerableSkipped'; data: { accountId: AccountId32 } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletSessionEvent =
  /**
   * New session has happened. Note that the argument is the session index, not the
   * block number as the type might suggest.
   **/
  { name: 'NewSession'; data: { sessionIndex: number } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletIdentityEvent =
  /**
   * A name was set or reset (which will remove all judgements).
   **/
  | { name: 'IdentitySet'; data: { who: AccountId32 } }
  /**
   * A name was cleared, and the given balance returned.
   **/
  | { name: 'IdentityCleared'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A name was removed and the given balance slashed.
   **/
  | { name: 'IdentityKilled'; data: { who: AccountId32; deposit: bigint } }
  /**
   * A judgement was asked from a registrar.
   **/
  | { name: 'JudgementRequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement request was retracted.
   **/
  | { name: 'JudgementUnrequested'; data: { who: AccountId32; registrarIndex: number } }
  /**
   * A judgement was given by a registrar.
   **/
  | { name: 'JudgementGiven'; data: { target: AccountId32; registrarIndex: number } }
  /**
   * A registrar was added.
   **/
  | { name: 'RegistrarAdded'; data: { registrarIndex: number } }
  /**
   * A sub-identity was added to an identity and the deposit paid.
   **/
  | { name: 'SubIdentityAdded'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was removed from an identity and the deposit freed.
   **/
  | { name: 'SubIdentityRemoved'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }
  /**
   * A sub-identity was cleared, and the given deposit repatriated from the
   * main identity account to the sub-identity account.
   **/
  | { name: 'SubIdentityRevoked'; data: { sub: AccountId32; main: AccountId32; deposit: bigint } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletDemocracyEvent =
  /**
   * A motion has been proposed by a public account.
   **/
  | { name: 'Proposed'; data: { proposalIndex: number; deposit: bigint } }
  /**
   * A public proposal has been tabled for referendum vote.
   **/
  | { name: 'Tabled'; data: { proposalIndex: number; deposit: bigint } }
  /**
   * An external proposal has been tabled.
   **/
  | { name: 'ExternalTabled' }
  /**
   * A referendum has begun.
   **/
  | { name: 'Started'; data: { refIndex: number; threshold: PalletDemocracyVoteThreshold } }
  /**
   * A proposal has been approved by referendum.
   **/
  | { name: 'Passed'; data: { refIndex: number } }
  /**
   * A proposal has been rejected by referendum.
   **/
  | { name: 'NotPassed'; data: { refIndex: number } }
  /**
   * A referendum has been cancelled.
   **/
  | { name: 'Cancelled'; data: { refIndex: number } }
  /**
   * An account has delegated their vote to another account.
   **/
  | { name: 'Delegated'; data: { who: AccountId32; target: AccountId32 } }
  /**
   * An account has cancelled a previous delegation operation.
   **/
  | { name: 'Undelegated'; data: { account: AccountId32 } }
  /**
   * An external proposal has been vetoed.
   **/
  | { name: 'Vetoed'; data: { who: AccountId32; proposalHash: H256; until: number } }
  /**
   * A proposal_hash has been blacklisted permanently.
   **/
  | { name: 'Blacklisted'; data: { proposalHash: H256 } }
  /**
   * An account has voted in a referendum
   **/
  | { name: 'Voted'; data: { voter: AccountId32; refIndex: number; vote: PalletDemocracyVoteAccountVote } }
  /**
   * An account has secconded a proposal
   **/
  | { name: 'Seconded'; data: { seconder: AccountId32; propIndex: number } }
  /**
   * A proposal got canceled.
   **/
  | { name: 'ProposalCanceled'; data: { propIndex: number } }
  /**
   * Metadata for a proposal or a referendum has been set.
   **/
  | {
      name: 'MetadataSet'
      data: {
        /**
         * Metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner

        /**
         * Preimage hash.
         **/
        hash: H256
      }
    }
  /**
   * Metadata for a proposal or a referendum has been cleared.
   **/
  | {
      name: 'MetadataCleared'
      data: {
        /**
         * Metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner

        /**
         * Preimage hash.
         **/
        hash: H256
      }
    }
  /**
   * Metadata has been transferred to new owner.
   **/
  | {
      name: 'MetadataTransferred'
      data: {
        /**
         * Previous metadata owner.
         **/
        prevOwner: PalletDemocracyMetadataOwner

        /**
         * New metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner

        /**
         * Preimage hash.
         **/
        hash: H256
      }
    }

export type PalletDemocracyVoteThreshold = 'SuperMajorityApprove' | 'SuperMajorityAgainst' | 'SimpleMajority'

export type PalletDemocracyVoteAccountVote =
  | { type: 'Standard'; value: { vote: PalletDemocracyVote; balance: bigint } }
  | { type: 'Split'; value: { aye: bigint; nay: bigint } }

export type PalletDemocracyVote = number

export type PalletDemocracyMetadataOwner =
  | { type: 'External' }
  | { type: 'Proposal'; value: number }
  | { type: 'Referendum'; value: number }

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollectiveEvent =
  /**
   * A motion (given hash) has been proposed (by given account) with a threshold (given
   * `MemberCount`).
   **/
  | { name: 'Proposed'; data: { account: AccountId32; proposalIndex: number; proposalHash: H256; threshold: number } }
  /**
   * A motion (given hash) has been voted on by given account, leaving
   * a tally (yes votes and no votes given respectively as `MemberCount`).
   **/
  | { name: 'Voted'; data: { account: AccountId32; proposalHash: H256; voted: boolean; yes: number; no: number } }
  /**
   * A motion was approved by the required threshold.
   **/
  | { name: 'Approved'; data: { proposalHash: H256 } }
  /**
   * A motion was not approved by the required threshold.
   **/
  | { name: 'Disapproved'; data: { proposalHash: H256 } }
  /**
   * A motion was executed; result will be `Ok` if it returned without error.
   **/
  | { name: 'Executed'; data: { proposalHash: H256; result: Result<[], DispatchError> } }
  /**
   * A single member did some action; result will be `Ok` if it returned without error.
   **/
  | { name: 'MemberExecuted'; data: { proposalHash: H256; result: Result<[], DispatchError> } }
  /**
   * A proposal was closed because its threshold was reached or after its duration was up.
   **/
  | { name: 'Closed'; data: { proposalHash: H256; yes: number; no: number } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletTreasuryEvent =
  /**
   * New proposal.
   **/
  | { name: 'Proposed'; data: { proposalIndex: number } }
  /**
   * We have ended a spend period and will now allocate funds.
   **/
  | { name: 'Spending'; data: { budgetRemaining: bigint } }
  /**
   * Some funds have been allocated.
   **/
  | { name: 'Awarded'; data: { proposalIndex: number; award: bigint; account: AccountId32 } }
  /**
   * A proposal was rejected; funds were slashed.
   **/
  | { name: 'Rejected'; data: { proposalIndex: number; slashed: bigint } }
  /**
   * Some of our funds have been burnt.
   **/
  | { name: 'Burnt'; data: { burntFunds: bigint } }
  /**
   * Spending has finished; this is the amount that rolls over until next spend.
   **/
  | { name: 'Rollover'; data: { rolloverBalance: bigint } }
  /**
   * Some funds have been deposited.
   **/
  | { name: 'Deposit'; data: { value: bigint } }
  /**
   * A new spend proposal has been approved.
   **/
  | { name: 'SpendApproved'; data: { proposalIndex: number; amount: bigint; beneficiary: AccountId32 } }
  /**
   * The inactive funds of the pallet have been updated.
   **/
  | { name: 'UpdatedInactive'; data: { reactivated: bigint; deactivated: bigint } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletBountiesEvent =
  /**
   * New bounty proposal.
   **/
  | { name: 'BountyProposed'; data: { index: number } }
  /**
   * A bounty proposal was rejected; funds were slashed.
   **/
  | { name: 'BountyRejected'; data: { index: number; bond: bigint } }
  /**
   * A bounty proposal is funded and became active.
   **/
  | { name: 'BountyBecameActive'; data: { index: number } }
  /**
   * A bounty is awarded to a beneficiary.
   **/
  | { name: 'BountyAwarded'; data: { index: number; beneficiary: AccountId32 } }
  /**
   * A bounty is claimed by beneficiary.
   **/
  | { name: 'BountyClaimed'; data: { index: number; payout: bigint; beneficiary: AccountId32 } }
  /**
   * A bounty is cancelled.
   **/
  | { name: 'BountyCanceled'; data: { index: number } }
  /**
   * A bounty expiry is extended.
   **/
  | { name: 'BountyExtended'; data: { index: number } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletLotteryEvent =
  /**
   * A lottery has been started!
   **/
  | { name: 'LotteryStarted' }
  /**
   * A new set of calls have been set!
   **/
  | { name: 'CallsUpdated' }
  /**
   * A winner has been chosen!
   **/
  | { name: 'Winner'; data: { winner: AccountId32; lotteryBalance: bigint } }
  /**
   * A ticket has been bought!
   **/
  | { name: 'TicketBought'; data: { who: AccountId32; callIndex: [number, number] } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletMembershipEvent =
  /**
   * The given member was added; see the transaction for who.
   **/
  | 'MemberAdded'
  /**
   * The given member was removed; see the transaction for who.
   **/
  | 'MemberRemoved'
  /**
   * Two members were swapped; see the transaction for who.
   **/
  | 'MembersSwapped'
  /**
   * The membership was reset; see the transaction for who the new set is.
   **/
  | 'MembersReset'
  /**
   * One of the members' keys changed.
   **/
  | 'KeyChanged'
  /**
   * Phantom member, never used.
   **/
  | 'Dummy'

/**
 * The `Event` enum of this pallet
 **/
export type PalletElectionsPhragmenEvent =
  /**
   * A new term with new_members. This indicates that enough candidates existed to run
   * the election, not that enough have has been elected. The inner value must be examined
   * for this purpose. A `NewTerm(\[\])` indicates that some candidates got their bond
   * slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to
   * begin with.
   **/
  | { name: 'NewTerm'; data: { newMembers: Array<[AccountId32, bigint]> } }
  /**
   * No (or not enough) candidates existed for this round. This is different from
   * `NewTerm(\[\])`. See the description of `NewTerm`.
   **/
  | { name: 'EmptyTerm' }
  /**
   * Internal error happened while trying to perform election.
   **/
  | { name: 'ElectionError' }
  /**
   * A member has been removed. This should always be followed by either `NewTerm` or
   * `EmptyTerm`.
   **/
  | { name: 'MemberKicked'; data: { member: AccountId32 } }
  /**
   * Someone has renounced their candidacy.
   **/
  | { name: 'Renounced'; data: { candidate: AccountId32 } }
  /**
   * A candidate was slashed by amount due to failing to obtain a seat as member or
   * runner-up.
   *
   * Note that old members and runners-up are also candidates.
   **/
  | { name: 'CandidateSlashed'; data: { candidate: AccountId32; amount: bigint } }
  /**
   * A seat holder was slashed by amount by being forcefully removed from the set.
   **/
  | { name: 'SeatHolderSlashed'; data: { seatHolder: AccountId32; amount: bigint } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletTipsEvent =
  /**
   * A new tip suggestion has been opened.
   **/
  | { name: 'NewTip'; data: { tipHash: H256 } }
  /**
   * A tip suggestion has reached threshold and is closing.
   **/
  | { name: 'TipClosing'; data: { tipHash: H256 } }
  /**
   * A tip suggestion has been closed.
   **/
  | { name: 'TipClosed'; data: { tipHash: H256; who: AccountId32; payout: bigint } }
  /**
   * A tip suggestion has been retracted.
   **/
  | { name: 'TipRetracted'; data: { tipHash: H256 } }
  /**
   * A tip suggestion has been slashed.
   **/
  | { name: 'TipSlashed'; data: { tipHash: H256; finder: AccountId32; deposit: bigint } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletChildBountiesEvent =
  /**
   * A child-bounty is added.
   **/
  | { name: 'Added'; data: { index: number; childIndex: number } }
  /**
   * A child-bounty is awarded to a beneficiary.
   **/
  | { name: 'Awarded'; data: { index: number; childIndex: number; beneficiary: AccountId32 } }
  /**
   * A child-bounty is claimed by beneficiary.
   **/
  | { name: 'Claimed'; data: { index: number; childIndex: number; payout: bigint; beneficiary: AccountId32 } }
  /**
   * A child-bounty is cancelled.
   **/
  | { name: 'Canceled'; data: { index: number; childIndex: number } }

/**
 * The `Event` enum of this pallet
 **/
export type SubbridgePalletsChainbridgePalletEvent =
  /**
   * Vote threshold has changed (new_threshold)
   **/
  | { name: 'RelayerThresholdChanged'; data: number }
  /**
   * Chain now available for transfers (chain_id)
   **/
  | { name: 'ChainWhitelisted'; data: number }
  /**
   * Relayer added to set
   **/
  | { name: 'RelayerAdded'; data: AccountId32 }
  /**
   * Relayer removed from set
   **/
  | { name: 'RelayerRemoved'; data: AccountId32 }
  /**
   * FungibleTransfer is for relaying fungibles (dest_id, nonce, resource_id, amount, recipient)
   **/
  | { name: 'FungibleTransfer'; data: [number, bigint, FixedBytes<32>, U256, Bytes] }
  /**
   * NonFungibleTransfer is for relaying NFTs (dest_id, nonce, resource_id, token_id, recipient, metadata)
   **/
  | { name: 'NonFungibleTransfer'; data: [number, bigint, FixedBytes<32>, Bytes, Bytes, Bytes] }
  /**
   * GenericTransfer is for a generic data payload (dest_id, nonce, resource_id, metadata)
   **/
  | { name: 'GenericTransfer'; data: [number, bigint, FixedBytes<32>, Bytes] }
  /**
   * Vote submitted in favour of proposal
   **/
  | { name: 'VoteFor'; data: [number, bigint, AccountId32] }
  /**
   * Vot submitted against proposal
   **/
  | { name: 'VoteAgainst'; data: [number, bigint, AccountId32] }
  /**
   * Voting successful for a proposal
   **/
  | { name: 'ProposalApproved'; data: [number, bigint] }
  /**
   * Voting rejected a proposal
   **/
  | { name: 'ProposalRejected'; data: [number, bigint] }
  /**
   * Execution of call succeeded
   **/
  | { name: 'ProposalSucceeded'; data: [number, bigint] }
  /**
   * Execution of call failed
   **/
  | { name: 'ProposalFailed'; data: [number, bigint] }
  | { name: 'FeeUpdated'; data: { destId: number; fee: bigint } }

/**
 * The `Event` enum of this pallet
 **/
export type SubbridgePalletsXcmbridgePalletEvent =
  /**
   * Assets sent to parachain or relaychain.
   **/
  {
    name: 'AssetTransfered'
    data: {
      asset: StagingXcmV3MultiassetMultiAsset
      origin: StagingXcmV3MultilocationMultiLocation
      dest: StagingXcmV3MultilocationMultiLocation
    }
  }

/**
 * The `Event` enum of this pallet
 **/
export type SubbridgePalletsXtransferPalletEvent =
  /**
   * Assets being withdrawn from somewhere.
   **/
  | {
      name: 'Withdrawn'
      data: { what: StagingXcmV3MultiassetMultiAsset; who: StagingXcmV3MultilocationMultiLocation; memo: Bytes }
    }
  /**
   * Assets being deposited to somewhere.
   **/
  | {
      name: 'Deposited'
      data: { what: StagingXcmV3MultiassetMultiAsset; who: StagingXcmV3MultilocationMultiLocation; memo: Bytes }
    }
  /**
   * Assets being forwarded to somewhere.
   **/
  | {
      name: 'Forwarded'
      data: { what: StagingXcmV3MultiassetMultiAsset; who: StagingXcmV3MultilocationMultiLocation; memo: Bytes }
    }

/**
 * The `Event` enum of this pallet
 **/
export type AssetsRegistryEvent =
  /**
   * Asset is registerd.
   **/
  | { name: 'AssetRegistered'; data: { assetId: number; location: StagingXcmV3MultilocationMultiLocation } }
  /**
   * Asset is unregisterd.
   **/
  | { name: 'AssetUnregistered'; data: { assetId: number; location: StagingXcmV3MultilocationMultiLocation } }
  /**
   * Asset enabled chainbridge.
   **/
  | { name: 'ChainbridgeEnabled'; data: { assetId: number; chainId: number; resourceId: FixedBytes<32> } }
  /**
   * Asset disabled chainbridge.
   **/
  | { name: 'ChainbridgeDisabled'; data: { assetId: number; chainId: number; resourceId: FixedBytes<32> } }
  /**
   * Asset enabled sygmabridge.
   **/
  | { name: 'SygmabridgeEnabled'; data: { assetId: number; domainId: number; resourceId: FixedBytes<32> } }
  /**
   * Asset disabled sygmabridge.
   **/
  | { name: 'SygmabridgeDisabled'; data: { assetId: number; domainId: number; resourceId: FixedBytes<32> } }
  /**
   * Force mint asset to an certain account.
   **/
  | { name: 'ForceMinted'; data: { assetId: number; beneficiary: AccountId32; amount: bigint } }
  /**
   * Force burn asset from an certain account.
   **/
  | { name: 'ForceBurnt'; data: { assetId: number; who: AccountId32; amount: bigint } }

/**
 * The `Event` enum of this pallet
 **/
export type PhalaPalletsRegistryPalletEvent =
  /**
   * A new Gatekeeper is enabled on the blockchain
   **/
  | { name: 'GatekeeperAdded'; data: { pubkey: SpCoreSr25519Public } }
  | { name: 'GatekeeperRemoved'; data: { pubkey: SpCoreSr25519Public } }
  | {
      name: 'WorkerAdded'
      data: {
        pubkey: SpCoreSr25519Public
        attestationProvider?: PhalaTypesAttestationProvider | undefined
        confidenceLevel: number
      }
    }
  | {
      name: 'WorkerUpdated'
      data: {
        pubkey: SpCoreSr25519Public
        attestationProvider?: PhalaTypesAttestationProvider | undefined
        confidenceLevel: number
      }
    }
  | { name: 'MasterKeyRotated'; data: { rotationId: bigint; masterPubkey: SpCoreSr25519Public } }
  | { name: 'MasterKeyRotationFailed'; data: { rotationLock?: bigint | undefined; gatekeeperRotationId: bigint } }
  | { name: 'InitialScoreSet'; data: { pubkey: SpCoreSr25519Public; initScore: number } }
  | { name: 'MinimumPRuntimeVersionChangedTo'; data: [number, number, number] }
  | { name: 'PRuntimeConsensusVersionChangedTo'; data: number }
  | { name: 'GatekeeperLaunched' }

export type SpCoreSr25519Public = FixedBytes<32>

export type PhalaTypesAttestationProvider = 'Root' | 'Ias' | 'Dcap'

/**
 * The `Event` enum of this pallet
 **/
export type PhalaPalletsComputeComputationPalletEvent =
  /**
   * Cool down expiration changed (in sec).
   *
   * Indicates a change in [`CoolDownPeriod`].
   **/
  | { name: 'CoolDownExpirationChanged'; data: { period: bigint } }
  /**
   * A worker starts computing.
   *
   * Affected states:
   * - the worker info at [`Sessions`] is updated with `WorkerIdle` state
   * - [`NextSessionId`] for the session is incremented
   * - [`Stakes`] for the session is updated
   * - [`OnlineWorkers`] is incremented
   **/
  | { name: 'WorkerStarted'; data: { session: AccountId32; initV: bigint; initP: number } }
  /**
   * Worker stops computing.
   *
   * Affected states:
   * - the worker info at [`Sessions`] is updated with `WorkerCoolingDown` state
   * - [`OnlineWorkers`] is decremented
   **/
  | { name: 'WorkerStopped'; data: { session: AccountId32 } }
  /**
   * Worker is reclaimed, with its slash settled.
   **/
  | { name: 'WorkerReclaimed'; data: { session: AccountId32; originalStake: bigint; slashed: bigint } }
  /**
   * Worker & session are bounded.
   *
   * Affected states:
   * - [`SessionBindings`] for the session account is pointed to the worker
   * - [`WorkerBindings`] for the worker is pointed to the session account
   * - the worker info at [`Sessions`] is updated with `Ready` state
   **/
  | { name: 'SessionBound'; data: { session: AccountId32; worker: SpCoreSr25519Public } }
  /**
   * Worker & worker are unbound.
   *
   * Affected states:
   * - [`SessionBindings`] for the session account is removed
   * - [`WorkerBindings`] for the worker is removed
   **/
  | { name: 'SessionUnbound'; data: { session: AccountId32; worker: SpCoreSr25519Public } }
  /**
   * Worker enters unresponsive state.
   *
   * Affected states:
   * - the worker info at [`Sessions`] is updated from `WorkerIdle` to `WorkerUnresponsive`
   **/
  | { name: 'WorkerEnterUnresponsive'; data: { session: AccountId32 } }
  /**
   * Worker returns to responsive state.
   *
   * Affected states:
   * - the worker info at [`Sessions`] is updated from `WorkerUnresponsive` to `WorkerIdle`
   **/
  | { name: 'WorkerExitUnresponsive'; data: { session: AccountId32 } }
  /**
   * Worker settled successfully.
   *
   * It results in the v in [`Sessions`] being updated. It also indicates the downstream
   * stake pool has received the computing reward (payout), and the treasury has received the
   * tax.
   **/
  | { name: 'SessionSettled'; data: { session: AccountId32; vBits: bigint; payoutBits: bigint } }
  /**
   * Some internal error happened when settling a worker's ledger.
   **/
  | { name: 'InternalErrorWorkerSettleFailed'; data: { worker: SpCoreSr25519Public } }
  /**
   * Block subsidy halved by 25%.
   *
   * This event will be followed by a [`TokenomicParametersChanged`](#variant.TokenomicParametersChanged)
   * event indicating the change of the block subsidy budget in the parameter.
   **/
  | { name: 'SubsidyBudgetHalved' }
  /**
   * Some internal error happened when trying to halve the subsidy
   **/
  | { name: 'InternalErrorWrongHalvingConfigured' }
  /**
   * Tokenomic parameter changed.
   *
   * Affected states:
   * - [`TokenomicParameters`] is updated.
   **/
  | { name: 'TokenomicParametersChanged' }
  /**
   * A session settlement was dropped because the on-chain version is more up-to-date.
   *
   * This is a temporary walk-around of the computing staking design. Will be fixed by
   * StakePool v2.
   **/
  | { name: 'SessionSettlementDropped'; data: { session: AccountId32; v: bigint; payout: bigint } }
  /**
   * Benchmark Updated
   **/
  | { name: 'BenchmarkUpdated'; data: { session: AccountId32; pInstant: number } }
  | { name: 'BudgetUpdated'; data: { nonce: bigint; budget: bigint } }

/**
 * The `Event` enum of this pallet
 **/
export type PhalaPalletsStakePoolPalletEvent = null

/**
 * The `Event` enum of this pallet
 **/
export type PhalaPalletsComputeStakePoolV2PalletEvent =
  /**
   * A stake pool is created by `owner`
   *
   * Affected states:
   * - a new entry in [`Pools`] with the pid
   **/
  | { name: 'PoolCreated'; data: { owner: AccountId32; pid: bigint; cid: number; poolAccountId: AccountId32 } }
  /**
   * The commission of a pool is updated
   *
   * The commission ratio is represented by an integer. The real value is
   * `commission / 1_000_000u32`.
   *
   * Affected states:
   * - the `payout_commission` field in [`Pools`] is updated
   **/
  | { name: 'PoolCommissionSet'; data: { pid: bigint; commission: number } }
  /**
   * The stake capacity of the pool is updated
   *
   * Affected states:
   * - the `cap` field in [`Pools`] is updated
   **/
  | { name: 'PoolCapacitySet'; data: { pid: bigint; cap: bigint } }
  /**
   * A worker is added to the pool
   *
   * Affected states:
   * - the `worker` is added to the vector `workers` in [`Pools`]
   * - the worker in the [`WorkerAssignments`] is pointed to `pid`
   * - the worker-session binding is updated in `computation` pallet ([`WorkerBindings`](computation::pallet::WorkerBindings),
   * [`SessionBindings`](computation::pallet::SessionBindings))
   **/
  | { name: 'PoolWorkerAdded'; data: { pid: bigint; worker: SpCoreSr25519Public; session: AccountId32 } }
  /**
   * Someone contributed to a pool
   *
   * Affected states:
   * - the stake related fields in [`Pools`]
   * - the user W-PHA balance reduced
   * - the user recive ad share NFT once contribution succeeded
   * - when there was any request in the withdraw queue, the action may trigger withdrawals
   * ([`Withdrawal`](#variant.Withdrawal) event)
   **/
  | {
      name: 'Contribution'
      data: { pid: bigint; user: AccountId32; amount: bigint; shares: bigint; asVault?: bigint | undefined }
    }
  /**
   * Owner rewards were withdrawn by pool owner
   *
   * Affected states:
   * - the stake related fields in [`Pools`]
   * - the owner asset account
   **/
  | { name: 'OwnerRewardsWithdrawn'; data: { pid: bigint; user: AccountId32; amount: bigint } }
  /**
   * The pool received a slash event from one of its workers (currently disabled)
   *
   * The slash is accured to the pending slash accumulator.
   **/
  | { name: 'PoolSlashed'; data: { pid: bigint; amount: bigint } }
  /**
   * Some slash is actually settled to a contributor (currently disabled)
   **/
  | { name: 'SlashSettled'; data: { pid: bigint; user: AccountId32; amount: bigint } }
  /**
   * Some reward is dismissed because the worker is no longer bound to a pool
   *
   * There's no affected state.
   **/
  | { name: 'RewardDismissedNotInPool'; data: { worker: SpCoreSr25519Public; amount: bigint } }
  /**
   * Some reward is dismissed because the pool doesn't have any share
   *
   * There's no affected state.
   **/
  | { name: 'RewardDismissedNoShare'; data: { pid: bigint; amount: bigint } }
  /**
   * Some reward is dismissed because the amount is too tiny (dust)
   *
   * There's no affected state.
   **/
  | { name: 'RewardDismissedDust'; data: { pid: bigint; amount: bigint } }
  /**
   * A worker is removed from a pool.
   *
   * Affected states:
   * - the worker item in [`WorkerAssignments`] is removed
   * - the worker is removed from the [`Pools`] item
   **/
  | { name: 'PoolWorkerRemoved'; data: { pid: bigint; worker: SpCoreSr25519Public } }
  /**
   * A worker is reclaimed from the pool
   **/
  | { name: 'WorkerReclaimed'; data: { pid: bigint; worker: SpCoreSr25519Public } }
  /**
   * The amount of reward that distributed to owner and stakers
   **/
  | { name: 'RewardReceived'; data: { pid: bigint; toOwner: bigint; toStakers: bigint } }
  /**
   * The amount of stakes for a worker to start computing
   **/
  | { name: 'WorkingStarted'; data: { pid: bigint; worker: SpCoreSr25519Public; amount: bigint } }
  /**
   * Some to-distribute reward is dismissed because the amount is too tiny (dust)
   *
   * There's no affected state.
   **/
  | { name: 'RewardToOwnerDismissedDust'; data: { pid: bigint; amount: bigint } }
  /**
   * Some to-distribute reward is dismissed because the amount is too tiny (dust)
   *
   * There's no affected state.
   **/
  | { name: 'RewardToDistributionDismissedDust'; data: { pid: bigint; amount: bigint } }

/**
 * The `Event` enum of this pallet
 **/
export type PhalaPalletsComputeVaultPalletEvent =
  /**
   * A vault is created by `owner`
   *
   * Affected states:
   * - a new entry in [`Pools`] with the pid
   **/
  | { name: 'PoolCreated'; data: { owner: AccountId32; pid: bigint; cid: number; poolAccountId: AccountId32 } }
  /**
   * The commission of a vault is updated
   *
   * The commission ratio is represented by an integer. The real value is
   * `commission / 1_000_000u32`.
   *
   * Affected states:
   * - the `commission` field in [`Pools`] is updated
   **/
  | { name: 'VaultCommissionSet'; data: { pid: bigint; commission: number } }
  /**
   * Owner shares is claimed by pool owner
   * Affected states:
   * - the shares related fields in [`Pools`]
   * - the nft related storages in rmrk and pallet unique
   **/
  | { name: 'OwnerSharesClaimed'; data: { pid: bigint; user: AccountId32; shares: bigint } }
  /**
   * Additional owner shares are mint into the pool
   *
   * Affected states:
   * - the shares related fields in [`Pools`]
   * - last_share_price_checkpoint in [`Pools`]
   **/
  | { name: 'OwnerSharesGained'; data: { pid: bigint; shares: bigint; checkoutPrice: bigint } }
  /**
   * Someone contributed to a vault
   *
   * Affected states:
   * - the stake related fields in [`Pools`]
   * - the user W-PHA balance reduced
   * - the user recive ad share NFT once contribution succeeded
   * - when there was any request in the withdraw queue, the action may trigger withdrawals
   * ([`Withdrawal`](#variant.Withdrawal) event)
   **/
  | { name: 'Contribution'; data: { pid: bigint; user: AccountId32; amount: bigint; shares: bigint } }
  | { name: 'ForceShutdown'; data: { pid: bigint; reason: PhalaPalletsComputeVaultPalletForceShutdownReason } }

export type PhalaPalletsComputeVaultPalletForceShutdownReason = 'NoEnoughReleasingStake' | 'Waiting3xGracePeriod'

/**
 * The `Event` enum of this pallet
 **/
export type PhalaPalletsComputeWrappedBalancesPalletEvent =
  /**
   * Some dust stake is removed
   *
   * Triggered when the remaining stake of a user is too small after withdrawal or slash.
   *
   * Affected states:
   * - the balance of the locking ledger of the contributor at [`StakeLedger`] is set to 0
   * - the user's dust stake is moved to treasury
   **/
  | { name: 'DustRemoved'; data: { user: AccountId32; amount: bigint } }
  | { name: 'Wrapped'; data: { user: AccountId32; amount: bigint } }
  | { name: 'Unwrapped'; data: { user: AccountId32; amount: bigint } }
  | { name: 'Voted'; data: { user: AccountId32; voteId: number; ayeAmount: bigint; nayAmount: bigint } }

/**
 * The `Event` enum of this pallet
 **/
export type PhalaPalletsComputeBasePoolPalletEvent =
  /**
   * A Nft is created to contain pool shares
   **/
  | { name: 'NftCreated'; data: { pid: bigint; cid: number; nftId: number; owner: AccountId32; shares: bigint } }
  /**
   * A withdrawal request is inserted to a queue
   *
   * Affected states:
   * - a new item is inserted to or an old item is being replaced by the new item in the
   * withdraw queue in [`Pools`]
   **/
  | {
      name: 'WithdrawalQueued'
      data: {
        pid: bigint
        user: AccountId32
        shares: bigint

        /**
         * Target NFT to withdraw
         **/
        nftId: number
        asVault?: bigint | undefined

        /**
         * Splitted NFT for withdrawing
         **/
        withdrawingNftId: number
      }
    }
  /**
   * Some stake was withdrawn from a pool
   *
   * The lock in [`Balances`](pallet_balances::pallet::Pallet) is updated to release the
   * locked stake.
   *
   * Affected states:
   * - the stake related fields in [`Pools`]
   * - the user staking asset account
   **/
  | {
      name: 'Withdrawal'
      data: { pid: bigint; user: AccountId32; amount: bigint; shares: bigint; burntShares: bigint }
    }
  /**
   * A pool contribution whitelist is added
   *
   * - lazy operated when the first staker is added to the whitelist
   **/
  | { name: 'PoolWhitelistCreated'; data: { pid: bigint } }
  /**
   * The pool contribution whitelist is deleted
   *
   * - lazy operated when the last staker is removed from the whitelist
   **/
  | { name: 'PoolWhitelistDeleted'; data: { pid: bigint } }
  /**
   * A staker is added to the pool contribution whitelist
   **/
  | { name: 'PoolWhitelistStakerAdded'; data: { pid: bigint; staker: AccountId32 } }
  /**
   * A staker is removed from the pool contribution whitelist
   **/
  | { name: 'PoolWhitelistStakerRemoved'; data: { pid: bigint; staker: AccountId32 } }

/**
 * The `Event` enum of this pallet
 **/
export type PhalaPalletsPhatPalletEvent =
  | { name: 'ClusterCreated'; data: { cluster: H256; systemContract: H256 } }
  | { name: 'ClusterPubkeyAvailable'; data: { cluster: H256; pubkey: SpCoreSr25519Public } }
  | { name: 'ClusterDeployed'; data: { cluster: H256; pubkey: SpCoreSr25519Public; worker: SpCoreSr25519Public } }
  | { name: 'ClusterDeploymentFailed'; data: { cluster: H256; worker: SpCoreSr25519Public } }
  | { name: 'Instantiating'; data: { contract: H256; cluster: H256; deployer: AccountId32 } }
  | { name: 'ContractPubkeyAvailable'; data: { contract: H256; cluster: H256; pubkey: SpCoreSr25519Public } }
  | { name: 'Instantiated'; data: { contract: H256; cluster: H256; deployer: H256 } }
  | { name: 'ClusterDestroyed'; data: { cluster: H256 } }
  | { name: 'Transfered'; data: { cluster: H256; account: H256; amount: bigint } }
  | { name: 'WorkerAddedToCluster'; data: { worker: SpCoreSr25519Public; cluster: H256 } }
  | { name: 'WorkerRemovedFromCluster'; data: { worker: SpCoreSr25519Public; cluster: H256 } }

/**
 * The `Event` enum of this pallet
 **/
export type PhalaPalletsPhatTokenomicPalletEvent =
  | { name: 'ContractDepositChanged'; data: { cluster?: H256 | undefined; contract: H256; deposit: bigint } }
  | {
      name: 'UserStakeChanged'
      data: { cluster?: H256 | undefined; account: AccountId32; contract: H256; stake: bigint }
    }

/**
 * The `Event` enum of this pallet
 **/
export type PalletUniquesEvent =
  /**
   * A `collection` was created.
   **/
  | { name: 'Created'; data: { collection: number; creator: AccountId32; owner: AccountId32 } }
  /**
   * A `collection` was force-created.
   **/
  | { name: 'ForceCreated'; data: { collection: number; owner: AccountId32 } }
  /**
   * A `collection` was destroyed.
   **/
  | { name: 'Destroyed'; data: { collection: number } }
  /**
   * An `item` was issued.
   **/
  | { name: 'Issued'; data: { collection: number; item: number; owner: AccountId32 } }
  /**
   * An `item` was transferred.
   **/
  | { name: 'Transferred'; data: { collection: number; item: number; from: AccountId32; to: AccountId32 } }
  /**
   * An `item` was destroyed.
   **/
  | { name: 'Burned'; data: { collection: number; item: number; owner: AccountId32 } }
  /**
   * Some `item` was frozen.
   **/
  | { name: 'Frozen'; data: { collection: number; item: number } }
  /**
   * Some `item` was thawed.
   **/
  | { name: 'Thawed'; data: { collection: number; item: number } }
  /**
   * Some `collection` was frozen.
   **/
  | { name: 'CollectionFrozen'; data: { collection: number } }
  /**
   * Some `collection` was thawed.
   **/
  | { name: 'CollectionThawed'; data: { collection: number } }
  /**
   * The owner changed.
   **/
  | { name: 'OwnerChanged'; data: { collection: number; newOwner: AccountId32 } }
  /**
   * The management team changed.
   **/
  | { name: 'TeamChanged'; data: { collection: number; issuer: AccountId32; admin: AccountId32; freezer: AccountId32 } }
  /**
   * An `item` of a `collection` has been approved by the `owner` for transfer by
   * a `delegate`.
   **/
  | { name: 'ApprovedTransfer'; data: { collection: number; item: number; owner: AccountId32; delegate: AccountId32 } }
  /**
   * An approval for a `delegate` account to transfer the `item` of an item
   * `collection` was cancelled by its `owner`.
   **/
  | { name: 'ApprovalCancelled'; data: { collection: number; item: number; owner: AccountId32; delegate: AccountId32 } }
  /**
   * A `collection` has had its attributes changed by the `Force` origin.
   **/
  | { name: 'ItemStatusChanged'; data: { collection: number } }
  /**
   * New metadata has been set for a `collection`.
   **/
  | { name: 'CollectionMetadataSet'; data: { collection: number; data: Bytes; isFrozen: boolean } }
  /**
   * Metadata has been cleared for a `collection`.
   **/
  | { name: 'CollectionMetadataCleared'; data: { collection: number } }
  /**
   * New metadata has been set for an item.
   **/
  | { name: 'MetadataSet'; data: { collection: number; item: number; data: Bytes; isFrozen: boolean } }
  /**
   * Metadata has been cleared for an item.
   **/
  | { name: 'MetadataCleared'; data: { collection: number; item: number } }
  /**
   * Metadata has been cleared for an item.
   **/
  | { name: 'Redeposited'; data: { collection: number; successfulItems: Array<number> } }
  /**
   * New attribute metadata has been set for a `collection` or `item`.
   **/
  | { name: 'AttributeSet'; data: { collection: number; maybeItem?: number | undefined; key: Bytes; value: Bytes } }
  /**
   * Attribute metadata has been cleared for a `collection` or `item`.
   **/
  | { name: 'AttributeCleared'; data: { collection: number; maybeItem?: number | undefined; key: Bytes } }
  /**
   * Ownership acceptance has changed for an account.
   **/
  | { name: 'OwnershipAcceptanceChanged'; data: { who: AccountId32; maybeCollection?: number | undefined } }
  /**
   * Max supply has been set for a collection.
   **/
  | { name: 'CollectionMaxSupplySet'; data: { collection: number; maxSupply: number } }
  /**
   * The price was set for the instance.
   **/
  | {
      name: 'ItemPriceSet'
      data: { collection: number; item: number; price: bigint; whitelistedBuyer?: AccountId32 | undefined }
    }
  /**
   * The price for the instance was removed.
   **/
  | { name: 'ItemPriceRemoved'; data: { collection: number; item: number } }
  /**
   * An item was bought.
   **/
  | {
      name: 'ItemBought'
      data: { collection: number; item: number; price: bigint; seller: AccountId32; buyer: AccountId32 }
    }

/**
 * The `Event` enum of this pallet
 **/
export type PalletRmrkCoreEvent =
  | { name: 'CollectionCreated'; data: { issuer: AccountId32; collectionId: number } }
  | {
      name: 'NftMinted'
      data: { owner: RmrkTraitsNftAccountIdOrCollectionNftTuple; collectionId: number; nftId: number }
    }
  | { name: 'NftBurned'; data: { owner: AccountId32; collectionId: number; nftId: number } }
  | { name: 'CollectionDestroyed'; data: { issuer: AccountId32; collectionId: number } }
  | {
      name: 'NftSent'
      data: {
        sender: AccountId32
        recipient: RmrkTraitsNftAccountIdOrCollectionNftTuple
        collectionId: number
        nftId: number
        approvalRequired: boolean
      }
    }
  | {
      name: 'NftAccepted'
      data: {
        sender: AccountId32
        recipient: RmrkTraitsNftAccountIdOrCollectionNftTuple
        collectionId: number
        nftId: number
      }
    }
  | { name: 'NftRejected'; data: { sender: AccountId32; collectionId: number; nftId: number } }
  | { name: 'IssuerChanged'; data: { oldIssuer: AccountId32; newIssuer: AccountId32; collectionId: number } }
  | { name: 'PropertySet'; data: { collectionId: number; maybeNftId?: number | undefined; key: Bytes; value: Bytes } }
  | { name: 'PropertyRemoved'; data: { collectionId: number; maybeNftId?: number | undefined; key: Bytes } }
  | { name: 'PropertiesRemoved'; data: { collectionId: number; maybeNftId?: number | undefined } }
  | { name: 'CollectionLocked'; data: { issuer: AccountId32; collectionId: number } }
  | { name: 'ResourceAdded'; data: { nftId: number; resourceId: number; collectionId: number } }
  | { name: 'ResourceReplaced'; data: { nftId: number; resourceId: number; collectionId: number } }
  | { name: 'ResourceAccepted'; data: { nftId: number; resourceId: number; collectionId: number } }
  | { name: 'ResourceRemoval'; data: { nftId: number; resourceId: number; collectionId: number } }
  | { name: 'ResourceRemovalAccepted'; data: { nftId: number; resourceId: number; collectionId: number } }
  | { name: 'PrioritySet'; data: { collectionId: number; nftId: number } }

export type RmrkTraitsNftAccountIdOrCollectionNftTuple =
  | { type: 'AccountId'; value: AccountId32 }
  | { type: 'CollectionAndNftTuple'; value: [number, number] }

/**
 * The `Event` enum of this pallet
 **/
export type PalletRmrkEquipEvent =
  | { name: 'BaseCreated'; data: { issuer: AccountId32; baseId: number } }
  | { name: 'SlotEquipped'; data: { itemCollection: number; itemNft: number; baseId: number; slotId: number } }
  | { name: 'SlotUnequipped'; data: { itemCollection: number; itemNft: number; baseId: number; slotId: number } }
  | { name: 'EquippablesUpdated'; data: { baseId: number; slotId: number } }
  | { name: 'BaseIssuerChanged'; data: { oldIssuer: AccountId32; newIssuer: AccountId32; baseId: number } }

/**
 * The `Event` enum of this pallet
 **/
export type PalletRmrkMarketEvent =
  /**
   * The price for a token was updated
   **/
  | {
      name: 'TokenPriceUpdated'
      data: { owner: AccountId32; collectionId: number; nftId: number; price?: bigint | undefined }
    }
  /**
   * Token was sold to a new owner
   **/
  | {
      name: 'TokenSold'
      data: { owner: AccountId32; buyer: AccountId32; collectionId: number; nftId: number; price: bigint }
    }
  /**
   * Token listed on Marketplace
   **/
  | { name: 'TokenListed'; data: { owner: AccountId32; collectionId: number; nftId: number; price: bigint } }
  /**
   * Token unlisted on Marketplace
   **/
  | { name: 'TokenUnlisted'; data: { owner: AccountId32; collectionId: number; nftId: number } }
  /**
   * Offer was placed on a token
   **/
  | { name: 'OfferPlaced'; data: { offerer: AccountId32; collectionId: number; nftId: number; price: bigint } }
  /**
   * Offer was withdrawn
   **/
  | { name: 'OfferWithdrawn'; data: { sender: AccountId32; collectionId: number; nftId: number } }
  /**
   * Offer was accepted
   **/
  | { name: 'OfferAccepted'; data: { owner: AccountId32; buyer: AccountId32; collectionId: number; nftId: number } }
  /**
   * Royalty fee paid to royalty owner
   **/
  | {
      name: 'RoyaltyFeePaid'
      data: { sender: AccountId32; royaltyOwner: AccountId32; collectionId: number; nftId: number; amount: bigint }
    }
  /**
   * Market fee paid to marketplace owner
   **/
  | {
      name: 'MarketFeePaid'
      data: { sender: AccountId32; marketplaceOwner: AccountId32; collectionId: number; nftId: number; amount: bigint }
    }

/**
 * The `Event` enum of this pallet
 **/
export type SygmaAccessSegregatorEvent =
  /**
   * Extrinsic access grant to someone
   * args: [pallet_index, extrinsic_name, who]
   **/
  { name: 'AccessGranted'; data: { palletIndex: number; extrinsicName: Bytes; who: AccountId32 } }

/**
 * The `Event` enum of this pallet
 **/
export type SygmaBasicFeehandlerEvent =
  /**
   * Fee set for a specific asset
   * args: [domain, asset, amount]
   **/
  { name: 'FeeSet'; data: { domain: number; asset: StagingXcmV3MultiassetAssetId; amount: bigint } }

/**
 * The `Event` enum of this pallet
 **/
export type SygmaBridgeEvent =
  /**
   * When initial bridge transfer send to dest domain
   * args: [dest_domain_id, resource_id, deposit_nonce, sender, transfer_type,
   * deposit_data, handler_response, ]
   **/
  | {
      name: 'Deposit'
      data: {
        destDomainId: number
        resourceId: FixedBytes<32>
        depositNonce: bigint
        sender: AccountId32
        transferType: SygmaTraitsTransferType
        depositData: Bytes
        handlerResponse: Bytes
      }
    }
  /**
   * When proposal was executed successfully
   **/
  | { name: 'ProposalExecution'; data: { originDomainId: number; depositNonce: bigint; dataHash: FixedBytes<32> } }
  /**
   * When proposal was faild to execute
   **/
  | { name: 'FailedHandlerExecution'; data: { error: Bytes; originDomainId: number; depositNonce: bigint } }
  /**
   * When user is going to retry a bridge transfer
   * args: [deposit_on_block_height, dest_domain_id, sender]
   **/
  | { name: 'Retry'; data: { depositOnBlockHeight: bigint; destDomainId: number; sender: AccountId32 } }
  /**
   * When bridge is paused
   * args: [dest_domain_id]
   **/
  | { name: 'BridgePaused'; data: { destDomainId: number } }
  /**
   * When bridge is unpaused
   * args: [dest_domain_id]
   **/
  | { name: 'BridgeUnpaused'; data: { destDomainId: number } }
  /**
   * When registering a new dest domainID with its corresponding chainID
   **/
  | { name: 'RegisterDestDomain'; data: { sender: AccountId32; domainId: number; chainId: U256 } }
  /**
   * When unregistering a dest domainID with its corresponding chainID
   **/
  | { name: 'UnregisterDestDomain'; data: { sender: AccountId32; domainId: number; chainId: U256 } }
  /**
   * When bridge fee is collected
   **/
  | {
      name: 'FeeCollected'
      data: {
        feePayer: AccountId32
        destDomainId: number
        resourceId: FixedBytes<32>
        feeAmount: bigint
        feeAssetId: StagingXcmV3MultiassetAssetId
      }
    }
  /**
   * When all bridges are paused
   **/
  | { name: 'AllBridgePaused'; data: { sender: AccountId32 } }
  /**
   * When all bridges are unpaused
   **/
  | { name: 'AllBridgeUnpaused'; data: { sender: AccountId32 } }

export type SygmaTraitsTransferType = 'FungibleTransfer' | 'NonFungibleTransfer' | 'GenericTransfer'

/**
 * The `Event` enum of this pallet
 **/
export type SygmaFeeHandlerRouterEvent =
  /**
   * When fee handler was set for a specific (domain, asset) pair
   * args: [dest_domain_id, asset_id, handler_type]
   **/
  {
    name: 'FeeHandlerSet'
    data: { domain: number; asset: StagingXcmV3MultiassetAssetId; handlerType: SygmaFeeHandlerRouterFeeHandlerType }
  }

export type SygmaFeeHandlerRouterFeeHandlerType = 'BasicFeeHandler' | 'PercentageFeeHandler' | 'DynamicFeeHandler'

/**
 * The `Event` enum of this pallet
 **/
export type SubbridgePalletsSygmaWrapperPalletEvent =
  /**
   * Assets sent to EVM chain.
   **/
  {
    name: 'AssetTransfered'
    data: {
      asset: StagingXcmV3MultiassetMultiAsset
      origin: StagingXcmV3MultilocationMultiLocation
      dest: StagingXcmV3MultilocationMultiLocation
    }
  }

/**
 * The `Event` enum of this pallet
 **/
export type SygmaPercentageFeehandlerEvent =
  /**
   * Fee set rate for a specific asset and domain
   * args: [domain, asset, rate_basis_point, fee_lower_bound, fee_upper_bound]
   **/
  {
    name: 'FeeRateSet'
    data: {
      domain: number
      asset: StagingXcmV3MultiassetAssetId
      rateBasisPoint: number
      feeLowerBound: bigint
      feeUpperBound: bigint
    }
  }

/**
 * The `Event` enum of this pallet
 **/
export type PalletIndexEvent =
  /**
   * Worker is set.
   **/
  | { name: 'WorkerAdd'; data: { worker: AccountId32 } }
  /**
   * Worker is set.
   **/
  | { name: 'WorkerRemove'; data: { worker: AccountId32 } }
  /**
   * New task saved.
   **/
  | {
      name: 'NewTask'
      data: {
        /**
         * Record
         **/
        depositInfo: PalletIndexDepositInfo
      }
    }
  /**
   * Task has been claimed.
   **/
  | { name: 'Claimed'; data: { tasks: Array<FixedBytes<32>>; fee: bigint } }

export type PalletIndexDepositInfo = {
  sender: AccountId32
  asset: StagingXcmV3MultiassetAssetId
  amount: bigint
  recipient: Bytes
  task: Bytes
}

export type FrameSystemLastRuntimeUpgradeInfo = { specVersion: number; specName: string }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * See [`Pallet::remark`].
   **/
  | { name: 'Remark'; params: { remark: Bytes } }
  /**
   * See [`Pallet::set_heap_pages`].
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: 'SetCode'; params: { code: Bytes } }
  /**
   * See [`Pallet::set_code_without_checks`].
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: Bytes } }
  /**
   * See [`Pallet::set_storage`].
   **/
  | { name: 'SetStorage'; params: { items: Array<[Bytes, Bytes]> } }
  /**
   * See [`Pallet::kill_storage`].
   **/
  | { name: 'KillStorage'; params: { keys: Array<Bytes> } }
  /**
   * See [`Pallet::kill_prefix`].
   **/
  | { name: 'KillPrefix'; params: { prefix: Bytes; subkeys: number } }
  /**
   * See [`Pallet::remark_with_event`].
   **/
  | { name: 'RemarkWithEvent'; params: { remark: Bytes } }

export type FrameSystemCallLike =
  /**
   * See [`Pallet::remark`].
   **/
  | { name: 'Remark'; params: { remark: BytesLike } }
  /**
   * See [`Pallet::set_heap_pages`].
   **/
  | { name: 'SetHeapPages'; params: { pages: bigint } }
  /**
   * See [`Pallet::set_code`].
   **/
  | { name: 'SetCode'; params: { code: BytesLike } }
  /**
   * See [`Pallet::set_code_without_checks`].
   **/
  | { name: 'SetCodeWithoutChecks'; params: { code: BytesLike } }
  /**
   * See [`Pallet::set_storage`].
   **/
  | { name: 'SetStorage'; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * See [`Pallet::kill_storage`].
   **/
  | { name: 'KillStorage'; params: { keys: Array<BytesLike> } }
  /**
   * See [`Pallet::kill_prefix`].
   **/
  | { name: 'KillPrefix'; params: { prefix: BytesLike; subkeys: number } }
  /**
   * See [`Pallet::remark_with_event`].
   **/
  | { name: 'RemarkWithEvent'; params: { remark: BytesLike } }

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight
  maxBlock: SpWeightsWeightV2Weight
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass
}

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass
  operational: FrameSystemLimitsWeightsPerClass
  mandatory: FrameSystemLimitsWeightsPerClass
}

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined
  maxTotal?: SpWeightsWeightV2Weight | undefined
  reserved?: SpWeightsWeightV2Weight | undefined
}

export type FrameSystemLimitsBlockLength = { max: FrameSupportDispatchPerDispatchClassU32 }

export type FrameSupportDispatchPerDispatchClassU32 = { normal: number; operational: number; mandatory: number }

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint }

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | 'InvalidSpecName'
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | 'SpecVersionNeedsToIncrease'
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | 'FailedToExtractRuntimeVersion'
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | 'NonDefaultComposite'
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | 'NonZeroRefCount'
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | 'CallFiltered'

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * See [`Pallet::set`].
   **/
  { name: 'Set'; params: { now: bigint } }

export type PalletTimestampCallLike =
  /**
   * See [`Pallet::set`].
   **/
  { name: 'Set'; params: { now: bigint } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * See [`Pallet::batch`].
   **/
  | { name: 'Batch'; params: { calls: Array<PhalaParachainRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::as_derivative`].
   **/
  | { name: 'AsDerivative'; params: { index: number; call: PhalaParachainRuntimeRuntimeCall } }
  /**
   * See [`Pallet::batch_all`].
   **/
  | { name: 'BatchAll'; params: { calls: Array<PhalaParachainRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::dispatch_as`].
   **/
  | {
      name: 'DispatchAs'
      params: { asOrigin: PhalaParachainRuntimeOriginCaller; call: PhalaParachainRuntimeRuntimeCall }
    }
  /**
   * See [`Pallet::force_batch`].
   **/
  | { name: 'ForceBatch'; params: { calls: Array<PhalaParachainRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::with_weight`].
   **/
  | { name: 'WithWeight'; params: { call: PhalaParachainRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } }

export type PalletUtilityCallLike =
  /**
   * See [`Pallet::batch`].
   **/
  | { name: 'Batch'; params: { calls: Array<PhalaParachainRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::as_derivative`].
   **/
  | { name: 'AsDerivative'; params: { index: number; call: PhalaParachainRuntimeRuntimeCallLike } }
  /**
   * See [`Pallet::batch_all`].
   **/
  | { name: 'BatchAll'; params: { calls: Array<PhalaParachainRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::dispatch_as`].
   **/
  | {
      name: 'DispatchAs'
      params: { asOrigin: PhalaParachainRuntimeOriginCaller; call: PhalaParachainRuntimeRuntimeCallLike }
    }
  /**
   * See [`Pallet::force_batch`].
   **/
  | { name: 'ForceBatch'; params: { calls: Array<PhalaParachainRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::with_weight`].
   **/
  | { name: 'WithWeight'; params: { call: PhalaParachainRuntimeRuntimeCallLike; weight: SpWeightsWeightV2Weight } }

export type PhalaParachainRuntimeRuntimeCall =
  | { pallet: 'System'; palletCall: FrameSystemCall }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCall }
  | { pallet: 'Utility'; palletCall: PalletUtilityCall }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCall }
  | { pallet: 'Proxy'; palletCall: PalletProxyCall }
  | { pallet: 'Vesting'; palletCall: PalletVestingCall }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCall }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCall }
  | { pallet: 'ParachainSystem'; palletCall: CumulusPalletParachainSystemCall }
  | { pallet: 'XcmpQueue'; palletCall: CumulusPalletXcmpQueueCall }
  | { pallet: 'DmpQueue'; palletCall: CumulusPalletDmpQueueCall }
  | { pallet: 'PolkadotXcm'; palletCall: PalletXcmCall }
  | { pallet: 'Balances'; palletCall: PalletBalancesCall }
  | { pallet: 'Assets'; palletCall: PalletAssetsCall }
  | { pallet: 'CollatorSelection'; palletCall: PalletCollatorSelectionCall }
  | { pallet: 'Session'; palletCall: PalletSessionCall }
  | { pallet: 'Identity'; palletCall: PalletIdentityCall }
  | { pallet: 'Democracy'; palletCall: PalletDemocracyCall }
  | { pallet: 'Council'; palletCall: PalletCollectiveCall }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCall }
  | { pallet: 'Bounties'; palletCall: PalletBountiesCall }
  | { pallet: 'Lottery'; palletCall: PalletLotteryCall }
  | { pallet: 'TechnicalCommittee'; palletCall: PalletCollectiveCall }
  | { pallet: 'TechnicalMembership'; palletCall: PalletMembershipCall }
  | { pallet: 'PhragmenElection'; palletCall: PalletElectionsPhragmenCall }
  | { pallet: 'Tips'; palletCall: PalletTipsCall }
  | { pallet: 'ChildBounties'; palletCall: PalletChildBountiesCall }
  | { pallet: 'ChainBridge'; palletCall: SubbridgePalletsChainbridgePalletCall }
  | { pallet: 'XTransfer'; palletCall: SubbridgePalletsXtransferPalletCall }
  | { pallet: 'AssetsRegistry'; palletCall: AssetsRegistryCall }
  | { pallet: 'PhalaMq'; palletCall: PhalaPalletsMqPalletCall }
  | { pallet: 'PhalaRegistry'; palletCall: PhalaPalletsRegistryPalletCall }
  | { pallet: 'PhalaComputation'; palletCall: PhalaPalletsComputeComputationPalletCall }
  | { pallet: 'PhalaStakePoolv2'; palletCall: PhalaPalletsComputeStakePoolV2PalletCall }
  | { pallet: 'PhalaVault'; palletCall: PhalaPalletsComputeVaultPalletCall }
  | { pallet: 'PhalaWrappedBalances'; palletCall: PhalaPalletsComputeWrappedBalancesPalletCall }
  | { pallet: 'PhalaBasePool'; palletCall: PhalaPalletsComputeBasePoolPalletCall }
  | { pallet: 'PhalaPhatContracts'; palletCall: PhalaPalletsPhatPalletCall }
  | { pallet: 'PhalaPhatTokenomic'; palletCall: PhalaPalletsPhatTokenomicPalletCall }
  | { pallet: 'Uniques'; palletCall: PalletUniquesCall }
  | { pallet: 'RmrkCore'; palletCall: PalletRmrkCoreCall }
  | { pallet: 'RmrkEquip'; palletCall: PalletRmrkEquipCall }
  | { pallet: 'RmrkMarket'; palletCall: PalletRmrkMarketCall }
  | { pallet: 'SygmaAccessSegregator'; palletCall: SygmaAccessSegregatorCall }
  | { pallet: 'SygmaBasicFeeHandler'; palletCall: SygmaBasicFeehandlerCall }
  | { pallet: 'SygmaBridge'; palletCall: SygmaBridgeCall }
  | { pallet: 'SygmaFeeHandlerRouter'; palletCall: SygmaFeeHandlerRouterCall }
  | { pallet: 'SygmaPercentageFeeHandler'; palletCall: SygmaPercentageFeehandlerCall }
  | { pallet: 'PalletIndex'; palletCall: PalletIndexCall }

export type PhalaParachainRuntimeRuntimeCallLike =
  | { pallet: 'System'; palletCall: FrameSystemCallLike }
  | { pallet: 'Timestamp'; palletCall: PalletTimestampCallLike }
  | { pallet: 'Utility'; palletCall: PalletUtilityCallLike }
  | { pallet: 'Multisig'; palletCall: PalletMultisigCallLike }
  | { pallet: 'Proxy'; palletCall: PalletProxyCallLike }
  | { pallet: 'Vesting'; palletCall: PalletVestingCallLike }
  | { pallet: 'Scheduler'; palletCall: PalletSchedulerCallLike }
  | { pallet: 'Preimage'; palletCall: PalletPreimageCallLike }
  | { pallet: 'ParachainSystem'; palletCall: CumulusPalletParachainSystemCallLike }
  | { pallet: 'XcmpQueue'; palletCall: CumulusPalletXcmpQueueCallLike }
  | { pallet: 'DmpQueue'; palletCall: CumulusPalletDmpQueueCallLike }
  | { pallet: 'PolkadotXcm'; palletCall: PalletXcmCallLike }
  | { pallet: 'Balances'; palletCall: PalletBalancesCallLike }
  | { pallet: 'Assets'; palletCall: PalletAssetsCallLike }
  | { pallet: 'CollatorSelection'; palletCall: PalletCollatorSelectionCallLike }
  | { pallet: 'Session'; palletCall: PalletSessionCallLike }
  | { pallet: 'Identity'; palletCall: PalletIdentityCallLike }
  | { pallet: 'Democracy'; palletCall: PalletDemocracyCallLike }
  | { pallet: 'Council'; palletCall: PalletCollectiveCallLike }
  | { pallet: 'Treasury'; palletCall: PalletTreasuryCallLike }
  | { pallet: 'Bounties'; palletCall: PalletBountiesCallLike }
  | { pallet: 'Lottery'; palletCall: PalletLotteryCallLike }
  | { pallet: 'TechnicalCommittee'; palletCall: PalletCollectiveCallLike }
  | { pallet: 'TechnicalMembership'; palletCall: PalletMembershipCallLike }
  | { pallet: 'PhragmenElection'; palletCall: PalletElectionsPhragmenCallLike }
  | { pallet: 'Tips'; palletCall: PalletTipsCallLike }
  | { pallet: 'ChildBounties'; palletCall: PalletChildBountiesCallLike }
  | { pallet: 'ChainBridge'; palletCall: SubbridgePalletsChainbridgePalletCallLike }
  | { pallet: 'XTransfer'; palletCall: SubbridgePalletsXtransferPalletCallLike }
  | { pallet: 'AssetsRegistry'; palletCall: AssetsRegistryCallLike }
  | { pallet: 'PhalaMq'; palletCall: PhalaPalletsMqPalletCallLike }
  | { pallet: 'PhalaRegistry'; palletCall: PhalaPalletsRegistryPalletCallLike }
  | { pallet: 'PhalaComputation'; palletCall: PhalaPalletsComputeComputationPalletCallLike }
  | { pallet: 'PhalaStakePoolv2'; palletCall: PhalaPalletsComputeStakePoolV2PalletCallLike }
  | { pallet: 'PhalaVault'; palletCall: PhalaPalletsComputeVaultPalletCallLike }
  | { pallet: 'PhalaWrappedBalances'; palletCall: PhalaPalletsComputeWrappedBalancesPalletCallLike }
  | { pallet: 'PhalaBasePool'; palletCall: PhalaPalletsComputeBasePoolPalletCallLike }
  | { pallet: 'PhalaPhatContracts'; palletCall: PhalaPalletsPhatPalletCallLike }
  | { pallet: 'PhalaPhatTokenomic'; palletCall: PhalaPalletsPhatTokenomicPalletCallLike }
  | { pallet: 'Uniques'; palletCall: PalletUniquesCallLike }
  | { pallet: 'RmrkCore'; palletCall: PalletRmrkCoreCallLike }
  | { pallet: 'RmrkEquip'; palletCall: PalletRmrkEquipCallLike }
  | { pallet: 'RmrkMarket'; palletCall: PalletRmrkMarketCallLike }
  | { pallet: 'SygmaAccessSegregator'; palletCall: SygmaAccessSegregatorCallLike }
  | { pallet: 'SygmaBasicFeeHandler'; palletCall: SygmaBasicFeehandlerCallLike }
  | { pallet: 'SygmaBridge'; palletCall: SygmaBridgeCallLike }
  | { pallet: 'SygmaFeeHandlerRouter'; palletCall: SygmaFeeHandlerRouterCallLike }
  | { pallet: 'SygmaPercentageFeeHandler'; palletCall: SygmaPercentageFeehandlerCallLike }
  | { pallet: 'PalletIndex'; palletCall: PalletIndexCallLike }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * See [`Pallet::as_multi_threshold_1`].
   **/
  | {
      name: 'AsMultiThreshold1'
      params: { otherSignatories: Array<AccountId32>; call: PhalaParachainRuntimeRuntimeCall }
    }
  /**
   * See [`Pallet::as_multi`].
   **/
  | {
      name: 'AsMulti'
      params: {
        threshold: number
        otherSignatories: Array<AccountId32>
        maybeTimepoint?: PalletMultisigTimepoint | undefined
        call: PhalaParachainRuntimeRuntimeCall
        maxWeight: SpWeightsWeightV2Weight
      }
    }
  /**
   * See [`Pallet::approve_as_multi`].
   **/
  | {
      name: 'ApproveAsMulti'
      params: {
        threshold: number
        otherSignatories: Array<AccountId32>
        maybeTimepoint?: PalletMultisigTimepoint | undefined
        callHash: FixedBytes<32>
        maxWeight: SpWeightsWeightV2Weight
      }
    }
  /**
   * See [`Pallet::cancel_as_multi`].
   **/
  | {
      name: 'CancelAsMulti'
      params: {
        threshold: number
        otherSignatories: Array<AccountId32>
        timepoint: PalletMultisigTimepoint
        callHash: FixedBytes<32>
      }
    }

export type PalletMultisigCallLike =
  /**
   * See [`Pallet::as_multi_threshold_1`].
   **/
  | {
      name: 'AsMultiThreshold1'
      params: { otherSignatories: Array<AccountId32Like>; call: PhalaParachainRuntimeRuntimeCallLike }
    }
  /**
   * See [`Pallet::as_multi`].
   **/
  | {
      name: 'AsMulti'
      params: {
        threshold: number
        otherSignatories: Array<AccountId32Like>
        maybeTimepoint?: PalletMultisigTimepoint | undefined
        call: PhalaParachainRuntimeRuntimeCallLike
        maxWeight: SpWeightsWeightV2Weight
      }
    }
  /**
   * See [`Pallet::approve_as_multi`].
   **/
  | {
      name: 'ApproveAsMulti'
      params: {
        threshold: number
        otherSignatories: Array<AccountId32Like>
        maybeTimepoint?: PalletMultisigTimepoint | undefined
        callHash: FixedBytes<32>
        maxWeight: SpWeightsWeightV2Weight
      }
    }
  /**
   * See [`Pallet::cancel_as_multi`].
   **/
  | {
      name: 'CancelAsMulti'
      params: {
        threshold: number
        otherSignatories: Array<AccountId32Like>
        timepoint: PalletMultisigTimepoint
        callHash: FixedBytes<32>
      }
    }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  /**
   * See [`Pallet::proxy`].
   **/
  | {
      name: 'Proxy'
      params: {
        real: MultiAddress
        forceProxyType?: PhalaParachainRuntimeProxyType | undefined
        call: PhalaParachainRuntimeRuntimeCall
      }
    }
  /**
   * See [`Pallet::add_proxy`].
   **/
  | { name: 'AddProxy'; params: { delegate: MultiAddress; proxyType: PhalaParachainRuntimeProxyType; delay: number } }
  /**
   * See [`Pallet::remove_proxy`].
   **/
  | {
      name: 'RemoveProxy'
      params: { delegate: MultiAddress; proxyType: PhalaParachainRuntimeProxyType; delay: number }
    }
  /**
   * See [`Pallet::remove_proxies`].
   **/
  | { name: 'RemoveProxies' }
  /**
   * See [`Pallet::create_pure`].
   **/
  | { name: 'CreatePure'; params: { proxyType: PhalaParachainRuntimeProxyType; delay: number; index: number } }
  /**
   * See [`Pallet::kill_pure`].
   **/
  | {
      name: 'KillPure'
      params: {
        spawner: MultiAddress
        proxyType: PhalaParachainRuntimeProxyType
        index: number
        height: number
        extIndex: number
      }
    }
  /**
   * See [`Pallet::announce`].
   **/
  | { name: 'Announce'; params: { real: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::remove_announcement`].
   **/
  | { name: 'RemoveAnnouncement'; params: { real: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::reject_announcement`].
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: MultiAddress; callHash: H256 } }
  /**
   * See [`Pallet::proxy_announced`].
   **/
  | {
      name: 'ProxyAnnounced'
      params: {
        delegate: MultiAddress
        real: MultiAddress
        forceProxyType?: PhalaParachainRuntimeProxyType | undefined
        call: PhalaParachainRuntimeRuntimeCall
      }
    }

export type PalletProxyCallLike =
  /**
   * See [`Pallet::proxy`].
   **/
  | {
      name: 'Proxy'
      params: {
        real: MultiAddressLike
        forceProxyType?: PhalaParachainRuntimeProxyType | undefined
        call: PhalaParachainRuntimeRuntimeCallLike
      }
    }
  /**
   * See [`Pallet::add_proxy`].
   **/
  | {
      name: 'AddProxy'
      params: { delegate: MultiAddressLike; proxyType: PhalaParachainRuntimeProxyType; delay: number }
    }
  /**
   * See [`Pallet::remove_proxy`].
   **/
  | {
      name: 'RemoveProxy'
      params: { delegate: MultiAddressLike; proxyType: PhalaParachainRuntimeProxyType; delay: number }
    }
  /**
   * See [`Pallet::remove_proxies`].
   **/
  | { name: 'RemoveProxies' }
  /**
   * See [`Pallet::create_pure`].
   **/
  | { name: 'CreatePure'; params: { proxyType: PhalaParachainRuntimeProxyType; delay: number; index: number } }
  /**
   * See [`Pallet::kill_pure`].
   **/
  | {
      name: 'KillPure'
      params: {
        spawner: MultiAddressLike
        proxyType: PhalaParachainRuntimeProxyType
        index: number
        height: number
        extIndex: number
      }
    }
  /**
   * See [`Pallet::announce`].
   **/
  | { name: 'Announce'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * See [`Pallet::remove_announcement`].
   **/
  | { name: 'RemoveAnnouncement'; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * See [`Pallet::reject_announcement`].
   **/
  | { name: 'RejectAnnouncement'; params: { delegate: MultiAddressLike; callHash: H256 } }
  /**
   * See [`Pallet::proxy_announced`].
   **/
  | {
      name: 'ProxyAnnounced'
      params: {
        delegate: MultiAddressLike
        real: MultiAddressLike
        forceProxyType?: PhalaParachainRuntimeProxyType | undefined
        call: PhalaParachainRuntimeRuntimeCallLike
      }
    }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletVestingCall =
  /**
   * See [`Pallet::vest`].
   **/
  | { name: 'Vest' }
  /**
   * See [`Pallet::vest_other`].
   **/
  | { name: 'VestOther'; params: { target: MultiAddress } }
  /**
   * See [`Pallet::vested_transfer`].
   **/
  | { name: 'VestedTransfer'; params: { target: MultiAddress; schedule: PalletVestingVestingInfo } }
  /**
   * See [`Pallet::force_vested_transfer`].
   **/
  | {
      name: 'ForceVestedTransfer'
      params: { source: MultiAddress; target: MultiAddress; schedule: PalletVestingVestingInfo }
    }
  /**
   * See [`Pallet::merge_schedules`].
   **/
  | { name: 'MergeSchedules'; params: { schedule1Index: number; schedule2Index: number } }

export type PalletVestingCallLike =
  /**
   * See [`Pallet::vest`].
   **/
  | { name: 'Vest' }
  /**
   * See [`Pallet::vest_other`].
   **/
  | { name: 'VestOther'; params: { target: MultiAddressLike } }
  /**
   * See [`Pallet::vested_transfer`].
   **/
  | { name: 'VestedTransfer'; params: { target: MultiAddressLike; schedule: PalletVestingVestingInfo } }
  /**
   * See [`Pallet::force_vested_transfer`].
   **/
  | {
      name: 'ForceVestedTransfer'
      params: { source: MultiAddressLike; target: MultiAddressLike; schedule: PalletVestingVestingInfo }
    }
  /**
   * See [`Pallet::merge_schedules`].
   **/
  | { name: 'MergeSchedules'; params: { schedule1Index: number; schedule2Index: number } }

export type PalletVestingVestingInfo = { locked: bigint; perBlock: bigint; startingBlock: number }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSchedulerCall =
  /**
   * See [`Pallet::schedule`].
   **/
  | {
      name: 'Schedule'
      params: {
        when: number
        maybePeriodic?: [number, number] | undefined
        priority: number
        call: PhalaParachainRuntimeRuntimeCall
      }
    }
  /**
   * See [`Pallet::cancel`].
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * See [`Pallet::schedule_named`].
   **/
  | {
      name: 'ScheduleNamed'
      params: {
        id: FixedBytes<32>
        when: number
        maybePeriodic?: [number, number] | undefined
        priority: number
        call: PhalaParachainRuntimeRuntimeCall
      }
    }
  /**
   * See [`Pallet::cancel_named`].
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * See [`Pallet::schedule_after`].
   **/
  | {
      name: 'ScheduleAfter'
      params: {
        after: number
        maybePeriodic?: [number, number] | undefined
        priority: number
        call: PhalaParachainRuntimeRuntimeCall
      }
    }
  /**
   * See [`Pallet::schedule_named_after`].
   **/
  | {
      name: 'ScheduleNamedAfter'
      params: {
        id: FixedBytes<32>
        after: number
        maybePeriodic?: [number, number] | undefined
        priority: number
        call: PhalaParachainRuntimeRuntimeCall
      }
    }

export type PalletSchedulerCallLike =
  /**
   * See [`Pallet::schedule`].
   **/
  | {
      name: 'Schedule'
      params: {
        when: number
        maybePeriodic?: [number, number] | undefined
        priority: number
        call: PhalaParachainRuntimeRuntimeCallLike
      }
    }
  /**
   * See [`Pallet::cancel`].
   **/
  | { name: 'Cancel'; params: { when: number; index: number } }
  /**
   * See [`Pallet::schedule_named`].
   **/
  | {
      name: 'ScheduleNamed'
      params: {
        id: FixedBytes<32>
        when: number
        maybePeriodic?: [number, number] | undefined
        priority: number
        call: PhalaParachainRuntimeRuntimeCallLike
      }
    }
  /**
   * See [`Pallet::cancel_named`].
   **/
  | { name: 'CancelNamed'; params: { id: FixedBytes<32> } }
  /**
   * See [`Pallet::schedule_after`].
   **/
  | {
      name: 'ScheduleAfter'
      params: {
        after: number
        maybePeriodic?: [number, number] | undefined
        priority: number
        call: PhalaParachainRuntimeRuntimeCallLike
      }
    }
  /**
   * See [`Pallet::schedule_named_after`].
   **/
  | {
      name: 'ScheduleNamedAfter'
      params: {
        id: FixedBytes<32>
        after: number
        maybePeriodic?: [number, number] | undefined
        priority: number
        call: PhalaParachainRuntimeRuntimeCallLike
      }
    }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletPreimageCall =
  /**
   * See [`Pallet::note_preimage`].
   **/
  | { name: 'NotePreimage'; params: { bytes: Bytes } }
  /**
   * See [`Pallet::unnote_preimage`].
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * See [`Pallet::request_preimage`].
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * See [`Pallet::unrequest_preimage`].
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * See [`Pallet::ensure_updated`].
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } }

export type PalletPreimageCallLike =
  /**
   * See [`Pallet::note_preimage`].
   **/
  | { name: 'NotePreimage'; params: { bytes: BytesLike } }
  /**
   * See [`Pallet::unnote_preimage`].
   **/
  | { name: 'UnnotePreimage'; params: { hash: H256 } }
  /**
   * See [`Pallet::request_preimage`].
   **/
  | { name: 'RequestPreimage'; params: { hash: H256 } }
  /**
   * See [`Pallet::unrequest_preimage`].
   **/
  | { name: 'UnrequestPreimage'; params: { hash: H256 } }
  /**
   * See [`Pallet::ensure_updated`].
   **/
  | { name: 'EnsureUpdated'; params: { hashes: Array<H256> } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletParachainSystemCall =
  /**
   * See [`Pallet::set_validation_data`].
   **/
  | { name: 'SetValidationData'; params: { data: CumulusPrimitivesParachainInherentParachainInherentData } }
  /**
   * See [`Pallet::sudo_send_upward_message`].
   **/
  | { name: 'SudoSendUpwardMessage'; params: { message: Bytes } }
  /**
   * See [`Pallet::authorize_upgrade`].
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256; checkVersion: boolean } }
  /**
   * See [`Pallet::enact_authorized_upgrade`].
   **/
  | { name: 'EnactAuthorizedUpgrade'; params: { code: Bytes } }

export type CumulusPalletParachainSystemCallLike =
  /**
   * See [`Pallet::set_validation_data`].
   **/
  | { name: 'SetValidationData'; params: { data: CumulusPrimitivesParachainInherentParachainInherentData } }
  /**
   * See [`Pallet::sudo_send_upward_message`].
   **/
  | { name: 'SudoSendUpwardMessage'; params: { message: BytesLike } }
  /**
   * See [`Pallet::authorize_upgrade`].
   **/
  | { name: 'AuthorizeUpgrade'; params: { codeHash: H256; checkVersion: boolean } }
  /**
   * See [`Pallet::enact_authorized_upgrade`].
   **/
  | { name: 'EnactAuthorizedUpgrade'; params: { code: BytesLike } }

export type CumulusPrimitivesParachainInherentParachainInherentData = {
  validationData: PolkadotPrimitivesV6PersistedValidationData
  relayChainState: SpTrieStorageProof
  downwardMessages: Array<PolkadotCorePrimitivesInboundDownwardMessage>
  horizontalMessages: Array<[PolkadotParachainPrimitivesPrimitivesId, Array<PolkadotCorePrimitivesInboundHrmpMessage>]>
}

export type PolkadotPrimitivesV6PersistedValidationData = {
  parentHead: PolkadotParachainPrimitivesPrimitivesHeadData
  relayParentNumber: number
  relayParentStorageRoot: H256
  maxPovSize: number
}

export type PolkadotParachainPrimitivesPrimitivesHeadData = Bytes

export type SpTrieStorageProof = { trieNodes: Array<Bytes> }

export type PolkadotCorePrimitivesInboundDownwardMessage = { sentAt: number; msg: Bytes }

export type PolkadotCorePrimitivesInboundHrmpMessage = { sentAt: number; data: Bytes }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletXcmpQueueCall =
  /**
   * See [`Pallet::service_overweight`].
   **/
  | { name: 'ServiceOverweight'; params: { index: bigint; weightLimit: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::suspend_xcm_execution`].
   **/
  | { name: 'SuspendXcmExecution' }
  /**
   * See [`Pallet::resume_xcm_execution`].
   **/
  | { name: 'ResumeXcmExecution' }
  /**
   * See [`Pallet::update_suspend_threshold`].
   **/
  | { name: 'UpdateSuspendThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_drop_threshold`].
   **/
  | { name: 'UpdateDropThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_resume_threshold`].
   **/
  | { name: 'UpdateResumeThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_threshold_weight`].
   **/
  | { name: 'UpdateThresholdWeight'; params: { new: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::update_weight_restrict_decay`].
   **/
  | { name: 'UpdateWeightRestrictDecay'; params: { new: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::update_xcmp_max_individual_weight`].
   **/
  | { name: 'UpdateXcmpMaxIndividualWeight'; params: { new: SpWeightsWeightV2Weight } }

export type CumulusPalletXcmpQueueCallLike =
  /**
   * See [`Pallet::service_overweight`].
   **/
  | { name: 'ServiceOverweight'; params: { index: bigint; weightLimit: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::suspend_xcm_execution`].
   **/
  | { name: 'SuspendXcmExecution' }
  /**
   * See [`Pallet::resume_xcm_execution`].
   **/
  | { name: 'ResumeXcmExecution' }
  /**
   * See [`Pallet::update_suspend_threshold`].
   **/
  | { name: 'UpdateSuspendThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_drop_threshold`].
   **/
  | { name: 'UpdateDropThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_resume_threshold`].
   **/
  | { name: 'UpdateResumeThreshold'; params: { new: number } }
  /**
   * See [`Pallet::update_threshold_weight`].
   **/
  | { name: 'UpdateThresholdWeight'; params: { new: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::update_weight_restrict_decay`].
   **/
  | { name: 'UpdateWeightRestrictDecay'; params: { new: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::update_xcmp_max_individual_weight`].
   **/
  | { name: 'UpdateXcmpMaxIndividualWeight'; params: { new: SpWeightsWeightV2Weight } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletDmpQueueCall =
  /**
   * See [`Pallet::service_overweight`].
   **/
  { name: 'ServiceOverweight'; params: { index: bigint; weightLimit: SpWeightsWeightV2Weight } }

export type CumulusPalletDmpQueueCallLike =
  /**
   * See [`Pallet::service_overweight`].
   **/
  { name: 'ServiceOverweight'; params: { index: bigint; weightLimit: SpWeightsWeightV2Weight } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXcmCall =
  /**
   * See [`Pallet::send`].
   **/
  | { name: 'Send'; params: { dest: StagingXcmVersionedMultiLocation; message: StagingXcmVersionedXcm } }
  /**
   * See [`Pallet::teleport_assets`].
   **/
  | {
      name: 'TeleportAssets'
      params: {
        dest: StagingXcmVersionedMultiLocation
        beneficiary: StagingXcmVersionedMultiLocation
        assets: StagingXcmVersionedMultiAssets
        feeAssetItem: number
      }
    }
  /**
   * See [`Pallet::reserve_transfer_assets`].
   **/
  | {
      name: 'ReserveTransferAssets'
      params: {
        dest: StagingXcmVersionedMultiLocation
        beneficiary: StagingXcmVersionedMultiLocation
        assets: StagingXcmVersionedMultiAssets
        feeAssetItem: number
      }
    }
  /**
   * See [`Pallet::execute`].
   **/
  | { name: 'Execute'; params: { message: StagingXcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::force_xcm_version`].
   **/
  | { name: 'ForceXcmVersion'; params: { location: StagingXcmV3MultilocationMultiLocation; version: number } }
  /**
   * See [`Pallet::force_default_xcm_version`].
   **/
  | { name: 'ForceDefaultXcmVersion'; params: { maybeXcmVersion?: number | undefined } }
  /**
   * See [`Pallet::force_subscribe_version_notify`].
   **/
  | { name: 'ForceSubscribeVersionNotify'; params: { location: StagingXcmVersionedMultiLocation } }
  /**
   * See [`Pallet::force_unsubscribe_version_notify`].
   **/
  | { name: 'ForceUnsubscribeVersionNotify'; params: { location: StagingXcmVersionedMultiLocation } }
  /**
   * See [`Pallet::limited_reserve_transfer_assets`].
   **/
  | {
      name: 'LimitedReserveTransferAssets'
      params: {
        dest: StagingXcmVersionedMultiLocation
        beneficiary: StagingXcmVersionedMultiLocation
        assets: StagingXcmVersionedMultiAssets
        feeAssetItem: number
        weightLimit: StagingXcmV3WeightLimit
      }
    }
  /**
   * See [`Pallet::limited_teleport_assets`].
   **/
  | {
      name: 'LimitedTeleportAssets'
      params: {
        dest: StagingXcmVersionedMultiLocation
        beneficiary: StagingXcmVersionedMultiLocation
        assets: StagingXcmVersionedMultiAssets
        feeAssetItem: number
        weightLimit: StagingXcmV3WeightLimit
      }
    }
  /**
   * See [`Pallet::force_suspension`].
   **/
  | { name: 'ForceSuspension'; params: { suspended: boolean } }

export type PalletXcmCallLike =
  /**
   * See [`Pallet::send`].
   **/
  | { name: 'Send'; params: { dest: StagingXcmVersionedMultiLocation; message: StagingXcmVersionedXcm } }
  /**
   * See [`Pallet::teleport_assets`].
   **/
  | {
      name: 'TeleportAssets'
      params: {
        dest: StagingXcmVersionedMultiLocation
        beneficiary: StagingXcmVersionedMultiLocation
        assets: StagingXcmVersionedMultiAssets
        feeAssetItem: number
      }
    }
  /**
   * See [`Pallet::reserve_transfer_assets`].
   **/
  | {
      name: 'ReserveTransferAssets'
      params: {
        dest: StagingXcmVersionedMultiLocation
        beneficiary: StagingXcmVersionedMultiLocation
        assets: StagingXcmVersionedMultiAssets
        feeAssetItem: number
      }
    }
  /**
   * See [`Pallet::execute`].
   **/
  | { name: 'Execute'; params: { message: StagingXcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight } }
  /**
   * See [`Pallet::force_xcm_version`].
   **/
  | { name: 'ForceXcmVersion'; params: { location: StagingXcmV3MultilocationMultiLocation; version: number } }
  /**
   * See [`Pallet::force_default_xcm_version`].
   **/
  | { name: 'ForceDefaultXcmVersion'; params: { maybeXcmVersion?: number | undefined } }
  /**
   * See [`Pallet::force_subscribe_version_notify`].
   **/
  | { name: 'ForceSubscribeVersionNotify'; params: { location: StagingXcmVersionedMultiLocation } }
  /**
   * See [`Pallet::force_unsubscribe_version_notify`].
   **/
  | { name: 'ForceUnsubscribeVersionNotify'; params: { location: StagingXcmVersionedMultiLocation } }
  /**
   * See [`Pallet::limited_reserve_transfer_assets`].
   **/
  | {
      name: 'LimitedReserveTransferAssets'
      params: {
        dest: StagingXcmVersionedMultiLocation
        beneficiary: StagingXcmVersionedMultiLocation
        assets: StagingXcmVersionedMultiAssets
        feeAssetItem: number
        weightLimit: StagingXcmV3WeightLimit
      }
    }
  /**
   * See [`Pallet::limited_teleport_assets`].
   **/
  | {
      name: 'LimitedTeleportAssets'
      params: {
        dest: StagingXcmVersionedMultiLocation
        beneficiary: StagingXcmVersionedMultiLocation
        assets: StagingXcmVersionedMultiAssets
        feeAssetItem: number
        weightLimit: StagingXcmV3WeightLimit
      }
    }
  /**
   * See [`Pallet::force_suspension`].
   **/
  | { name: 'ForceSuspension'; params: { suspended: boolean } }

export type StagingXcmVersionedXcm = { type: 'V2'; value: StagingXcmV2Xcm } | { type: 'V3'; value: StagingXcmV3Xcm }

export type StagingXcmV2Xcm = Array<StagingXcmV2Instruction>

export type StagingXcmV2Instruction =
  | { type: 'WithdrawAsset'; value: StagingXcmV2MultiassetMultiAssets }
  | { type: 'ReserveAssetDeposited'; value: StagingXcmV2MultiassetMultiAssets }
  | { type: 'ReceiveTeleportedAsset'; value: StagingXcmV2MultiassetMultiAssets }
  | { type: 'QueryResponse'; value: { queryId: bigint; response: StagingXcmV2Response; maxWeight: bigint } }
  | {
      type: 'TransferAsset'
      value: { assets: StagingXcmV2MultiassetMultiAssets; beneficiary: StagingXcmV2MultilocationMultiLocation }
    }
  | {
      type: 'TransferReserveAsset'
      value: {
        assets: StagingXcmV2MultiassetMultiAssets
        dest: StagingXcmV2MultilocationMultiLocation
        xcm: StagingXcmV2Xcm
      }
    }
  | {
      type: 'Transact'
      value: { originType: StagingXcmV2OriginKind; requireWeightAtMost: bigint; call: StagingXcmDoubleEncoded }
    }
  | { type: 'HrmpNewChannelOpenRequest'; value: { sender: number; maxMessageSize: number; maxCapacity: number } }
  | { type: 'HrmpChannelAccepted'; value: { recipient: number } }
  | { type: 'HrmpChannelClosing'; value: { initiator: number; sender: number; recipient: number } }
  | { type: 'ClearOrigin' }
  | { type: 'DescendOrigin'; value: StagingXcmV2MultilocationJunctions }
  | {
      type: 'ReportError'
      value: { queryId: bigint; dest: StagingXcmV2MultilocationMultiLocation; maxResponseWeight: bigint }
    }
  | {
      type: 'DepositAsset'
      value: {
        assets: StagingXcmV2MultiassetMultiAssetFilter
        maxAssets: number
        beneficiary: StagingXcmV2MultilocationMultiLocation
      }
    }
  | {
      type: 'DepositReserveAsset'
      value: {
        assets: StagingXcmV2MultiassetMultiAssetFilter
        maxAssets: number
        dest: StagingXcmV2MultilocationMultiLocation
        xcm: StagingXcmV2Xcm
      }
    }
  | {
      type: 'ExchangeAsset'
      value: { give: StagingXcmV2MultiassetMultiAssetFilter; receive: StagingXcmV2MultiassetMultiAssets }
    }
  | {
      type: 'InitiateReserveWithdraw'
      value: {
        assets: StagingXcmV2MultiassetMultiAssetFilter
        reserve: StagingXcmV2MultilocationMultiLocation
        xcm: StagingXcmV2Xcm
      }
    }
  | {
      type: 'InitiateTeleport'
      value: {
        assets: StagingXcmV2MultiassetMultiAssetFilter
        dest: StagingXcmV2MultilocationMultiLocation
        xcm: StagingXcmV2Xcm
      }
    }
  | {
      type: 'QueryHolding'
      value: {
        queryId: bigint
        dest: StagingXcmV2MultilocationMultiLocation
        assets: StagingXcmV2MultiassetMultiAssetFilter
        maxResponseWeight: bigint
      }
    }
  | { type: 'BuyExecution'; value: { fees: StagingXcmV2MultiassetMultiAsset; weightLimit: StagingXcmV2WeightLimit } }
  | { type: 'RefundSurplus' }
  | { type: 'SetErrorHandler'; value: StagingXcmV2Xcm }
  | { type: 'SetAppendix'; value: StagingXcmV2Xcm }
  | { type: 'ClearError' }
  | {
      type: 'ClaimAsset'
      value: { assets: StagingXcmV2MultiassetMultiAssets; ticket: StagingXcmV2MultilocationMultiLocation }
    }
  | { type: 'Trap'; value: bigint }
  | { type: 'SubscribeVersion'; value: { queryId: bigint; maxResponseWeight: bigint } }
  | { type: 'UnsubscribeVersion' }

export type StagingXcmV2Response =
  | { type: 'Null' }
  | { type: 'Assets'; value: StagingXcmV2MultiassetMultiAssets }
  | { type: 'ExecutionResult'; value?: [number, StagingXcmV2TraitsError] | undefined }
  | { type: 'Version'; value: number }

export type StagingXcmV2TraitsError =
  | { type: 'Overflow' }
  | { type: 'Unimplemented' }
  | { type: 'UntrustedReserveLocation' }
  | { type: 'UntrustedTeleportLocation' }
  | { type: 'MultiLocationFull' }
  | { type: 'MultiLocationNotInvertible' }
  | { type: 'BadOrigin' }
  | { type: 'InvalidLocation' }
  | { type: 'AssetNotFound' }
  | { type: 'FailedToTransactAsset' }
  | { type: 'NotWithdrawable' }
  | { type: 'LocationCannotHold' }
  | { type: 'ExceedsMaxMessageSize' }
  | { type: 'DestinationUnsupported' }
  | { type: 'Transport' }
  | { type: 'Unroutable' }
  | { type: 'UnknownClaim' }
  | { type: 'FailedToDecode' }
  | { type: 'MaxWeightInvalid' }
  | { type: 'NotHoldingFees' }
  | { type: 'TooExpensive' }
  | { type: 'Trap'; value: bigint }
  | { type: 'UnhandledXcmVersion' }
  | { type: 'WeightLimitReached'; value: bigint }
  | { type: 'Barrier' }
  | { type: 'WeightNotComputable' }

export type StagingXcmV2MultiassetMultiAssetFilter =
  | { type: 'Definite'; value: StagingXcmV2MultiassetMultiAssets }
  | { type: 'Wild'; value: StagingXcmV2MultiassetWildMultiAsset }

export type StagingXcmV2MultiassetWildMultiAsset =
  | { type: 'All' }
  | { type: 'AllOf'; value: { id: StagingXcmV2MultiassetAssetId; fun: StagingXcmV2MultiassetWildFungibility } }

export type StagingXcmV2MultiassetWildFungibility = 'Fungible' | 'NonFungible'

export type StagingXcmV2WeightLimit = { type: 'Unlimited' } | { type: 'Limited'; value: bigint }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * See [`Pallet::transfer_allow_death`].
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddress; dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddress; value: bigint } }
  /**
   * See [`Pallet::transfer_all`].
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddress; keepAlive: boolean } }
  /**
   * See [`Pallet::force_unreserve`].
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::upgrade_accounts`].
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32> } }
  /**
   * See [`Pallet::force_set_balance`].
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddress; newFree: bigint } }

export type PalletBalancesCallLike =
  /**
   * See [`Pallet::transfer_allow_death`].
   **/
  | { name: 'TransferAllowDeath'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { source: MultiAddressLike; dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { dest: MultiAddressLike; value: bigint } }
  /**
   * See [`Pallet::transfer_all`].
   **/
  | { name: 'TransferAll'; params: { dest: MultiAddressLike; keepAlive: boolean } }
  /**
   * See [`Pallet::force_unreserve`].
   **/
  | { name: 'ForceUnreserve'; params: { who: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::upgrade_accounts`].
   **/
  | { name: 'UpgradeAccounts'; params: { who: Array<AccountId32Like> } }
  /**
   * See [`Pallet::force_set_balance`].
   **/
  | { name: 'ForceSetBalance'; params: { who: MultiAddressLike; newFree: bigint } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetsCall =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { id: number; admin: MultiAddress; minBalance: bigint } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { id: number; owner: MultiAddress; isSufficient: boolean; minBalance: bigint } }
  /**
   * See [`Pallet::start_destroy`].
   **/
  | { name: 'StartDestroy'; params: { id: number } }
  /**
   * See [`Pallet::destroy_accounts`].
   **/
  | { name: 'DestroyAccounts'; params: { id: number } }
  /**
   * See [`Pallet::destroy_approvals`].
   **/
  | { name: 'DestroyApprovals'; params: { id: number } }
  /**
   * See [`Pallet::finish_destroy`].
   **/
  | { name: 'FinishDestroy'; params: { id: number } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { id: number; beneficiary: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { id: number; who: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { id: number; target: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { id: number; target: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { id: number; source: MultiAddress; dest: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { id: number; who: MultiAddress } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { id: number; who: MultiAddress } }
  /**
   * See [`Pallet::freeze_asset`].
   **/
  | { name: 'FreezeAsset'; params: { id: number } }
  /**
   * See [`Pallet::thaw_asset`].
   **/
  | { name: 'ThawAsset'; params: { id: number } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { id: number; owner: MultiAddress } }
  /**
   * See [`Pallet::set_team`].
   **/
  | { name: 'SetTeam'; params: { id: number; issuer: MultiAddress; admin: MultiAddress; freezer: MultiAddress } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { id: number; name: Bytes; symbol: Bytes; decimals: number } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { id: number } }
  /**
   * See [`Pallet::force_set_metadata`].
   **/
  | {
      name: 'ForceSetMetadata'
      params: { id: number; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean }
    }
  /**
   * See [`Pallet::force_clear_metadata`].
   **/
  | { name: 'ForceClearMetadata'; params: { id: number } }
  /**
   * See [`Pallet::force_asset_status`].
   **/
  | {
      name: 'ForceAssetStatus'
      params: {
        id: number
        owner: MultiAddress
        issuer: MultiAddress
        admin: MultiAddress
        freezer: MultiAddress
        minBalance: bigint
        isSufficient: boolean
        isFrozen: boolean
      }
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | { name: 'ApproveTransfer'; params: { id: number; delegate: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | { name: 'CancelApproval'; params: { id: number; delegate: MultiAddress } }
  /**
   * See [`Pallet::force_cancel_approval`].
   **/
  | { name: 'ForceCancelApproval'; params: { id: number; owner: MultiAddress; delegate: MultiAddress } }
  /**
   * See [`Pallet::transfer_approved`].
   **/
  | { name: 'TransferApproved'; params: { id: number; owner: MultiAddress; destination: MultiAddress; amount: bigint } }
  /**
   * See [`Pallet::touch`].
   **/
  | { name: 'Touch'; params: { id: number } }
  /**
   * See [`Pallet::refund`].
   **/
  | { name: 'Refund'; params: { id: number; allowBurn: boolean } }
  /**
   * See [`Pallet::set_min_balance`].
   **/
  | { name: 'SetMinBalance'; params: { id: number; minBalance: bigint } }
  /**
   * See [`Pallet::touch_other`].
   **/
  | { name: 'TouchOther'; params: { id: number; who: MultiAddress } }
  /**
   * See [`Pallet::refund_other`].
   **/
  | { name: 'RefundOther'; params: { id: number; who: MultiAddress } }
  /**
   * See [`Pallet::block`].
   **/
  | { name: 'Block'; params: { id: number; who: MultiAddress } }

export type PalletAssetsCallLike =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { id: number; admin: MultiAddressLike; minBalance: bigint } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { id: number; owner: MultiAddressLike; isSufficient: boolean; minBalance: bigint } }
  /**
   * See [`Pallet::start_destroy`].
   **/
  | { name: 'StartDestroy'; params: { id: number } }
  /**
   * See [`Pallet::destroy_accounts`].
   **/
  | { name: 'DestroyAccounts'; params: { id: number } }
  /**
   * See [`Pallet::destroy_approvals`].
   **/
  | { name: 'DestroyApprovals'; params: { id: number } }
  /**
   * See [`Pallet::finish_destroy`].
   **/
  | { name: 'FinishDestroy'; params: { id: number } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { id: number; beneficiary: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { id: number; who: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { id: number; target: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::transfer_keep_alive`].
   **/
  | { name: 'TransferKeepAlive'; params: { id: number; target: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::force_transfer`].
   **/
  | { name: 'ForceTransfer'; params: { id: number; source: MultiAddressLike; dest: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { id: number; who: MultiAddressLike } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { id: number; who: MultiAddressLike } }
  /**
   * See [`Pallet::freeze_asset`].
   **/
  | { name: 'FreezeAsset'; params: { id: number } }
  /**
   * See [`Pallet::thaw_asset`].
   **/
  | { name: 'ThawAsset'; params: { id: number } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { id: number; owner: MultiAddressLike } }
  /**
   * See [`Pallet::set_team`].
   **/
  | {
      name: 'SetTeam'
      params: { id: number; issuer: MultiAddressLike; admin: MultiAddressLike; freezer: MultiAddressLike }
    }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { id: number; name: BytesLike; symbol: BytesLike; decimals: number } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { id: number } }
  /**
   * See [`Pallet::force_set_metadata`].
   **/
  | {
      name: 'ForceSetMetadata'
      params: { id: number; name: BytesLike; symbol: BytesLike; decimals: number; isFrozen: boolean }
    }
  /**
   * See [`Pallet::force_clear_metadata`].
   **/
  | { name: 'ForceClearMetadata'; params: { id: number } }
  /**
   * See [`Pallet::force_asset_status`].
   **/
  | {
      name: 'ForceAssetStatus'
      params: {
        id: number
        owner: MultiAddressLike
        issuer: MultiAddressLike
        admin: MultiAddressLike
        freezer: MultiAddressLike
        minBalance: bigint
        isSufficient: boolean
        isFrozen: boolean
      }
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | { name: 'ApproveTransfer'; params: { id: number; delegate: MultiAddressLike; amount: bigint } }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | { name: 'CancelApproval'; params: { id: number; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::force_cancel_approval`].
   **/
  | { name: 'ForceCancelApproval'; params: { id: number; owner: MultiAddressLike; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::transfer_approved`].
   **/
  | {
      name: 'TransferApproved'
      params: { id: number; owner: MultiAddressLike; destination: MultiAddressLike; amount: bigint }
    }
  /**
   * See [`Pallet::touch`].
   **/
  | { name: 'Touch'; params: { id: number } }
  /**
   * See [`Pallet::refund`].
   **/
  | { name: 'Refund'; params: { id: number; allowBurn: boolean } }
  /**
   * See [`Pallet::set_min_balance`].
   **/
  | { name: 'SetMinBalance'; params: { id: number; minBalance: bigint } }
  /**
   * See [`Pallet::touch_other`].
   **/
  | { name: 'TouchOther'; params: { id: number; who: MultiAddressLike } }
  /**
   * See [`Pallet::refund_other`].
   **/
  | { name: 'RefundOther'; params: { id: number; who: MultiAddressLike } }
  /**
   * See [`Pallet::block`].
   **/
  | { name: 'Block'; params: { id: number; who: MultiAddressLike } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCollatorSelectionCall =
  /**
   * See [`Pallet::set_invulnerables`].
   **/
  | { name: 'SetInvulnerables'; params: { new: Array<AccountId32> } }
  /**
   * See [`Pallet::set_desired_candidates`].
   **/
  | { name: 'SetDesiredCandidates'; params: { max: number } }
  /**
   * See [`Pallet::set_candidacy_bond`].
   **/
  | { name: 'SetCandidacyBond'; params: { bond: bigint } }
  /**
   * See [`Pallet::register_as_candidate`].
   **/
  | { name: 'RegisterAsCandidate' }
  /**
   * See [`Pallet::leave_intent`].
   **/
  | { name: 'LeaveIntent' }
  /**
   * See [`Pallet::add_invulnerable`].
   **/
  | { name: 'AddInvulnerable'; params: { who: AccountId32 } }
  /**
   * See [`Pallet::remove_invulnerable`].
   **/
  | { name: 'RemoveInvulnerable'; params: { who: AccountId32 } }

export type PalletCollatorSelectionCallLike =
  /**
   * See [`Pallet::set_invulnerables`].
   **/
  | { name: 'SetInvulnerables'; params: { new: Array<AccountId32Like> } }
  /**
   * See [`Pallet::set_desired_candidates`].
   **/
  | { name: 'SetDesiredCandidates'; params: { max: number } }
  /**
   * See [`Pallet::set_candidacy_bond`].
   **/
  | { name: 'SetCandidacyBond'; params: { bond: bigint } }
  /**
   * See [`Pallet::register_as_candidate`].
   **/
  | { name: 'RegisterAsCandidate' }
  /**
   * See [`Pallet::leave_intent`].
   **/
  | { name: 'LeaveIntent' }
  /**
   * See [`Pallet::add_invulnerable`].
   **/
  | { name: 'AddInvulnerable'; params: { who: AccountId32Like } }
  /**
   * See [`Pallet::remove_invulnerable`].
   **/
  | { name: 'RemoveInvulnerable'; params: { who: AccountId32Like } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSessionCall =
  /**
   * See [`Pallet::set_keys`].
   **/
  | { name: 'SetKeys'; params: { keys: PhalaParachainRuntimeOpaqueSessionKeys; proof: Bytes } }
  /**
   * See [`Pallet::purge_keys`].
   **/
  | { name: 'PurgeKeys' }

export type PalletSessionCallLike =
  /**
   * See [`Pallet::set_keys`].
   **/
  | { name: 'SetKeys'; params: { keys: PhalaParachainRuntimeOpaqueSessionKeys; proof: BytesLike } }
  /**
   * See [`Pallet::purge_keys`].
   **/
  | { name: 'PurgeKeys' }

export type PhalaParachainRuntimeOpaqueSessionKeys = { aura: SpConsensusAuraSr25519AppSr25519Public }

export type SpConsensusAuraSr25519AppSr25519Public = SpCoreSr25519Public

/**
 * Identity pallet declaration.
 **/
export type PalletIdentityCall =
  /**
   * See [`Pallet::add_registrar`].
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddress } }
  /**
   * See [`Pallet::set_identity`].
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityIdentityInfo } }
  /**
   * See [`Pallet::set_subs`].
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32, Data]> } }
  /**
   * See [`Pallet::clear_identity`].
   **/
  | { name: 'ClearIdentity' }
  /**
   * See [`Pallet::request_judgement`].
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * See [`Pallet::cancel_request`].
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * See [`Pallet::set_fee`].
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * See [`Pallet::set_account_id`].
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddress } }
  /**
   * See [`Pallet::set_fields`].
   **/
  | { name: 'SetFields'; params: { index: number; fields: PalletIdentityBitFlags } }
  /**
   * See [`Pallet::provide_judgement`].
   **/
  | {
      name: 'ProvideJudgement'
      params: { regIndex: number; target: MultiAddress; judgement: PalletIdentityJudgement; identity: H256 }
    }
  /**
   * See [`Pallet::kill_identity`].
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddress } }
  /**
   * See [`Pallet::add_sub`].
   **/
  | { name: 'AddSub'; params: { sub: MultiAddress; data: Data } }
  /**
   * See [`Pallet::rename_sub`].
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddress; data: Data } }
  /**
   * See [`Pallet::remove_sub`].
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddress } }
  /**
   * See [`Pallet::quit_sub`].
   **/
  | { name: 'QuitSub' }

export type PalletIdentityCallLike =
  /**
   * See [`Pallet::add_registrar`].
   **/
  | { name: 'AddRegistrar'; params: { account: MultiAddressLike } }
  /**
   * See [`Pallet::set_identity`].
   **/
  | { name: 'SetIdentity'; params: { info: PalletIdentityIdentityInfo } }
  /**
   * See [`Pallet::set_subs`].
   **/
  | { name: 'SetSubs'; params: { subs: Array<[AccountId32Like, Data]> } }
  /**
   * See [`Pallet::clear_identity`].
   **/
  | { name: 'ClearIdentity' }
  /**
   * See [`Pallet::request_judgement`].
   **/
  | { name: 'RequestJudgement'; params: { regIndex: number; maxFee: bigint } }
  /**
   * See [`Pallet::cancel_request`].
   **/
  | { name: 'CancelRequest'; params: { regIndex: number } }
  /**
   * See [`Pallet::set_fee`].
   **/
  | { name: 'SetFee'; params: { index: number; fee: bigint } }
  /**
   * See [`Pallet::set_account_id`].
   **/
  | { name: 'SetAccountId'; params: { index: number; new: MultiAddressLike } }
  /**
   * See [`Pallet::set_fields`].
   **/
  | { name: 'SetFields'; params: { index: number; fields: PalletIdentityBitFlags } }
  /**
   * See [`Pallet::provide_judgement`].
   **/
  | {
      name: 'ProvideJudgement'
      params: { regIndex: number; target: MultiAddressLike; judgement: PalletIdentityJudgement; identity: H256 }
    }
  /**
   * See [`Pallet::kill_identity`].
   **/
  | { name: 'KillIdentity'; params: { target: MultiAddressLike } }
  /**
   * See [`Pallet::add_sub`].
   **/
  | { name: 'AddSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * See [`Pallet::rename_sub`].
   **/
  | { name: 'RenameSub'; params: { sub: MultiAddressLike; data: Data } }
  /**
   * See [`Pallet::remove_sub`].
   **/
  | { name: 'RemoveSub'; params: { sub: MultiAddressLike } }
  /**
   * See [`Pallet::quit_sub`].
   **/
  | { name: 'QuitSub' }

export type PalletIdentityIdentityInfo = {
  additional: Array<[Data, Data]>
  display: Data
  legal: Data
  web: Data
  riot: Data
  email: Data
  pgpFingerprint?: FixedBytes<20> | undefined
  image: Data
  twitter: Data
}

export type PalletIdentityBitFlags = bigint

export type PalletIdentityIdentityField =
  | 'Display'
  | 'Legal'
  | 'Web'
  | 'Riot'
  | 'Email'
  | 'PgpFingerprint'
  | 'Image'
  | 'Twitter'

export type PalletIdentityJudgement =
  | { type: 'Unknown' }
  | { type: 'FeePaid'; value: bigint }
  | { type: 'Reasonable' }
  | { type: 'KnownGood' }
  | { type: 'OutOfDate' }
  | { type: 'LowQuality' }
  | { type: 'Erroneous' }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDemocracyCall =
  /**
   * See [`Pallet::propose`].
   **/
  | { name: 'Propose'; params: { proposal: FrameSupportPreimagesBounded; value: bigint } }
  /**
   * See [`Pallet::second`].
   **/
  | { name: 'Second'; params: { proposal: number } }
  /**
   * See [`Pallet::vote`].
   **/
  | { name: 'Vote'; params: { refIndex: number; vote: PalletDemocracyVoteAccountVote } }
  /**
   * See [`Pallet::emergency_cancel`].
   **/
  | { name: 'EmergencyCancel'; params: { refIndex: number } }
  /**
   * See [`Pallet::external_propose`].
   **/
  | { name: 'ExternalPropose'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * See [`Pallet::external_propose_majority`].
   **/
  | { name: 'ExternalProposeMajority'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * See [`Pallet::external_propose_default`].
   **/
  | { name: 'ExternalProposeDefault'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * See [`Pallet::fast_track`].
   **/
  | { name: 'FastTrack'; params: { proposalHash: H256; votingPeriod: number; delay: number } }
  /**
   * See [`Pallet::veto_external`].
   **/
  | { name: 'VetoExternal'; params: { proposalHash: H256 } }
  /**
   * See [`Pallet::cancel_referendum`].
   **/
  | { name: 'CancelReferendum'; params: { refIndex: number } }
  /**
   * See [`Pallet::delegate`].
   **/
  | { name: 'Delegate'; params: { to: MultiAddress; conviction: PalletDemocracyConviction; balance: bigint } }
  /**
   * See [`Pallet::undelegate`].
   **/
  | { name: 'Undelegate' }
  /**
   * See [`Pallet::clear_public_proposals`].
   **/
  | { name: 'ClearPublicProposals' }
  /**
   * See [`Pallet::unlock`].
   **/
  | { name: 'Unlock'; params: { target: MultiAddress } }
  /**
   * See [`Pallet::remove_vote`].
   **/
  | { name: 'RemoveVote'; params: { index: number } }
  /**
   * See [`Pallet::remove_other_vote`].
   **/
  | { name: 'RemoveOtherVote'; params: { target: MultiAddress; index: number } }
  /**
   * See [`Pallet::blacklist`].
   **/
  | { name: 'Blacklist'; params: { proposalHash: H256; maybeRefIndex?: number | undefined } }
  /**
   * See [`Pallet::cancel_proposal`].
   **/
  | { name: 'CancelProposal'; params: { propIndex: number } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { owner: PalletDemocracyMetadataOwner; maybeHash?: H256 | undefined } }

export type PalletDemocracyCallLike =
  /**
   * See [`Pallet::propose`].
   **/
  | { name: 'Propose'; params: { proposal: FrameSupportPreimagesBounded; value: bigint } }
  /**
   * See [`Pallet::second`].
   **/
  | { name: 'Second'; params: { proposal: number } }
  /**
   * See [`Pallet::vote`].
   **/
  | { name: 'Vote'; params: { refIndex: number; vote: PalletDemocracyVoteAccountVote } }
  /**
   * See [`Pallet::emergency_cancel`].
   **/
  | { name: 'EmergencyCancel'; params: { refIndex: number } }
  /**
   * See [`Pallet::external_propose`].
   **/
  | { name: 'ExternalPropose'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * See [`Pallet::external_propose_majority`].
   **/
  | { name: 'ExternalProposeMajority'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * See [`Pallet::external_propose_default`].
   **/
  | { name: 'ExternalProposeDefault'; params: { proposal: FrameSupportPreimagesBounded } }
  /**
   * See [`Pallet::fast_track`].
   **/
  | { name: 'FastTrack'; params: { proposalHash: H256; votingPeriod: number; delay: number } }
  /**
   * See [`Pallet::veto_external`].
   **/
  | { name: 'VetoExternal'; params: { proposalHash: H256 } }
  /**
   * See [`Pallet::cancel_referendum`].
   **/
  | { name: 'CancelReferendum'; params: { refIndex: number } }
  /**
   * See [`Pallet::delegate`].
   **/
  | { name: 'Delegate'; params: { to: MultiAddressLike; conviction: PalletDemocracyConviction; balance: bigint } }
  /**
   * See [`Pallet::undelegate`].
   **/
  | { name: 'Undelegate' }
  /**
   * See [`Pallet::clear_public_proposals`].
   **/
  | { name: 'ClearPublicProposals' }
  /**
   * See [`Pallet::unlock`].
   **/
  | { name: 'Unlock'; params: { target: MultiAddressLike } }
  /**
   * See [`Pallet::remove_vote`].
   **/
  | { name: 'RemoveVote'; params: { index: number } }
  /**
   * See [`Pallet::remove_other_vote`].
   **/
  | { name: 'RemoveOtherVote'; params: { target: MultiAddressLike; index: number } }
  /**
   * See [`Pallet::blacklist`].
   **/
  | { name: 'Blacklist'; params: { proposalHash: H256; maybeRefIndex?: number | undefined } }
  /**
   * See [`Pallet::cancel_proposal`].
   **/
  | { name: 'CancelProposal'; params: { propIndex: number } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { owner: PalletDemocracyMetadataOwner; maybeHash?: H256 | undefined } }

export type FrameSupportPreimagesBounded =
  | { type: 'Legacy'; value: { hash: H256 } }
  | { type: 'Inline'; value: Bytes }
  | { type: 'Lookup'; value: { hash: H256; len: number } }

export type SpRuntimeBlakeTwo256 = {}

export type PalletDemocracyConviction =
  | 'None'
  | 'Locked1x'
  | 'Locked2x'
  | 'Locked3x'
  | 'Locked4x'
  | 'Locked5x'
  | 'Locked6x'

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCollectiveCall =
  /**
   * See [`Pallet::set_members`].
   **/
  | {
      name: 'SetMembers'
      params: { newMembers: Array<AccountId32>; prime?: AccountId32 | undefined; oldCount: number }
    }
  /**
   * See [`Pallet::execute`].
   **/
  | { name: 'Execute'; params: { proposal: PhalaParachainRuntimeRuntimeCall; lengthBound: number } }
  /**
   * See [`Pallet::propose`].
   **/
  | { name: 'Propose'; params: { threshold: number; proposal: PhalaParachainRuntimeRuntimeCall; lengthBound: number } }
  /**
   * See [`Pallet::vote`].
   **/
  | { name: 'Vote'; params: { proposal: H256; index: number; approve: boolean } }
  /**
   * See [`Pallet::disapprove_proposal`].
   **/
  | { name: 'DisapproveProposal'; params: { proposalHash: H256 } }
  /**
   * See [`Pallet::close`].
   **/
  | {
      name: 'Close'
      params: { proposalHash: H256; index: number; proposalWeightBound: SpWeightsWeightV2Weight; lengthBound: number }
    }

export type PalletCollectiveCallLike =
  /**
   * See [`Pallet::set_members`].
   **/
  | {
      name: 'SetMembers'
      params: { newMembers: Array<AccountId32Like>; prime?: AccountId32Like | undefined; oldCount: number }
    }
  /**
   * See [`Pallet::execute`].
   **/
  | { name: 'Execute'; params: { proposal: PhalaParachainRuntimeRuntimeCallLike; lengthBound: number } }
  /**
   * See [`Pallet::propose`].
   **/
  | {
      name: 'Propose'
      params: { threshold: number; proposal: PhalaParachainRuntimeRuntimeCallLike; lengthBound: number }
    }
  /**
   * See [`Pallet::vote`].
   **/
  | { name: 'Vote'; params: { proposal: H256; index: number; approve: boolean } }
  /**
   * See [`Pallet::disapprove_proposal`].
   **/
  | { name: 'DisapproveProposal'; params: { proposalHash: H256 } }
  /**
   * See [`Pallet::close`].
   **/
  | {
      name: 'Close'
      params: { proposalHash: H256; index: number; proposalWeightBound: SpWeightsWeightV2Weight; lengthBound: number }
    }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTreasuryCall =
  /**
   * See [`Pallet::propose_spend`].
   **/
  | { name: 'ProposeSpend'; params: { value: bigint; beneficiary: MultiAddress } }
  /**
   * See [`Pallet::reject_proposal`].
   **/
  | { name: 'RejectProposal'; params: { proposalId: number } }
  /**
   * See [`Pallet::approve_proposal`].
   **/
  | { name: 'ApproveProposal'; params: { proposalId: number } }
  /**
   * See [`Pallet::spend`].
   **/
  | { name: 'Spend'; params: { amount: bigint; beneficiary: MultiAddress } }
  /**
   * See [`Pallet::remove_approval`].
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } }

export type PalletTreasuryCallLike =
  /**
   * See [`Pallet::propose_spend`].
   **/
  | { name: 'ProposeSpend'; params: { value: bigint; beneficiary: MultiAddressLike } }
  /**
   * See [`Pallet::reject_proposal`].
   **/
  | { name: 'RejectProposal'; params: { proposalId: number } }
  /**
   * See [`Pallet::approve_proposal`].
   **/
  | { name: 'ApproveProposal'; params: { proposalId: number } }
  /**
   * See [`Pallet::spend`].
   **/
  | { name: 'Spend'; params: { amount: bigint; beneficiary: MultiAddressLike } }
  /**
   * See [`Pallet::remove_approval`].
   **/
  | { name: 'RemoveApproval'; params: { proposalId: number } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBountiesCall =
  /**
   * See [`Pallet::propose_bounty`].
   **/
  | { name: 'ProposeBounty'; params: { value: bigint; description: Bytes } }
  /**
   * See [`Pallet::approve_bounty`].
   **/
  | { name: 'ApproveBounty'; params: { bountyId: number } }
  /**
   * See [`Pallet::propose_curator`].
   **/
  | { name: 'ProposeCurator'; params: { bountyId: number; curator: MultiAddress; fee: bigint } }
  /**
   * See [`Pallet::unassign_curator`].
   **/
  | { name: 'UnassignCurator'; params: { bountyId: number } }
  /**
   * See [`Pallet::accept_curator`].
   **/
  | { name: 'AcceptCurator'; params: { bountyId: number } }
  /**
   * See [`Pallet::award_bounty`].
   **/
  | { name: 'AwardBounty'; params: { bountyId: number; beneficiary: MultiAddress } }
  /**
   * See [`Pallet::claim_bounty`].
   **/
  | { name: 'ClaimBounty'; params: { bountyId: number } }
  /**
   * See [`Pallet::close_bounty`].
   **/
  | { name: 'CloseBounty'; params: { bountyId: number } }
  /**
   * See [`Pallet::extend_bounty_expiry`].
   **/
  | { name: 'ExtendBountyExpiry'; params: { bountyId: number; remark: Bytes } }

export type PalletBountiesCallLike =
  /**
   * See [`Pallet::propose_bounty`].
   **/
  | { name: 'ProposeBounty'; params: { value: bigint; description: BytesLike } }
  /**
   * See [`Pallet::approve_bounty`].
   **/
  | { name: 'ApproveBounty'; params: { bountyId: number } }
  /**
   * See [`Pallet::propose_curator`].
   **/
  | { name: 'ProposeCurator'; params: { bountyId: number; curator: MultiAddressLike; fee: bigint } }
  /**
   * See [`Pallet::unassign_curator`].
   **/
  | { name: 'UnassignCurator'; params: { bountyId: number } }
  /**
   * See [`Pallet::accept_curator`].
   **/
  | { name: 'AcceptCurator'; params: { bountyId: number } }
  /**
   * See [`Pallet::award_bounty`].
   **/
  | { name: 'AwardBounty'; params: { bountyId: number; beneficiary: MultiAddressLike } }
  /**
   * See [`Pallet::claim_bounty`].
   **/
  | { name: 'ClaimBounty'; params: { bountyId: number } }
  /**
   * See [`Pallet::close_bounty`].
   **/
  | { name: 'CloseBounty'; params: { bountyId: number } }
  /**
   * See [`Pallet::extend_bounty_expiry`].
   **/
  | { name: 'ExtendBountyExpiry'; params: { bountyId: number; remark: BytesLike } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletLotteryCall =
  /**
   * See [`Pallet::buy_ticket`].
   **/
  | { name: 'BuyTicket'; params: { call: PhalaParachainRuntimeRuntimeCall } }
  /**
   * See [`Pallet::set_calls`].
   **/
  | { name: 'SetCalls'; params: { calls: Array<PhalaParachainRuntimeRuntimeCall> } }
  /**
   * See [`Pallet::start_lottery`].
   **/
  | { name: 'StartLottery'; params: { price: bigint; length: number; delay: number; repeat: boolean } }
  /**
   * See [`Pallet::stop_repeat`].
   **/
  | { name: 'StopRepeat' }

export type PalletLotteryCallLike =
  /**
   * See [`Pallet::buy_ticket`].
   **/
  | { name: 'BuyTicket'; params: { call: PhalaParachainRuntimeRuntimeCallLike } }
  /**
   * See [`Pallet::set_calls`].
   **/
  | { name: 'SetCalls'; params: { calls: Array<PhalaParachainRuntimeRuntimeCallLike> } }
  /**
   * See [`Pallet::start_lottery`].
   **/
  | { name: 'StartLottery'; params: { price: bigint; length: number; delay: number; repeat: boolean } }
  /**
   * See [`Pallet::stop_repeat`].
   **/
  | { name: 'StopRepeat' }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMembershipCall =
  /**
   * See [`Pallet::add_member`].
   **/
  | { name: 'AddMember'; params: { who: MultiAddress } }
  /**
   * See [`Pallet::remove_member`].
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddress } }
  /**
   * See [`Pallet::swap_member`].
   **/
  | { name: 'SwapMember'; params: { remove: MultiAddress; add: MultiAddress } }
  /**
   * See [`Pallet::reset_members`].
   **/
  | { name: 'ResetMembers'; params: { members: Array<AccountId32> } }
  /**
   * See [`Pallet::change_key`].
   **/
  | { name: 'ChangeKey'; params: { new: MultiAddress } }
  /**
   * See [`Pallet::set_prime`].
   **/
  | { name: 'SetPrime'; params: { who: MultiAddress } }
  /**
   * See [`Pallet::clear_prime`].
   **/
  | { name: 'ClearPrime' }

export type PalletMembershipCallLike =
  /**
   * See [`Pallet::add_member`].
   **/
  | { name: 'AddMember'; params: { who: MultiAddressLike } }
  /**
   * See [`Pallet::remove_member`].
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddressLike } }
  /**
   * See [`Pallet::swap_member`].
   **/
  | { name: 'SwapMember'; params: { remove: MultiAddressLike; add: MultiAddressLike } }
  /**
   * See [`Pallet::reset_members`].
   **/
  | { name: 'ResetMembers'; params: { members: Array<AccountId32Like> } }
  /**
   * See [`Pallet::change_key`].
   **/
  | { name: 'ChangeKey'; params: { new: MultiAddressLike } }
  /**
   * See [`Pallet::set_prime`].
   **/
  | { name: 'SetPrime'; params: { who: MultiAddressLike } }
  /**
   * See [`Pallet::clear_prime`].
   **/
  | { name: 'ClearPrime' }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletElectionsPhragmenCall =
  /**
   * See [`Pallet::vote`].
   **/
  | { name: 'Vote'; params: { votes: Array<AccountId32>; value: bigint } }
  /**
   * See [`Pallet::remove_voter`].
   **/
  | { name: 'RemoveVoter' }
  /**
   * See [`Pallet::submit_candidacy`].
   **/
  | { name: 'SubmitCandidacy'; params: { candidateCount: number } }
  /**
   * See [`Pallet::renounce_candidacy`].
   **/
  | { name: 'RenounceCandidacy'; params: { renouncing: PalletElectionsPhragmenRenouncing } }
  /**
   * See [`Pallet::remove_member`].
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddress; slashBond: boolean; rerunElection: boolean } }
  /**
   * See [`Pallet::clean_defunct_voters`].
   **/
  | { name: 'CleanDefunctVoters'; params: { numVoters: number; numDefunct: number } }

export type PalletElectionsPhragmenCallLike =
  /**
   * See [`Pallet::vote`].
   **/
  | { name: 'Vote'; params: { votes: Array<AccountId32Like>; value: bigint } }
  /**
   * See [`Pallet::remove_voter`].
   **/
  | { name: 'RemoveVoter' }
  /**
   * See [`Pallet::submit_candidacy`].
   **/
  | { name: 'SubmitCandidacy'; params: { candidateCount: number } }
  /**
   * See [`Pallet::renounce_candidacy`].
   **/
  | { name: 'RenounceCandidacy'; params: { renouncing: PalletElectionsPhragmenRenouncing } }
  /**
   * See [`Pallet::remove_member`].
   **/
  | { name: 'RemoveMember'; params: { who: MultiAddressLike; slashBond: boolean; rerunElection: boolean } }
  /**
   * See [`Pallet::clean_defunct_voters`].
   **/
  | { name: 'CleanDefunctVoters'; params: { numVoters: number; numDefunct: number } }

export type PalletElectionsPhragmenRenouncing =
  | { type: 'Member' }
  | { type: 'RunnerUp' }
  | { type: 'Candidate'; value: number }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTipsCall =
  /**
   * See [`Pallet::report_awesome`].
   **/
  | { name: 'ReportAwesome'; params: { reason: Bytes; who: MultiAddress } }
  /**
   * See [`Pallet::retract_tip`].
   **/
  | { name: 'RetractTip'; params: { hash: H256 } }
  /**
   * See [`Pallet::tip_new`].
   **/
  | { name: 'TipNew'; params: { reason: Bytes; who: MultiAddress; tipValue: bigint } }
  /**
   * See [`Pallet::tip`].
   **/
  | { name: 'Tip'; params: { hash: H256; tipValue: bigint } }
  /**
   * See [`Pallet::close_tip`].
   **/
  | { name: 'CloseTip'; params: { hash: H256 } }
  /**
   * See [`Pallet::slash_tip`].
   **/
  | { name: 'SlashTip'; params: { hash: H256 } }

export type PalletTipsCallLike =
  /**
   * See [`Pallet::report_awesome`].
   **/
  | { name: 'ReportAwesome'; params: { reason: BytesLike; who: MultiAddressLike } }
  /**
   * See [`Pallet::retract_tip`].
   **/
  | { name: 'RetractTip'; params: { hash: H256 } }
  /**
   * See [`Pallet::tip_new`].
   **/
  | { name: 'TipNew'; params: { reason: BytesLike; who: MultiAddressLike; tipValue: bigint } }
  /**
   * See [`Pallet::tip`].
   **/
  | { name: 'Tip'; params: { hash: H256; tipValue: bigint } }
  /**
   * See [`Pallet::close_tip`].
   **/
  | { name: 'CloseTip'; params: { hash: H256 } }
  /**
   * See [`Pallet::slash_tip`].
   **/
  | { name: 'SlashTip'; params: { hash: H256 } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletChildBountiesCall =
  /**
   * See [`Pallet::add_child_bounty`].
   **/
  | { name: 'AddChildBounty'; params: { parentBountyId: number; value: bigint; description: Bytes } }
  /**
   * See [`Pallet::propose_curator`].
   **/
  | {
      name: 'ProposeCurator'
      params: { parentBountyId: number; childBountyId: number; curator: MultiAddress; fee: bigint }
    }
  /**
   * See [`Pallet::accept_curator`].
   **/
  | { name: 'AcceptCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * See [`Pallet::unassign_curator`].
   **/
  | { name: 'UnassignCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * See [`Pallet::award_child_bounty`].
   **/
  | { name: 'AwardChildBounty'; params: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddress } }
  /**
   * See [`Pallet::claim_child_bounty`].
   **/
  | { name: 'ClaimChildBounty'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * See [`Pallet::close_child_bounty`].
   **/
  | { name: 'CloseChildBounty'; params: { parentBountyId: number; childBountyId: number } }

export type PalletChildBountiesCallLike =
  /**
   * See [`Pallet::add_child_bounty`].
   **/
  | { name: 'AddChildBounty'; params: { parentBountyId: number; value: bigint; description: BytesLike } }
  /**
   * See [`Pallet::propose_curator`].
   **/
  | {
      name: 'ProposeCurator'
      params: { parentBountyId: number; childBountyId: number; curator: MultiAddressLike; fee: bigint }
    }
  /**
   * See [`Pallet::accept_curator`].
   **/
  | { name: 'AcceptCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * See [`Pallet::unassign_curator`].
   **/
  | { name: 'UnassignCurator'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * See [`Pallet::award_child_bounty`].
   **/
  | {
      name: 'AwardChildBounty'
      params: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddressLike }
    }
  /**
   * See [`Pallet::claim_child_bounty`].
   **/
  | { name: 'ClaimChildBounty'; params: { parentBountyId: number; childBountyId: number } }
  /**
   * See [`Pallet::close_child_bounty`].
   **/
  | { name: 'CloseChildBounty'; params: { parentBountyId: number; childBountyId: number } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type SubbridgePalletsChainbridgePalletCall =
  /**
   * See [`Pallet::set_threshold`].
   **/
  | { name: 'SetThreshold'; params: { threshold: number } }
  /**
   * See [`Pallet::whitelist_chain`].
   **/
  | { name: 'WhitelistChain'; params: { id: number } }
  /**
   * See [`Pallet::add_relayer`].
   **/
  | { name: 'AddRelayer'; params: { v: AccountId32 } }
  /**
   * See [`Pallet::remove_relayer`].
   **/
  | { name: 'RemoveRelayer'; params: { v: AccountId32 } }
  /**
   * See [`Pallet::update_fee`].
   **/
  | { name: 'UpdateFee'; params: { fee: bigint; destId: number } }
  /**
   * See [`Pallet::acknowledge_proposal`].
   **/
  | {
      name: 'AcknowledgeProposal'
      params: { nonce: bigint; srcId: number; rId: FixedBytes<32>; call: PhalaParachainRuntimeRuntimeCall }
    }
  /**
   * See [`Pallet::reject_proposal`].
   **/
  | {
      name: 'RejectProposal'
      params: { nonce: bigint; srcId: number; rId: FixedBytes<32>; call: PhalaParachainRuntimeRuntimeCall }
    }
  /**
   * See [`Pallet::eval_vote_state`].
   **/
  | { name: 'EvalVoteState'; params: { nonce: bigint; srcId: number; prop: PhalaParachainRuntimeRuntimeCall } }
  /**
   * See [`Pallet::handle_fungible_transfer`].
   **/
  | { name: 'HandleFungibleTransfer'; params: { dest: Bytes; amount: bigint; rid: FixedBytes<32> } }

export type SubbridgePalletsChainbridgePalletCallLike =
  /**
   * See [`Pallet::set_threshold`].
   **/
  | { name: 'SetThreshold'; params: { threshold: number } }
  /**
   * See [`Pallet::whitelist_chain`].
   **/
  | { name: 'WhitelistChain'; params: { id: number } }
  /**
   * See [`Pallet::add_relayer`].
   **/
  | { name: 'AddRelayer'; params: { v: AccountId32Like } }
  /**
   * See [`Pallet::remove_relayer`].
   **/
  | { name: 'RemoveRelayer'; params: { v: AccountId32Like } }
  /**
   * See [`Pallet::update_fee`].
   **/
  | { name: 'UpdateFee'; params: { fee: bigint; destId: number } }
  /**
   * See [`Pallet::acknowledge_proposal`].
   **/
  | {
      name: 'AcknowledgeProposal'
      params: { nonce: bigint; srcId: number; rId: FixedBytes<32>; call: PhalaParachainRuntimeRuntimeCallLike }
    }
  /**
   * See [`Pallet::reject_proposal`].
   **/
  | {
      name: 'RejectProposal'
      params: { nonce: bigint; srcId: number; rId: FixedBytes<32>; call: PhalaParachainRuntimeRuntimeCallLike }
    }
  /**
   * See [`Pallet::eval_vote_state`].
   **/
  | { name: 'EvalVoteState'; params: { nonce: bigint; srcId: number; prop: PhalaParachainRuntimeRuntimeCallLike } }
  /**
   * See [`Pallet::handle_fungible_transfer`].
   **/
  | { name: 'HandleFungibleTransfer'; params: { dest: BytesLike; amount: bigint; rid: FixedBytes<32> } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type SubbridgePalletsXtransferPalletCall =
  /**
   * See [`Pallet::transfer`].
   **/
  | {
      name: 'Transfer'
      params: {
        asset: StagingXcmV3MultiassetMultiAsset
        dest: StagingXcmV3MultilocationMultiLocation
        destWeight?: SpWeightsWeightV2Weight | undefined
      }
    }
  /**
   * See [`Pallet::transfer_generic`].
   **/
  | {
      name: 'TransferGeneric'
      params: {
        data: Bytes
        dest: StagingXcmV3MultilocationMultiLocation
        destWeight?: SpWeightsWeightV2Weight | undefined
      }
    }

export type SubbridgePalletsXtransferPalletCallLike =
  /**
   * See [`Pallet::transfer`].
   **/
  | {
      name: 'Transfer'
      params: {
        asset: StagingXcmV3MultiassetMultiAsset
        dest: StagingXcmV3MultilocationMultiLocation
        destWeight?: SpWeightsWeightV2Weight | undefined
      }
    }
  /**
   * See [`Pallet::transfer_generic`].
   **/
  | {
      name: 'TransferGeneric'
      params: {
        data: BytesLike
        dest: StagingXcmV3MultilocationMultiLocation
        destWeight?: SpWeightsWeightV2Weight | undefined
      }
    }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type AssetsRegistryCall =
  /**
   * See [`Pallet::force_withdraw_fund`].
   **/
  | { name: 'ForceWithdrawFund'; params: { assetId?: number | undefined; recipient: AccountId32; amount: bigint } }
  /**
   * See [`Pallet::force_register_asset`].
   **/
  | {
      name: 'ForceRegisterAsset'
      params: {
        location: StagingXcmV3MultilocationMultiLocation
        assetId: number
        properties: AssetsRegistryAssetProperties
      }
    }
  /**
   * See [`Pallet::force_unregister_asset`].
   **/
  | { name: 'ForceUnregisterAsset'; params: { assetId: number } }
  /**
   * See [`Pallet::force_set_metadata`].
   **/
  | { name: 'ForceSetMetadata'; params: { assetId: number; properties: AssetsRegistryAssetProperties } }
  /**
   * See [`Pallet::force_mint`].
   **/
  | { name: 'ForceMint'; params: { assetId: number; beneficiary: AccountId32; amount: bigint } }
  /**
   * See [`Pallet::force_burn`].
   **/
  | { name: 'ForceBurn'; params: { assetId: number; who: AccountId32; amount: bigint } }
  /**
   * See [`Pallet::force_set_price`].
   **/
  | { name: 'ForceSetPrice'; params: { assetId: number; executionPrice: bigint } }
  /**
   * See [`Pallet::force_set_location`].
   **/
  | { name: 'ForceSetLocation'; params: { assetId: number; location: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::force_enable_chainbridge`].
   **/
  | {
      name: 'ForceEnableChainbridge'
      params: { assetId: number; chainId: number; isMintable: boolean; metadata: Bytes }
    }
  /**
   * See [`Pallet::force_disable_chainbridge`].
   **/
  | { name: 'ForceDisableChainbridge'; params: { assetId: number; chainId: number } }
  /**
   * See [`Pallet::force_enable_sygmabridge`].
   **/
  | {
      name: 'ForceEnableSygmabridge'
      params: { assetId: number; resourceId: FixedBytes<32>; domainId: number; isMintable: boolean; metadata: Bytes }
    }
  /**
   * See [`Pallet::force_disable_sygmabridge`].
   **/
  | { name: 'ForceDisableSygmabridge'; params: { assetId: number; resourceId: FixedBytes<32>; domainId: number } }

export type AssetsRegistryCallLike =
  /**
   * See [`Pallet::force_withdraw_fund`].
   **/
  | { name: 'ForceWithdrawFund'; params: { assetId?: number | undefined; recipient: AccountId32Like; amount: bigint } }
  /**
   * See [`Pallet::force_register_asset`].
   **/
  | {
      name: 'ForceRegisterAsset'
      params: {
        location: StagingXcmV3MultilocationMultiLocation
        assetId: number
        properties: AssetsRegistryAssetProperties
      }
    }
  /**
   * See [`Pallet::force_unregister_asset`].
   **/
  | { name: 'ForceUnregisterAsset'; params: { assetId: number } }
  /**
   * See [`Pallet::force_set_metadata`].
   **/
  | { name: 'ForceSetMetadata'; params: { assetId: number; properties: AssetsRegistryAssetProperties } }
  /**
   * See [`Pallet::force_mint`].
   **/
  | { name: 'ForceMint'; params: { assetId: number; beneficiary: AccountId32Like; amount: bigint } }
  /**
   * See [`Pallet::force_burn`].
   **/
  | { name: 'ForceBurn'; params: { assetId: number; who: AccountId32Like; amount: bigint } }
  /**
   * See [`Pallet::force_set_price`].
   **/
  | { name: 'ForceSetPrice'; params: { assetId: number; executionPrice: bigint } }
  /**
   * See [`Pallet::force_set_location`].
   **/
  | { name: 'ForceSetLocation'; params: { assetId: number; location: StagingXcmV3MultilocationMultiLocation } }
  /**
   * See [`Pallet::force_enable_chainbridge`].
   **/
  | {
      name: 'ForceEnableChainbridge'
      params: { assetId: number; chainId: number; isMintable: boolean; metadata: BytesLike }
    }
  /**
   * See [`Pallet::force_disable_chainbridge`].
   **/
  | { name: 'ForceDisableChainbridge'; params: { assetId: number; chainId: number } }
  /**
   * See [`Pallet::force_enable_sygmabridge`].
   **/
  | {
      name: 'ForceEnableSygmabridge'
      params: {
        assetId: number
        resourceId: FixedBytes<32>
        domainId: number
        isMintable: boolean
        metadata: BytesLike
      }
    }
  /**
   * See [`Pallet::force_disable_sygmabridge`].
   **/
  | { name: 'ForceDisableSygmabridge'; params: { assetId: number; resourceId: FixedBytes<32>; domainId: number } }

export type AssetsRegistryAssetProperties = { name: Bytes; symbol: Bytes; decimals: number }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PhalaPalletsMqPalletCall =
  /**
   * See [`Pallet::sync_offchain_message`].
   **/
  | { name: 'SyncOffchainMessage'; params: { signedMessage: PhalaMqSignedMessage } }
  /**
   * See [`Pallet::push_message`].
   **/
  | { name: 'PushMessage'; params: { destination: Bytes; payload: Bytes } }
  /**
   * See [`Pallet::force_push_pallet_message`].
   **/
  | { name: 'ForcePushPalletMessage'; params: { destination: Bytes; payload: Bytes } }

export type PhalaPalletsMqPalletCallLike =
  /**
   * See [`Pallet::sync_offchain_message`].
   **/
  | { name: 'SyncOffchainMessage'; params: { signedMessage: PhalaMqSignedMessage } }
  /**
   * See [`Pallet::push_message`].
   **/
  | { name: 'PushMessage'; params: { destination: BytesLike; payload: BytesLike } }
  /**
   * See [`Pallet::force_push_pallet_message`].
   **/
  | { name: 'ForcePushPalletMessage'; params: { destination: BytesLike; payload: BytesLike } }

export type PhalaMqSignedMessage = { message: PhalaMqMessage; sequence: bigint; signature: Bytes }

export type PhalaMqMessage = { sender: PhalaMqMessageOrigin; destination: PhalaMqTopic; payload: Bytes }

export type PhalaMqMessageOrigin =
  | { type: 'Pallet'; value: Bytes }
  | { type: 'Contract'; value: H256 }
  | { type: 'Worker'; value: SpCoreSr25519Public }
  | { type: 'AccountId'; value: H256 }
  | { type: 'MultiLocation'; value: Bytes }
  | { type: 'Gatekeeper' }
  | { type: 'Cluster'; value: H256 }
  | { type: 'Reserved' }

export type PhalaMqTopic = Bytes

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PhalaPalletsRegistryPalletCall =
  /**
   * See [`Pallet::force_set_benchmark_duration`].
   **/
  | { name: 'ForceSetBenchmarkDuration'; params: { value: number } }
  /**
   * See [`Pallet::force_register_worker`].
   **/
  | {
      name: 'ForceRegisterWorker'
      params: { pubkey: SpCoreSr25519Public; ecdhPubkey: SpCoreSr25519Public; operator?: AccountId32 | undefined }
    }
  /**
   * See [`Pallet::force_register_topic_pubkey`].
   **/
  | { name: 'ForceRegisterTopicPubkey'; params: { topic: Bytes; pubkey: Bytes } }
  /**
   * See [`Pallet::register_gatekeeper`].
   **/
  | { name: 'RegisterGatekeeper'; params: { gatekeeper: SpCoreSr25519Public } }
  /**
   * See [`Pallet::unregister_gatekeeper`].
   **/
  | { name: 'UnregisterGatekeeper'; params: { gatekeeper: SpCoreSr25519Public } }
  /**
   * See [`Pallet::rotate_master_key`].
   **/
  | { name: 'RotateMasterKey' }
  /**
   * See [`Pallet::register_worker`].
   **/
  | {
      name: 'RegisterWorker'
      params: {
        pruntimeInfo: PhalaTypesWorkerRegistrationInfo
        attestation: PhalaPalletsUtilsAttestationLegacyAttestation
      }
    }
  /**
   * See [`Pallet::register_worker_v2`].
   **/
  | {
      name: 'RegisterWorkerV2'
      params: {
        pruntimeInfo: PhalaTypesWorkerRegistrationInfoV2
        attestation?: PhalaTypesAttestationReport | undefined
      }
    }
  /**
   * See [`Pallet::update_worker_endpoint`].
   **/
  | { name: 'UpdateWorkerEndpoint'; params: { endpointPayload: PhalaTypesWorkerEndpointPayload; signature: Bytes } }
  /**
   * See [`Pallet::add_pruntime`].
   **/
  | { name: 'AddPruntime'; params: { pruntimeHash: Bytes } }
  /**
   * See [`Pallet::remove_pruntime`].
   **/
  | { name: 'RemovePruntime'; params: { pruntimeHash: Bytes } }
  /**
   * See [`Pallet::add_relaychain_genesis_block_hash`].
   **/
  | { name: 'AddRelaychainGenesisBlockHash'; params: { genesisBlockHash: H256 } }
  /**
   * See [`Pallet::remove_relaychain_genesis_block_hash`].
   **/
  | { name: 'RemoveRelaychainGenesisBlockHash'; params: { genesisBlockHash: H256 } }
  /**
   * See [`Pallet::set_minimum_pruntime_version`].
   **/
  | { name: 'SetMinimumPruntimeVersion'; params: { major: number; minor: number; patch: number } }
  /**
   * See [`Pallet::set_pruntime_consensus_version`].
   **/
  | { name: 'SetPruntimeConsensusVersion'; params: { version: number } }

export type PhalaPalletsRegistryPalletCallLike =
  /**
   * See [`Pallet::force_set_benchmark_duration`].
   **/
  | { name: 'ForceSetBenchmarkDuration'; params: { value: number } }
  /**
   * See [`Pallet::force_register_worker`].
   **/
  | {
      name: 'ForceRegisterWorker'
      params: { pubkey: SpCoreSr25519Public; ecdhPubkey: SpCoreSr25519Public; operator?: AccountId32Like | undefined }
    }
  /**
   * See [`Pallet::force_register_topic_pubkey`].
   **/
  | { name: 'ForceRegisterTopicPubkey'; params: { topic: BytesLike; pubkey: BytesLike } }
  /**
   * See [`Pallet::register_gatekeeper`].
   **/
  | { name: 'RegisterGatekeeper'; params: { gatekeeper: SpCoreSr25519Public } }
  /**
   * See [`Pallet::unregister_gatekeeper`].
   **/
  | { name: 'UnregisterGatekeeper'; params: { gatekeeper: SpCoreSr25519Public } }
  /**
   * See [`Pallet::rotate_master_key`].
   **/
  | { name: 'RotateMasterKey' }
  /**
   * See [`Pallet::register_worker`].
   **/
  | {
      name: 'RegisterWorker'
      params: {
        pruntimeInfo: PhalaTypesWorkerRegistrationInfo
        attestation: PhalaPalletsUtilsAttestationLegacyAttestation
      }
    }
  /**
   * See [`Pallet::register_worker_v2`].
   **/
  | {
      name: 'RegisterWorkerV2'
      params: {
        pruntimeInfo: PhalaTypesWorkerRegistrationInfoV2
        attestation?: PhalaTypesAttestationReport | undefined
      }
    }
  /**
   * See [`Pallet::update_worker_endpoint`].
   **/
  | { name: 'UpdateWorkerEndpoint'; params: { endpointPayload: PhalaTypesWorkerEndpointPayload; signature: BytesLike } }
  /**
   * See [`Pallet::add_pruntime`].
   **/
  | { name: 'AddPruntime'; params: { pruntimeHash: BytesLike } }
  /**
   * See [`Pallet::remove_pruntime`].
   **/
  | { name: 'RemovePruntime'; params: { pruntimeHash: BytesLike } }
  /**
   * See [`Pallet::add_relaychain_genesis_block_hash`].
   **/
  | { name: 'AddRelaychainGenesisBlockHash'; params: { genesisBlockHash: H256 } }
  /**
   * See [`Pallet::remove_relaychain_genesis_block_hash`].
   **/
  | { name: 'RemoveRelaychainGenesisBlockHash'; params: { genesisBlockHash: H256 } }
  /**
   * See [`Pallet::set_minimum_pruntime_version`].
   **/
  | { name: 'SetMinimumPruntimeVersion'; params: { major: number; minor: number; patch: number } }
  /**
   * See [`Pallet::set_pruntime_consensus_version`].
   **/
  | { name: 'SetPruntimeConsensusVersion'; params: { version: number } }

export type PhalaTypesWorkerRegistrationInfo = {
  version: number
  machineId: Bytes
  pubkey: SpCoreSr25519Public
  ecdhPubkey: SpCoreSr25519Public
  genesisBlockHash: H256
  features: Array<number>
  operator?: AccountId32 | undefined
}

export type PhalaPalletsUtilsAttestationLegacyAttestation = {
  type: 'SgxIas'
  value: { raReport: Bytes; signature: Bytes; rawSigningCert: Bytes }
}

export type PhalaTypesWorkerRegistrationInfoV2 = {
  version: number
  machineId: Bytes
  pubkey: SpCoreSr25519Public
  ecdhPubkey: SpCoreSr25519Public
  genesisBlockHash: H256
  features: Array<number>
  operator?: AccountId32 | undefined
  paraId: number
  maxConsensusVersion: number
}

export type PhalaTypesAttestationReport =
  | { type: 'SgxIas'; value: { raReport: Bytes; signature: Bytes; rawSigningCert: Bytes } }
  | { type: 'SgxDcap'; value: { quote: Bytes; collateral?: PhalaTypesCollateral | undefined } }

export type PhalaTypesCollateral = { type: 'SgxV30'; value: SgxAttestationDcapSgxV30QuoteCollateral }

export type SgxAttestationDcapSgxV30QuoteCollateral = {
  pckCrlIssuerChain: string
  rootCaCrl: string
  pckCrl: string
  tcbInfoIssuerChain: string
  tcbInfo: string
  tcbInfoSignature: Bytes
  qeIdentityIssuerChain: string
  qeIdentity: string
  qeIdentitySignature: Bytes
}

export type PhalaTypesWorkerEndpointPayload = {
  pubkey: SpCoreSr25519Public
  versionedEndpoints: PhalaTypesVersionedWorkerEndpoints
  signingTime: bigint
}

export type PhalaTypesVersionedWorkerEndpoints = { type: 'V1'; value: Array<string> }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PhalaPalletsComputeComputationPalletCall =
  /**
   * See [`Pallet::set_cool_down_expiration`].
   **/
  | { name: 'SetCoolDownExpiration'; params: { period: bigint } }
  /**
   * See [`Pallet::unbind`].
   **/
  | { name: 'Unbind'; params: { session: AccountId32 } }
  /**
   * See [`Pallet::force_heartbeat`].
   **/
  | { name: 'ForceHeartbeat' }
  /**
   * See [`Pallet::force_start_computing`].
   **/
  | { name: 'ForceStartComputing'; params: { session: AccountId32; stake: bigint } }
  /**
   * See [`Pallet::force_stop_computing`].
   **/
  | { name: 'ForceStopComputing'; params: { session: AccountId32 } }
  /**
   * See [`Pallet::update_tokenomic`].
   **/
  | { name: 'UpdateTokenomic'; params: { newParams: PhalaTypesMessagingTokenomicParameters } }
  /**
   * See [`Pallet::set_heartbeat_paused`].
   **/
  | { name: 'SetHeartbeatPaused'; params: { paused: boolean } }
  /**
   * See [`Pallet::set_budget_per_block`].
   **/
  | { name: 'SetBudgetPerBlock'; params: { nonce: bigint; blockNumber: number; budget: bigint } }
  /**
   * See [`Pallet::update_contract_root`].
   **/
  | { name: 'UpdateContractRoot'; params: { accountId: AccountId32 } }

export type PhalaPalletsComputeComputationPalletCallLike =
  /**
   * See [`Pallet::set_cool_down_expiration`].
   **/
  | { name: 'SetCoolDownExpiration'; params: { period: bigint } }
  /**
   * See [`Pallet::unbind`].
   **/
  | { name: 'Unbind'; params: { session: AccountId32Like } }
  /**
   * See [`Pallet::force_heartbeat`].
   **/
  | { name: 'ForceHeartbeat' }
  /**
   * See [`Pallet::force_start_computing`].
   **/
  | { name: 'ForceStartComputing'; params: { session: AccountId32Like; stake: bigint } }
  /**
   * See [`Pallet::force_stop_computing`].
   **/
  | { name: 'ForceStopComputing'; params: { session: AccountId32Like } }
  /**
   * See [`Pallet::update_tokenomic`].
   **/
  | { name: 'UpdateTokenomic'; params: { newParams: PhalaTypesMessagingTokenomicParameters } }
  /**
   * See [`Pallet::set_heartbeat_paused`].
   **/
  | { name: 'SetHeartbeatPaused'; params: { paused: boolean } }
  /**
   * See [`Pallet::set_budget_per_block`].
   **/
  | { name: 'SetBudgetPerBlock'; params: { nonce: bigint; blockNumber: number; budget: bigint } }
  /**
   * See [`Pallet::update_contract_root`].
   **/
  | { name: 'UpdateContractRoot'; params: { accountId: AccountId32Like } }

export type PhalaTypesMessagingTokenomicParameters = {
  phaRate: bigint
  rho: bigint
  budgetPerBlock: bigint
  vMax: bigint
  costK: bigint
  costB: bigint
  slashRate: bigint
  treasuryRatio: bigint
  heartbeatWindow: number
  rigK: bigint
  rigB: bigint
  re: bigint
  k: bigint
  kappa: bigint
}

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PhalaPalletsComputeStakePoolV2PalletCall =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create' }
  /**
   * See [`Pallet::add_worker`].
   **/
  | { name: 'AddWorker'; params: { pid: bigint; pubkey: SpCoreSr25519Public } }
  /**
   * See [`Pallet::remove_worker`].
   **/
  | { name: 'RemoveWorker'; params: { pid: bigint; worker: SpCoreSr25519Public } }
  /**
   * See [`Pallet::set_cap`].
   **/
  | { name: 'SetCap'; params: { pid: bigint; cap: bigint } }
  /**
   * See [`Pallet::set_payout_pref`].
   **/
  | { name: 'SetPayoutPref'; params: { pid: bigint; payoutCommission?: Permill | undefined } }
  /**
   * See [`Pallet::claim_legacy_rewards`].
   **/
  | { name: 'ClaimLegacyRewards'; params: { pid: bigint; target: AccountId32 } }
  /**
   * See [`Pallet::claim_owner_rewards`].
   **/
  | { name: 'ClaimOwnerRewards'; params: { pid: bigint; target: AccountId32 } }
  /**
   * See [`Pallet::check_and_maybe_force_withdraw`].
   **/
  | { name: 'CheckAndMaybeForceWithdraw'; params: { pid: bigint } }
  /**
   * See [`Pallet::contribute`].
   **/
  | { name: 'Contribute'; params: { pid: bigint; amount: bigint; asVault?: bigint | undefined } }
  /**
   * See [`Pallet::withdraw`].
   **/
  | { name: 'Withdraw'; params: { pid: bigint; shares: bigint; asVault?: bigint | undefined } }
  /**
   * See [`Pallet::start_computing`].
   **/
  | { name: 'StartComputing'; params: { pid: bigint; worker: SpCoreSr25519Public; stake: bigint } }
  /**
   * See [`Pallet::stop_computing`].
   **/
  | { name: 'StopComputing'; params: { pid: bigint; worker: SpCoreSr25519Public } }
  /**
   * See [`Pallet::reclaim_pool_worker`].
   **/
  | { name: 'ReclaimPoolWorker'; params: { pid: bigint; worker: SpCoreSr25519Public } }
  /**
   * See [`Pallet::restart_computing`].
   **/
  | { name: 'RestartComputing'; params: { pid: bigint; worker: SpCoreSr25519Public; stake: bigint } }

export type PhalaPalletsComputeStakePoolV2PalletCallLike =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create' }
  /**
   * See [`Pallet::add_worker`].
   **/
  | { name: 'AddWorker'; params: { pid: bigint; pubkey: SpCoreSr25519Public } }
  /**
   * See [`Pallet::remove_worker`].
   **/
  | { name: 'RemoveWorker'; params: { pid: bigint; worker: SpCoreSr25519Public } }
  /**
   * See [`Pallet::set_cap`].
   **/
  | { name: 'SetCap'; params: { pid: bigint; cap: bigint } }
  /**
   * See [`Pallet::set_payout_pref`].
   **/
  | { name: 'SetPayoutPref'; params: { pid: bigint; payoutCommission?: Permill | undefined } }
  /**
   * See [`Pallet::claim_legacy_rewards`].
   **/
  | { name: 'ClaimLegacyRewards'; params: { pid: bigint; target: AccountId32Like } }
  /**
   * See [`Pallet::claim_owner_rewards`].
   **/
  | { name: 'ClaimOwnerRewards'; params: { pid: bigint; target: AccountId32Like } }
  /**
   * See [`Pallet::check_and_maybe_force_withdraw`].
   **/
  | { name: 'CheckAndMaybeForceWithdraw'; params: { pid: bigint } }
  /**
   * See [`Pallet::contribute`].
   **/
  | { name: 'Contribute'; params: { pid: bigint; amount: bigint; asVault?: bigint | undefined } }
  /**
   * See [`Pallet::withdraw`].
   **/
  | { name: 'Withdraw'; params: { pid: bigint; shares: bigint; asVault?: bigint | undefined } }
  /**
   * See [`Pallet::start_computing`].
   **/
  | { name: 'StartComputing'; params: { pid: bigint; worker: SpCoreSr25519Public; stake: bigint } }
  /**
   * See [`Pallet::stop_computing`].
   **/
  | { name: 'StopComputing'; params: { pid: bigint; worker: SpCoreSr25519Public } }
  /**
   * See [`Pallet::reclaim_pool_worker`].
   **/
  | { name: 'ReclaimPoolWorker'; params: { pid: bigint; worker: SpCoreSr25519Public } }
  /**
   * See [`Pallet::restart_computing`].
   **/
  | { name: 'RestartComputing'; params: { pid: bigint; worker: SpCoreSr25519Public; stake: bigint } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PhalaPalletsComputeVaultPalletCall =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create' }
  /**
   * See [`Pallet::set_payout_pref`].
   **/
  | { name: 'SetPayoutPref'; params: { pid: bigint; payoutCommission?: Permill | undefined } }
  /**
   * See [`Pallet::claim_owner_shares`].
   **/
  | { name: 'ClaimOwnerShares'; params: { vaultPid: bigint; target: AccountId32; shares: bigint } }
  /**
   * See [`Pallet::maybe_gain_owner_shares`].
   **/
  | { name: 'MaybeGainOwnerShares'; params: { vaultPid: bigint } }
  /**
   * See [`Pallet::check_and_maybe_force_withdraw`].
   **/
  | { name: 'CheckAndMaybeForceWithdraw'; params: { vaultPid: bigint } }
  /**
   * See [`Pallet::contribute`].
   **/
  | { name: 'Contribute'; params: { pid: bigint; amount: bigint } }
  /**
   * See [`Pallet::withdraw`].
   **/
  | { name: 'Withdraw'; params: { pid: bigint; shares: bigint } }

export type PhalaPalletsComputeVaultPalletCallLike =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create' }
  /**
   * See [`Pallet::set_payout_pref`].
   **/
  | { name: 'SetPayoutPref'; params: { pid: bigint; payoutCommission?: Permill | undefined } }
  /**
   * See [`Pallet::claim_owner_shares`].
   **/
  | { name: 'ClaimOwnerShares'; params: { vaultPid: bigint; target: AccountId32Like; shares: bigint } }
  /**
   * See [`Pallet::maybe_gain_owner_shares`].
   **/
  | { name: 'MaybeGainOwnerShares'; params: { vaultPid: bigint } }
  /**
   * See [`Pallet::check_and_maybe_force_withdraw`].
   **/
  | { name: 'CheckAndMaybeForceWithdraw'; params: { vaultPid: bigint } }
  /**
   * See [`Pallet::contribute`].
   **/
  | { name: 'Contribute'; params: { pid: bigint; amount: bigint } }
  /**
   * See [`Pallet::withdraw`].
   **/
  | { name: 'Withdraw'; params: { pid: bigint; shares: bigint } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PhalaPalletsComputeWrappedBalancesPalletCall =
  /**
   * See [`Pallet::wrap`].
   **/
  | { name: 'Wrap'; params: { amount: bigint } }
  /**
   * See [`Pallet::unwrap_all`].
   **/
  | { name: 'UnwrapAll' }
  /**
   * See [`Pallet::unwrap`].
   **/
  | { name: 'Unwrap'; params: { amount: bigint } }
  /**
   * See [`Pallet::vote`].
   **/
  | { name: 'Vote'; params: { ayeAmount: bigint; nayAmount: bigint; voteId: number } }
  /**
   * See [`Pallet::unlock`].
   **/
  | { name: 'Unlock'; params: { voteId: number; maxIterations: number } }

export type PhalaPalletsComputeWrappedBalancesPalletCallLike =
  /**
   * See [`Pallet::wrap`].
   **/
  | { name: 'Wrap'; params: { amount: bigint } }
  /**
   * See [`Pallet::unwrap_all`].
   **/
  | { name: 'UnwrapAll' }
  /**
   * See [`Pallet::unwrap`].
   **/
  | { name: 'Unwrap'; params: { amount: bigint } }
  /**
   * See [`Pallet::vote`].
   **/
  | { name: 'Vote'; params: { ayeAmount: bigint; nayAmount: bigint; voteId: number } }
  /**
   * See [`Pallet::unlock`].
   **/
  | { name: 'Unlock'; params: { voteId: number; maxIterations: number } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PhalaPalletsComputeBasePoolPalletCall =
  /**
   * See [`Pallet::add_staker_to_whitelist`].
   **/
  | { name: 'AddStakerToWhitelist'; params: { pid: bigint; staker: AccountId32 } }
  /**
   * See [`Pallet::set_pool_description`].
   **/
  | { name: 'SetPoolDescription'; params: { pid: bigint; description: Bytes } }
  /**
   * See [`Pallet::remove_staker_from_whitelist`].
   **/
  | { name: 'RemoveStakerFromWhitelist'; params: { pid: bigint; staker: AccountId32 } }
  /**
   * See [`Pallet::claim_reimbursement`].
   **/
  | { name: 'ClaimReimbursement'; params: { pid: bigint; target: AccountId32 } }
  /**
   * See [`Pallet::set_reimbursements`].
   **/
  | { name: 'SetReimbursements'; params: { input: Array<[AccountId32, bigint, bigint]>; add: boolean } }

export type PhalaPalletsComputeBasePoolPalletCallLike =
  /**
   * See [`Pallet::add_staker_to_whitelist`].
   **/
  | { name: 'AddStakerToWhitelist'; params: { pid: bigint; staker: AccountId32Like } }
  /**
   * See [`Pallet::set_pool_description`].
   **/
  | { name: 'SetPoolDescription'; params: { pid: bigint; description: BytesLike } }
  /**
   * See [`Pallet::remove_staker_from_whitelist`].
   **/
  | { name: 'RemoveStakerFromWhitelist'; params: { pid: bigint; staker: AccountId32Like } }
  /**
   * See [`Pallet::claim_reimbursement`].
   **/
  | { name: 'ClaimReimbursement'; params: { pid: bigint; target: AccountId32Like } }
  /**
   * See [`Pallet::set_reimbursements`].
   **/
  | { name: 'SetReimbursements'; params: { input: Array<[AccountId32Like, bigint, bigint]>; add: boolean } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PhalaPalletsPhatPalletCall =
  /**
   * See [`Pallet::add_cluster`].
   **/
  | {
      name: 'AddCluster'
      params: {
        owner: AccountId32
        permission: PhalaTypesContractClusterPermission
        deployWorkers: Array<SpCoreSr25519Public>
        deposit: bigint
        gasPrice: bigint
        depositPerItem: bigint
        depositPerByte: bigint
        treasuryAccount: AccountId32
      }
    }
  /**
   * See [`Pallet::cluster_upload_resource`].
   **/
  | {
      name: 'ClusterUploadResource'
      params: { clusterId: H256; resourceType: PhalaTypesContractMessagingResourceType; resourceData: Bytes }
    }
  /**
   * See [`Pallet::transfer_to_cluster`].
   **/
  | { name: 'TransferToCluster'; params: { amount: bigint; clusterId: H256; destAccount: AccountId32 } }
  /**
   * See [`Pallet::push_contract_message`].
   **/
  | { name: 'PushContractMessage'; params: { contractId: H256; payload: Bytes; deposit: bigint } }
  /**
   * See [`Pallet::instantiate_contract`].
   **/
  | {
      name: 'InstantiateContract'
      params: {
        codeIndex: PhalaTypesContractCodeIndex
        data: Bytes
        salt: Bytes
        clusterId: H256
        transfer: bigint
        gasLimit: bigint
        storageDepositLimit?: bigint | undefined
        deposit: bigint
      }
    }
  /**
   * See [`Pallet::cluster_destroy`].
   **/
  | { name: 'ClusterDestroy'; params: { cluster: H256 } }
  /**
   * See [`Pallet::set_pink_system_code`].
   **/
  | { name: 'SetPinkSystemCode'; params: { code: Bytes } }
  /**
   * See [`Pallet::set_pink_runtime_version`].
   **/
  | { name: 'SetPinkRuntimeVersion'; params: { version: [number, number] } }
  /**
   * See [`Pallet::add_worker_to_cluster`].
   **/
  | { name: 'AddWorkerToCluster'; params: { workerPubkey: SpCoreSr25519Public; clusterId: H256 } }
  /**
   * See [`Pallet::remove_worker_from_cluster`].
   **/
  | { name: 'RemoveWorkerFromCluster'; params: { workerPubkey: SpCoreSr25519Public; clusterId: H256 } }
  /**
   * See [`Pallet::cleanup_removed_workers`].
   **/
  | { name: 'CleanupRemovedWorkers'; params: { clusterId: H256 } }

export type PhalaPalletsPhatPalletCallLike =
  /**
   * See [`Pallet::add_cluster`].
   **/
  | {
      name: 'AddCluster'
      params: {
        owner: AccountId32Like
        permission: PhalaTypesContractClusterPermission
        deployWorkers: Array<SpCoreSr25519Public>
        deposit: bigint
        gasPrice: bigint
        depositPerItem: bigint
        depositPerByte: bigint
        treasuryAccount: AccountId32Like
      }
    }
  /**
   * See [`Pallet::cluster_upload_resource`].
   **/
  | {
      name: 'ClusterUploadResource'
      params: { clusterId: H256; resourceType: PhalaTypesContractMessagingResourceType; resourceData: BytesLike }
    }
  /**
   * See [`Pallet::transfer_to_cluster`].
   **/
  | { name: 'TransferToCluster'; params: { amount: bigint; clusterId: H256; destAccount: AccountId32Like } }
  /**
   * See [`Pallet::push_contract_message`].
   **/
  | { name: 'PushContractMessage'; params: { contractId: H256; payload: BytesLike; deposit: bigint } }
  /**
   * See [`Pallet::instantiate_contract`].
   **/
  | {
      name: 'InstantiateContract'
      params: {
        codeIndex: PhalaTypesContractCodeIndex
        data: BytesLike
        salt: BytesLike
        clusterId: H256
        transfer: bigint
        gasLimit: bigint
        storageDepositLimit?: bigint | undefined
        deposit: bigint
      }
    }
  /**
   * See [`Pallet::cluster_destroy`].
   **/
  | { name: 'ClusterDestroy'; params: { cluster: H256 } }
  /**
   * See [`Pallet::set_pink_system_code`].
   **/
  | { name: 'SetPinkSystemCode'; params: { code: BytesLike } }
  /**
   * See [`Pallet::set_pink_runtime_version`].
   **/
  | { name: 'SetPinkRuntimeVersion'; params: { version: [number, number] } }
  /**
   * See [`Pallet::add_worker_to_cluster`].
   **/
  | { name: 'AddWorkerToCluster'; params: { workerPubkey: SpCoreSr25519Public; clusterId: H256 } }
  /**
   * See [`Pallet::remove_worker_from_cluster`].
   **/
  | { name: 'RemoveWorkerFromCluster'; params: { workerPubkey: SpCoreSr25519Public; clusterId: H256 } }
  /**
   * See [`Pallet::cleanup_removed_workers`].
   **/
  | { name: 'CleanupRemovedWorkers'; params: { clusterId: H256 } }

export type PhalaTypesContractClusterPermission = { type: 'Public' } | { type: 'OnlyOwner'; value: AccountId32 }

export type PhalaTypesContractMessagingResourceType = 'InkCode' | 'SidevmCode' | 'IndeterministicInkCode'

export type PhalaTypesContractCodeIndex = { type: 'WasmCode'; value: H256 }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PhalaPalletsPhatTokenomicPalletCall =
  /**
   * See [`Pallet::adjust_stake`].
   **/
  { name: 'AdjustStake'; params: { contract: H256; amount: bigint } }

export type PhalaPalletsPhatTokenomicPalletCallLike =
  /**
   * See [`Pallet::adjust_stake`].
   **/
  { name: 'AdjustStake'; params: { contract: H256; amount: bigint } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUniquesCall =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { collection: number; admin: MultiAddress } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { collection: number; owner: MultiAddress; freeHolding: boolean } }
  /**
   * See [`Pallet::destroy`].
   **/
  | { name: 'Destroy'; params: { collection: number; witness: PalletUniquesDestroyWitness } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { collection: number; item: number; owner: MultiAddress } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { collection: number; item: number; checkOwner?: MultiAddress | undefined } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { collection: number; item: number; dest: MultiAddress } }
  /**
   * See [`Pallet::redeposit`].
   **/
  | { name: 'Redeposit'; params: { collection: number; items: Array<number> } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::freeze_collection`].
   **/
  | { name: 'FreezeCollection'; params: { collection: number } }
  /**
   * See [`Pallet::thaw_collection`].
   **/
  | { name: 'ThawCollection'; params: { collection: number } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { collection: number; owner: MultiAddress } }
  /**
   * See [`Pallet::set_team`].
   **/
  | {
      name: 'SetTeam'
      params: { collection: number; issuer: MultiAddress; admin: MultiAddress; freezer: MultiAddress }
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | { name: 'ApproveTransfer'; params: { collection: number; item: number; delegate: MultiAddress } }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | {
      name: 'CancelApproval'
      params: { collection: number; item: number; maybeCheckDelegate?: MultiAddress | undefined }
    }
  /**
   * See [`Pallet::force_item_status`].
   **/
  | {
      name: 'ForceItemStatus'
      params: {
        collection: number
        owner: MultiAddress
        issuer: MultiAddress
        admin: MultiAddress
        freezer: MultiAddress
        freeHolding: boolean
        isFrozen: boolean
      }
    }
  /**
   * See [`Pallet::set_attribute`].
   **/
  | { name: 'SetAttribute'; params: { collection: number; maybeItem?: number | undefined; key: Bytes; value: Bytes } }
  /**
   * See [`Pallet::clear_attribute`].
   **/
  | { name: 'ClearAttribute'; params: { collection: number; maybeItem?: number | undefined; key: Bytes } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { collection: number; item: number; data: Bytes; isFrozen: boolean } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::set_collection_metadata`].
   **/
  | { name: 'SetCollectionMetadata'; params: { collection: number; data: Bytes; isFrozen: boolean } }
  /**
   * See [`Pallet::clear_collection_metadata`].
   **/
  | { name: 'ClearCollectionMetadata'; params: { collection: number } }
  /**
   * See [`Pallet::set_accept_ownership`].
   **/
  | { name: 'SetAcceptOwnership'; params: { maybeCollection?: number | undefined } }
  /**
   * See [`Pallet::set_collection_max_supply`].
   **/
  | { name: 'SetCollectionMaxSupply'; params: { collection: number; maxSupply: number } }
  /**
   * See [`Pallet::set_price`].
   **/
  | {
      name: 'SetPrice'
      params: {
        collection: number
        item: number
        price?: bigint | undefined
        whitelistedBuyer?: MultiAddress | undefined
      }
    }
  /**
   * See [`Pallet::buy_item`].
   **/
  | { name: 'BuyItem'; params: { collection: number; item: number; bidPrice: bigint } }

export type PalletUniquesCallLike =
  /**
   * See [`Pallet::create`].
   **/
  | { name: 'Create'; params: { collection: number; admin: MultiAddressLike } }
  /**
   * See [`Pallet::force_create`].
   **/
  | { name: 'ForceCreate'; params: { collection: number; owner: MultiAddressLike; freeHolding: boolean } }
  /**
   * See [`Pallet::destroy`].
   **/
  | { name: 'Destroy'; params: { collection: number; witness: PalletUniquesDestroyWitness } }
  /**
   * See [`Pallet::mint`].
   **/
  | { name: 'Mint'; params: { collection: number; item: number; owner: MultiAddressLike } }
  /**
   * See [`Pallet::burn`].
   **/
  | { name: 'Burn'; params: { collection: number; item: number; checkOwner?: MultiAddressLike | undefined } }
  /**
   * See [`Pallet::transfer`].
   **/
  | { name: 'Transfer'; params: { collection: number; item: number; dest: MultiAddressLike } }
  /**
   * See [`Pallet::redeposit`].
   **/
  | { name: 'Redeposit'; params: { collection: number; items: Array<number> } }
  /**
   * See [`Pallet::freeze`].
   **/
  | { name: 'Freeze'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::thaw`].
   **/
  | { name: 'Thaw'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::freeze_collection`].
   **/
  | { name: 'FreezeCollection'; params: { collection: number } }
  /**
   * See [`Pallet::thaw_collection`].
   **/
  | { name: 'ThawCollection'; params: { collection: number } }
  /**
   * See [`Pallet::transfer_ownership`].
   **/
  | { name: 'TransferOwnership'; params: { collection: number; owner: MultiAddressLike } }
  /**
   * See [`Pallet::set_team`].
   **/
  | {
      name: 'SetTeam'
      params: { collection: number; issuer: MultiAddressLike; admin: MultiAddressLike; freezer: MultiAddressLike }
    }
  /**
   * See [`Pallet::approve_transfer`].
   **/
  | { name: 'ApproveTransfer'; params: { collection: number; item: number; delegate: MultiAddressLike } }
  /**
   * See [`Pallet::cancel_approval`].
   **/
  | {
      name: 'CancelApproval'
      params: { collection: number; item: number; maybeCheckDelegate?: MultiAddressLike | undefined }
    }
  /**
   * See [`Pallet::force_item_status`].
   **/
  | {
      name: 'ForceItemStatus'
      params: {
        collection: number
        owner: MultiAddressLike
        issuer: MultiAddressLike
        admin: MultiAddressLike
        freezer: MultiAddressLike
        freeHolding: boolean
        isFrozen: boolean
      }
    }
  /**
   * See [`Pallet::set_attribute`].
   **/
  | {
      name: 'SetAttribute'
      params: { collection: number; maybeItem?: number | undefined; key: BytesLike; value: BytesLike }
    }
  /**
   * See [`Pallet::clear_attribute`].
   **/
  | { name: 'ClearAttribute'; params: { collection: number; maybeItem?: number | undefined; key: BytesLike } }
  /**
   * See [`Pallet::set_metadata`].
   **/
  | { name: 'SetMetadata'; params: { collection: number; item: number; data: BytesLike; isFrozen: boolean } }
  /**
   * See [`Pallet::clear_metadata`].
   **/
  | { name: 'ClearMetadata'; params: { collection: number; item: number } }
  /**
   * See [`Pallet::set_collection_metadata`].
   **/
  | { name: 'SetCollectionMetadata'; params: { collection: number; data: BytesLike; isFrozen: boolean } }
  /**
   * See [`Pallet::clear_collection_metadata`].
   **/
  | { name: 'ClearCollectionMetadata'; params: { collection: number } }
  /**
   * See [`Pallet::set_accept_ownership`].
   **/
  | { name: 'SetAcceptOwnership'; params: { maybeCollection?: number | undefined } }
  /**
   * See [`Pallet::set_collection_max_supply`].
   **/
  | { name: 'SetCollectionMaxSupply'; params: { collection: number; maxSupply: number } }
  /**
   * See [`Pallet::set_price`].
   **/
  | {
      name: 'SetPrice'
      params: {
        collection: number
        item: number
        price?: bigint | undefined
        whitelistedBuyer?: MultiAddressLike | undefined
      }
    }
  /**
   * See [`Pallet::buy_item`].
   **/
  | { name: 'BuyItem'; params: { collection: number; item: number; bidPrice: bigint } }

export type PalletUniquesDestroyWitness = { items: number; itemMetadatas: number; attributes: number }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRmrkCoreCall =
  /**
   * See [`Pallet::mint_nft`].
   **/
  | {
      name: 'MintNft'
      params: {
        owner?: AccountId32 | undefined
        nftId: number
        collectionId: number
        royaltyRecipient?: AccountId32 | undefined
        royalty?: Permill | undefined
        metadata: Bytes
        transferable: boolean
        resources?: Array<RmrkTraitsResourceResourceInfoMin> | undefined
      }
    }
  /**
   * See [`Pallet::mint_nft_directly_to_nft`].
   **/
  | {
      name: 'MintNftDirectlyToNft'
      params: {
        owner: [number, number]
        nftId: number
        collectionId: number
        royaltyRecipient?: AccountId32 | undefined
        royalty?: Permill | undefined
        metadata: Bytes
        transferable: boolean
        resources?: Array<RmrkTraitsResourceResourceInfoMin> | undefined
      }
    }
  /**
   * See [`Pallet::create_collection`].
   **/
  | {
      name: 'CreateCollection'
      params: { collectionId: number; metadata: Bytes; max?: number | undefined; symbol: Bytes }
    }
  /**
   * See [`Pallet::burn_nft`].
   **/
  | { name: 'BurnNft'; params: { collectionId: number; nftId: number } }
  /**
   * See [`Pallet::destroy_collection`].
   **/
  | { name: 'DestroyCollection'; params: { collectionId: number } }
  /**
   * See [`Pallet::send`].
   **/
  | {
      name: 'Send'
      params: { collectionId: number; nftId: number; newOwner: RmrkTraitsNftAccountIdOrCollectionNftTuple }
    }
  /**
   * See [`Pallet::accept_nft`].
   **/
  | {
      name: 'AcceptNft'
      params: { collectionId: number; nftId: number; newOwner: RmrkTraitsNftAccountIdOrCollectionNftTuple }
    }
  /**
   * See [`Pallet::reject_nft`].
   **/
  | { name: 'RejectNft'; params: { collectionId: number; nftId: number } }
  /**
   * See [`Pallet::change_collection_issuer`].
   **/
  | { name: 'ChangeCollectionIssuer'; params: { collectionId: number; newIssuer: MultiAddress } }
  /**
   * See [`Pallet::set_property`].
   **/
  | { name: 'SetProperty'; params: { collectionId: number; maybeNftId?: number | undefined; key: Bytes; value: Bytes } }
  /**
   * See [`Pallet::lock_collection`].
   **/
  | { name: 'LockCollection'; params: { collectionId: number } }
  /**
   * See [`Pallet::add_basic_resource`].
   **/
  | {
      name: 'AddBasicResource'
      params: { collectionId: number; nftId: number; resource: RmrkTraitsResourceBasicResource; resourceId: number }
    }
  /**
   * See [`Pallet::add_composable_resource`].
   **/
  | {
      name: 'AddComposableResource'
      params: {
        collectionId: number
        nftId: number
        resource: RmrkTraitsResourceComposableResource
        resourceId: number
      }
    }
  /**
   * See [`Pallet::add_slot_resource`].
   **/
  | {
      name: 'AddSlotResource'
      params: { collectionId: number; nftId: number; resource: RmrkTraitsResourceSlotResource; resourceId: number }
    }
  /**
   * See [`Pallet::replace_resource`].
   **/
  | {
      name: 'ReplaceResource'
      params: { collectionId: number; nftId: number; resource: RmrkTraitsResourceResourceTypes; resourceId: number }
    }
  /**
   * See [`Pallet::accept_resource`].
   **/
  | { name: 'AcceptResource'; params: { collectionId: number; nftId: number; resourceId: number } }
  /**
   * See [`Pallet::remove_resource`].
   **/
  | { name: 'RemoveResource'; params: { collectionId: number; nftId: number; resourceId: number } }
  /**
   * See [`Pallet::accept_resource_removal`].
   **/
  | { name: 'AcceptResourceRemoval'; params: { collectionId: number; nftId: number; resourceId: number } }
  /**
   * See [`Pallet::set_priority`].
   **/
  | { name: 'SetPriority'; params: { collectionId: number; nftId: number; priorities: Array<number> } }

export type PalletRmrkCoreCallLike =
  /**
   * See [`Pallet::mint_nft`].
   **/
  | {
      name: 'MintNft'
      params: {
        owner?: AccountId32Like | undefined
        nftId: number
        collectionId: number
        royaltyRecipient?: AccountId32Like | undefined
        royalty?: Permill | undefined
        metadata: BytesLike
        transferable: boolean
        resources?: Array<RmrkTraitsResourceResourceInfoMin> | undefined
      }
    }
  /**
   * See [`Pallet::mint_nft_directly_to_nft`].
   **/
  | {
      name: 'MintNftDirectlyToNft'
      params: {
        owner: [number, number]
        nftId: number
        collectionId: number
        royaltyRecipient?: AccountId32Like | undefined
        royalty?: Permill | undefined
        metadata: BytesLike
        transferable: boolean
        resources?: Array<RmrkTraitsResourceResourceInfoMin> | undefined
      }
    }
  /**
   * See [`Pallet::create_collection`].
   **/
  | {
      name: 'CreateCollection'
      params: { collectionId: number; metadata: BytesLike; max?: number | undefined; symbol: BytesLike }
    }
  /**
   * See [`Pallet::burn_nft`].
   **/
  | { name: 'BurnNft'; params: { collectionId: number; nftId: number } }
  /**
   * See [`Pallet::destroy_collection`].
   **/
  | { name: 'DestroyCollection'; params: { collectionId: number } }
  /**
   * See [`Pallet::send`].
   **/
  | {
      name: 'Send'
      params: { collectionId: number; nftId: number; newOwner: RmrkTraitsNftAccountIdOrCollectionNftTuple }
    }
  /**
   * See [`Pallet::accept_nft`].
   **/
  | {
      name: 'AcceptNft'
      params: { collectionId: number; nftId: number; newOwner: RmrkTraitsNftAccountIdOrCollectionNftTuple }
    }
  /**
   * See [`Pallet::reject_nft`].
   **/
  | { name: 'RejectNft'; params: { collectionId: number; nftId: number } }
  /**
   * See [`Pallet::change_collection_issuer`].
   **/
  | { name: 'ChangeCollectionIssuer'; params: { collectionId: number; newIssuer: MultiAddressLike } }
  /**
   * See [`Pallet::set_property`].
   **/
  | {
      name: 'SetProperty'
      params: { collectionId: number; maybeNftId?: number | undefined; key: BytesLike; value: BytesLike }
    }
  /**
   * See [`Pallet::lock_collection`].
   **/
  | { name: 'LockCollection'; params: { collectionId: number } }
  /**
   * See [`Pallet::add_basic_resource`].
   **/
  | {
      name: 'AddBasicResource'
      params: { collectionId: number; nftId: number; resource: RmrkTraitsResourceBasicResource; resourceId: number }
    }
  /**
   * See [`Pallet::add_composable_resource`].
   **/
  | {
      name: 'AddComposableResource'
      params: {
        collectionId: number
        nftId: number
        resource: RmrkTraitsResourceComposableResource
        resourceId: number
      }
    }
  /**
   * See [`Pallet::add_slot_resource`].
   **/
  | {
      name: 'AddSlotResource'
      params: { collectionId: number; nftId: number; resource: RmrkTraitsResourceSlotResource; resourceId: number }
    }
  /**
   * See [`Pallet::replace_resource`].
   **/
  | {
      name: 'ReplaceResource'
      params: { collectionId: number; nftId: number; resource: RmrkTraitsResourceResourceTypes; resourceId: number }
    }
  /**
   * See [`Pallet::accept_resource`].
   **/
  | { name: 'AcceptResource'; params: { collectionId: number; nftId: number; resourceId: number } }
  /**
   * See [`Pallet::remove_resource`].
   **/
  | { name: 'RemoveResource'; params: { collectionId: number; nftId: number; resourceId: number } }
  /**
   * See [`Pallet::accept_resource_removal`].
   **/
  | { name: 'AcceptResourceRemoval'; params: { collectionId: number; nftId: number; resourceId: number } }
  /**
   * See [`Pallet::set_priority`].
   **/
  | { name: 'SetPriority'; params: { collectionId: number; nftId: number; priorities: Array<number> } }

export type RmrkTraitsResourceResourceInfoMin = { id: number; resource: RmrkTraitsResourceResourceTypes }

export type RmrkTraitsResourceResourceTypes =
  | { type: 'Basic'; value: RmrkTraitsResourceBasicResource }
  | { type: 'Composable'; value: RmrkTraitsResourceComposableResource }
  | { type: 'Slot'; value: RmrkTraitsResourceSlotResource }

export type RmrkTraitsResourceBasicResource = { metadata: Bytes }

export type RmrkTraitsResourceComposableResource = {
  parts: Array<number>
  base: number
  metadata?: Bytes | undefined
  slot?: [number, number] | undefined
}

export type RmrkTraitsResourceSlotResource = { base: number; metadata?: Bytes | undefined; slot: number }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRmrkEquipCall =
  /**
   * See [`Pallet::change_base_issuer`].
   **/
  | { name: 'ChangeBaseIssuer'; params: { baseId: number; newIssuer: MultiAddress } }
  /**
   * See [`Pallet::equip`].
   **/
  | {
      name: 'Equip'
      params: { item: [number, number]; equipper: [number, number]; resourceId: number; base: number; slot: number }
    }
  /**
   * See [`Pallet::unequip`].
   **/
  | { name: 'Unequip'; params: { item: [number, number]; unequipper: [number, number]; base: number; slot: number } }
  /**
   * See [`Pallet::equippable`].
   **/
  | { name: 'Equippable'; params: { baseId: number; slotId: number; equippables: RmrkTraitsPartEquippableList } }
  /**
   * See [`Pallet::equippable_add`].
   **/
  | { name: 'EquippableAdd'; params: { baseId: number; slotId: number; equippable: number } }
  /**
   * See [`Pallet::equippable_remove`].
   **/
  | { name: 'EquippableRemove'; params: { baseId: number; slotId: number; equippable: number } }
  /**
   * See [`Pallet::theme_add`].
   **/
  | { name: 'ThemeAdd'; params: { baseId: number; theme: RmrkTraitsTheme } }
  /**
   * See [`Pallet::create_base`].
   **/
  | { name: 'CreateBase'; params: { baseType: Bytes; symbol: Bytes; parts: Array<RmrkTraitsPartPartType> } }

export type PalletRmrkEquipCallLike =
  /**
   * See [`Pallet::change_base_issuer`].
   **/
  | { name: 'ChangeBaseIssuer'; params: { baseId: number; newIssuer: MultiAddressLike } }
  /**
   * See [`Pallet::equip`].
   **/
  | {
      name: 'Equip'
      params: { item: [number, number]; equipper: [number, number]; resourceId: number; base: number; slot: number }
    }
  /**
   * See [`Pallet::unequip`].
   **/
  | { name: 'Unequip'; params: { item: [number, number]; unequipper: [number, number]; base: number; slot: number } }
  /**
   * See [`Pallet::equippable`].
   **/
  | { name: 'Equippable'; params: { baseId: number; slotId: number; equippables: RmrkTraitsPartEquippableList } }
  /**
   * See [`Pallet::equippable_add`].
   **/
  | { name: 'EquippableAdd'; params: { baseId: number; slotId: number; equippable: number } }
  /**
   * See [`Pallet::equippable_remove`].
   **/
  | { name: 'EquippableRemove'; params: { baseId: number; slotId: number; equippable: number } }
  /**
   * See [`Pallet::theme_add`].
   **/
  | { name: 'ThemeAdd'; params: { baseId: number; theme: RmrkTraitsTheme } }
  /**
   * See [`Pallet::create_base`].
   **/
  | { name: 'CreateBase'; params: { baseType: BytesLike; symbol: BytesLike; parts: Array<RmrkTraitsPartPartType> } }

export type RmrkTraitsPartEquippableList =
  | { type: 'All' }
  | { type: 'Empty' }
  | { type: 'Custom'; value: Array<number> }

export type RmrkTraitsTheme = { name: Bytes; properties: Array<RmrkTraitsThemeThemeProperty>; inherit: boolean }

export type RmrkTraitsThemeThemeProperty = { key: Bytes; value: Bytes }

export type RmrkTraitsPartPartType =
  | { type: 'FixedPart'; value: RmrkTraitsPartFixedPart }
  | { type: 'SlotPart'; value: RmrkTraitsPartSlotPart }

export type RmrkTraitsPartFixedPart = { id: number; z: number; src: Bytes }

export type RmrkTraitsPartSlotPart = {
  id: number
  equippable: RmrkTraitsPartEquippableList
  src?: Bytes | undefined
  z: number
}

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRmrkMarketCall =
  /**
   * See [`Pallet::buy`].
   **/
  | { name: 'Buy'; params: { collectionId: number; nftId: number; amount?: bigint | undefined } }
  /**
   * See [`Pallet::list`].
   **/
  | { name: 'List'; params: { collectionId: number; nftId: number; amount: bigint; expires?: number | undefined } }
  /**
   * See [`Pallet::unlist`].
   **/
  | { name: 'Unlist'; params: { collectionId: number; nftId: number } }
  /**
   * See [`Pallet::make_offer`].
   **/
  | { name: 'MakeOffer'; params: { collectionId: number; nftId: number; amount: bigint; expires?: number | undefined } }
  /**
   * See [`Pallet::withdraw_offer`].
   **/
  | { name: 'WithdrawOffer'; params: { collectionId: number; nftId: number } }
  /**
   * See [`Pallet::accept_offer`].
   **/
  | { name: 'AcceptOffer'; params: { collectionId: number; nftId: number; offerer: AccountId32 } }

export type PalletRmrkMarketCallLike =
  /**
   * See [`Pallet::buy`].
   **/
  | { name: 'Buy'; params: { collectionId: number; nftId: number; amount?: bigint | undefined } }
  /**
   * See [`Pallet::list`].
   **/
  | { name: 'List'; params: { collectionId: number; nftId: number; amount: bigint; expires?: number | undefined } }
  /**
   * See [`Pallet::unlist`].
   **/
  | { name: 'Unlist'; params: { collectionId: number; nftId: number } }
  /**
   * See [`Pallet::make_offer`].
   **/
  | { name: 'MakeOffer'; params: { collectionId: number; nftId: number; amount: bigint; expires?: number | undefined } }
  /**
   * See [`Pallet::withdraw_offer`].
   **/
  | { name: 'WithdrawOffer'; params: { collectionId: number; nftId: number } }
  /**
   * See [`Pallet::accept_offer`].
   **/
  | { name: 'AcceptOffer'; params: { collectionId: number; nftId: number; offerer: AccountId32Like } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type SygmaAccessSegregatorCall =
  /**
   * See [`Pallet::grant_access`].
   **/
  { name: 'GrantAccess'; params: { palletIndex: number; extrinsicName: Bytes; who: AccountId32 } }

export type SygmaAccessSegregatorCallLike =
  /**
   * See [`Pallet::grant_access`].
   **/
  { name: 'GrantAccess'; params: { palletIndex: number; extrinsicName: BytesLike; who: AccountId32Like } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type SygmaBasicFeehandlerCall =
  /**
   * See [`Pallet::set_fee`].
   **/
  { name: 'SetFee'; params: { domain: number; asset: StagingXcmV3MultiassetAssetId; amount: bigint } }

export type SygmaBasicFeehandlerCallLike =
  /**
   * See [`Pallet::set_fee`].
   **/
  { name: 'SetFee'; params: { domain: number; asset: StagingXcmV3MultiassetAssetId; amount: bigint } }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type SygmaBridgeCall =
  /**
   * See [`Pallet::pause_bridge`].
   **/
  | { name: 'PauseBridge'; params: { destDomainId: number } }
  /**
   * See [`Pallet::unpause_bridge`].
   **/
  | { name: 'UnpauseBridge'; params: { destDomainId: number } }
  /**
   * See [`Pallet::set_mpc_address`].
   **/
  | { name: 'SetMpcAddress'; params: { addr: SygmaTraitsMpcAddress } }
  /**
   * See [`Pallet::register_domain`].
   **/
  | { name: 'RegisterDomain'; params: { destDomainId: number; destChainId: U256 } }
  /**
   * See [`Pallet::unregister_domain`].
   **/
  | { name: 'UnregisterDomain'; params: { destDomainId: number; destChainId: U256 } }
  /**
   * See [`Pallet::deposit`].
   **/
  | {
      name: 'Deposit'
      params: { asset: StagingXcmV3MultiassetMultiAsset; dest: StagingXcmV3MultilocationMultiLocation }
    }
  /**
   * See [`Pallet::retry`].
   **/
  | { name: 'Retry'; params: { depositOnBlockHeight: bigint; destDomainId: number } }
  /**
   * See [`Pallet::execute_proposal`].
   **/
  | { name: 'ExecuteProposal'; params: { proposals: Array<SygmaBridgeProposal>; signature: Bytes } }
  /**
   * See [`Pallet::pause_all_bridges`].
   **/
  | { name: 'PauseAllBridges' }
  /**
   * See [`Pallet::unpause_all_bridges`].
   **/
  | { name: 'UnpauseAllBridges' }

export type SygmaBridgeCallLike =
  /**
   * See [`Pallet::pause_bridge`].
   **/
  | { name: 'PauseBridge'; params: { destDomainId: number } }
  /**
   * See [`Pallet::unpause_bridge`].
   **/
  | { name: 'UnpauseBridge'; params: { destDomainId: number } }
  /**
   * See [`Pallet::set_mpc_address`].
   **/
  | { name: 'SetMpcAddress'; params: { addr: SygmaTraitsMpcAddress } }
  /**
   * See [`Pallet::register_domain`].
   **/
  | { name: 'RegisterDomain'; params: { destDomainId: number; destChainId: U256 } }
  /**
   * See [`Pallet::unregister_domain`].
   **/
  | { name: 'UnregisterDomain'; params: { destDomainId: number; destChainId: U256 } }
  /**
   * See [`Pallet::deposit`].
   **/
  | {
      name: 'Deposit'
      params: { asset: StagingXcmV3MultiassetMultiAsset; dest: StagingXcmV3MultilocationMultiLocation }
    }
  /**
   * See [`Pallet::retry`].
   **/
  | { name: 'Retry'; params: { depositOnBlockHeight: bigint; destDomainId: number } }
  /**
   * See [`Pallet::execute_proposal`].
   **/
  | { name: 'ExecuteProposal'; params: { proposals: Array<SygmaBridgeProposal>; signature: BytesLike } }
  /**
   * See [`Pallet::pause_all_bridges`].
   **/
  | { name: 'PauseAllBridges' }
  /**
   * See [`Pallet::unpause_all_bridges`].
   **/
  | { name: 'UnpauseAllBridges' }

export type SygmaTraitsMpcAddress = FixedBytes<20>

export type SygmaBridgeProposal = {
  originDomainId: number
  depositNonce: bigint
  resourceId: FixedBytes<32>
  data: Bytes
}

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type SygmaFeeHandlerRouterCall =
  /**
   * See [`Pallet::set_fee_handler`].
   **/
  {
    name: 'SetFeeHandler'
    params: { domain: number; asset: StagingXcmV3MultiassetAssetId; handlerType: SygmaFeeHandlerRouterFeeHandlerType }
  }

export type SygmaFeeHandlerRouterCallLike =
  /**
   * See [`Pallet::set_fee_handler`].
   **/
  {
    name: 'SetFeeHandler'
    params: { domain: number; asset: StagingXcmV3MultiassetAssetId; handlerType: SygmaFeeHandlerRouterFeeHandlerType }
  }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type SygmaPercentageFeehandlerCall =
  /**
   * See [`Pallet::set_fee_rate`].
   **/
  {
    name: 'SetFeeRate'
    params: {
      domain: number
      asset: StagingXcmV3MultiassetAssetId
      feeRateBasisPoint: number
      feeLowerBound: bigint
      feeUpperBound: bigint
    }
  }

export type SygmaPercentageFeehandlerCallLike =
  /**
   * See [`Pallet::set_fee_rate`].
   **/
  {
    name: 'SetFeeRate'
    params: {
      domain: number
      asset: StagingXcmV3MultiassetAssetId
      feeRateBasisPoint: number
      feeLowerBound: bigint
      feeUpperBound: bigint
    }
  }

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletIndexCall =
  /**
   * See [`Pallet::force_add_worker`].
   **/
  | { name: 'ForceAddWorker'; params: { worker: AccountId32 } }
  /**
   * See [`Pallet::force_remove_worker`].
   **/
  | { name: 'ForceRemoveWorker'; params: { worker: AccountId32 } }
  /**
   * See [`Pallet::deposit_task`].
   **/
  | {
      name: 'DepositTask'
      params: {
        asset: StagingXcmV3MultiassetAssetId
        amount: bigint
        recipient: Bytes
        worker: AccountId32
        taskId: FixedBytes<32>
        task: Bytes
      }
    }
  /**
   * See [`Pallet::claim_task`].
   **/
  | { name: 'ClaimTask'; params: { taskId: FixedBytes<32>; fee: bigint } }

export type PalletIndexCallLike =
  /**
   * See [`Pallet::force_add_worker`].
   **/
  | { name: 'ForceAddWorker'; params: { worker: AccountId32Like } }
  /**
   * See [`Pallet::force_remove_worker`].
   **/
  | { name: 'ForceRemoveWorker'; params: { worker: AccountId32Like } }
  /**
   * See [`Pallet::deposit_task`].
   **/
  | {
      name: 'DepositTask'
      params: {
        asset: StagingXcmV3MultiassetAssetId
        amount: bigint
        recipient: BytesLike
        worker: AccountId32Like
        taskId: FixedBytes<32>
        task: BytesLike
      }
    }
  /**
   * See [`Pallet::claim_task`].
   **/
  | { name: 'ClaimTask'; params: { taskId: FixedBytes<32>; fee: bigint } }

export type PhalaParachainRuntimeOriginCaller =
  | { type: 'System'; value: FrameSupportDispatchRawOrigin }
  | { type: 'CumulusXcm'; value: CumulusPalletXcmOrigin }
  | { type: 'PolkadotXcm'; value: PalletXcmOrigin }
  | { type: 'Council'; value: PalletCollectiveRawOrigin }
  | { type: 'TechnicalCommittee'; value: PalletCollectiveRawOrigin }
  | { type: 'Void'; value: SpCoreVoid }

export type FrameSupportDispatchRawOrigin = { type: 'Root' } | { type: 'Signed'; value: AccountId32 } | { type: 'None' }

export type CumulusPalletXcmOrigin =
  | { type: 'Relay' }
  | { type: 'SiblingParachain'; value: PolkadotParachainPrimitivesPrimitivesId }

export type PalletXcmOrigin =
  | { type: 'Xcm'; value: StagingXcmV3MultilocationMultiLocation }
  | { type: 'Response'; value: StagingXcmV3MultilocationMultiLocation }

export type PalletCollectiveRawOrigin =
  | { type: 'Members'; value: [number, number] }
  | { type: 'Member'; value: AccountId32 }
  | { type: 'Phantom' }

export type SpCoreVoid = null

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  'TooManyCalls'

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint
  deposit: bigint
  depositor: AccountId32
  approvals: Array<AccountId32>
}

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | 'MinimumThreshold'
  /**
   * Call is already approved by this signatory.
   **/
  | 'AlreadyApproved'
  /**
   * Call doesn't need any (more) approvals.
   **/
  | 'NoApprovalsNeeded'
  /**
   * There are too few signatories in the list.
   **/
  | 'TooFewSignatories'
  /**
   * There are too many signatories in the list.
   **/
  | 'TooManySignatories'
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | 'SignatoriesOutOfOrder'
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | 'SenderInSignatories'
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | 'NotFound'
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | 'NotOwner'
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | 'NoTimepoint'
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | 'WrongTimepoint'
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | 'UnexpectedTimepoint'
  /**
   * The maximum weight information provided was too low.
   **/
  | 'MaxWeightTooLow'
  /**
   * The data to be stored is already stored.
   **/
  | 'AlreadyStored'

export type PalletProxyProxyDefinition = {
  delegate: AccountId32
  proxyType: PhalaParachainRuntimeProxyType
  delay: number
}

export type PalletProxyAnnouncement = { real: AccountId32; callHash: H256; height: number }

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | 'TooMany'
  /**
   * Proxy registration not found.
   **/
  | 'NotFound'
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | 'NotProxy'
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | 'Unproxyable'
  /**
   * Account is already a proxy.
   **/
  | 'Duplicate'
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | 'NoPermission'
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | 'Unannounced'
  /**
   * Cannot add self as proxy.
   **/
  | 'NoSelfProxy'

export type PalletVestingReleases = 'V0' | 'V1'

/**
 * Error for the vesting pallet.
 **/
export type PalletVestingError =
  /**
   * The account given is not vesting.
   **/
  | 'NotVesting'
  /**
   * The account already has `MaxVestingSchedules` count of schedules and thus
   * cannot add another one. Consider merging existing schedules in order to add another.
   **/
  | 'AtMaxVestingSchedules'
  /**
   * Amount being transferred is too low to create a vesting schedule.
   **/
  | 'AmountLow'
  /**
   * An index was out of bounds of the vesting schedules.
   **/
  | 'ScheduleIndexOutOfBounds'
  /**
   * Failed to create a new schedule because some parameter was invalid.
   **/
  | 'InvalidScheduleParams'

export type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined
  priority: number
  call: FrameSupportPreimagesBounded
  maybePeriodic?: [number, number] | undefined
  origin: PhalaParachainRuntimeOriginCaller
}

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSchedulerError =
  /**
   * Failed to schedule a call
   **/
  | 'FailedToSchedule'
  /**
   * Cannot find the scheduled call.
   **/
  | 'NotFound'
  /**
   * Given target block number is in the past.
   **/
  | 'TargetBlockNumberInPast'
  /**
   * Reschedule failed because it does not change scheduled time.
   **/
  | 'RescheduleNoChange'
  /**
   * Attempt to use a non-named function on a named task.
   **/
  | 'Named'

export type PalletPreimageOldRequestStatus =
  | { type: 'Unrequested'; value: { deposit: [AccountId32, bigint]; len: number } }
  | {
      type: 'Requested'
      value: { deposit?: [AccountId32, bigint] | undefined; count: number; len?: number | undefined }
    }

export type PalletPreimageRequestStatus =
  | { type: 'Unrequested'; value: { ticket: [AccountId32, FrameSupportTokensFungibleHoldConsideration]; len: number } }
  | {
      type: 'Requested'
      value: {
        maybeTicket?: [AccountId32, FrameSupportTokensFungibleHoldConsideration] | undefined
        count: number
        maybeLen?: number | undefined
      }
    }

export type FrameSupportTokensFungibleHoldConsideration = bigint

/**
 * The `Error` enum of this pallet.
 **/
export type PalletPreimageError =
  /**
   * Preimage is too large to store on-chain.
   **/
  | 'TooBig'
  /**
   * Preimage has already been noted on-chain.
   **/
  | 'AlreadyNoted'
  /**
   * The user is not authorized to perform this action.
   **/
  | 'NotAuthorized'
  /**
   * The preimage cannot be removed since it has not yet been noted.
   **/
  | 'NotNoted'
  /**
   * A preimage may not be removed when there are outstanding requests.
   **/
  | 'Requested'
  /**
   * The preimage request cannot be removed since no outstanding requests exist.
   **/
  | 'NotRequested'
  /**
   * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
   **/
  | 'TooMany'
  /**
   * Too few hashes were requested to be upgraded (i.e. zero).
   **/
  | 'TooFew'

export type CumulusPalletParachainSystemUnincludedSegmentAncestor = {
  usedBandwidth: CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth
  paraHeadHash?: H256 | undefined
  consumedGoAheadSignal?: PolkadotPrimitivesV6UpgradeGoAhead | undefined
}

export type CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth = {
  umpMsgCount: number
  umpTotalBytes: number
  hrmpOutgoing: Array<
    [PolkadotParachainPrimitivesPrimitivesId, CumulusPalletParachainSystemUnincludedSegmentHrmpChannelUpdate]
  >
}

export type CumulusPalletParachainSystemUnincludedSegmentHrmpChannelUpdate = { msgCount: number; totalBytes: number }

export type PolkadotPrimitivesV6UpgradeGoAhead = 'Abort' | 'GoAhead'

export type CumulusPalletParachainSystemUnincludedSegmentSegmentTracker = {
  usedBandwidth: CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth
  hrmpWatermark?: number | undefined
  consumedGoAheadSignal?: PolkadotPrimitivesV6UpgradeGoAhead | undefined
}

export type PolkadotPrimitivesV6UpgradeRestriction = 'Present'

export type CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot = {
  dmqMqcHead: H256
  relayDispatchQueueRemainingCapacity: CumulusPalletParachainSystemRelayStateSnapshotRelayDispatchQueueRemainingCapacity
  ingressChannels: Array<[PolkadotParachainPrimitivesPrimitivesId, PolkadotPrimitivesV6AbridgedHrmpChannel]>
  egressChannels: Array<[PolkadotParachainPrimitivesPrimitivesId, PolkadotPrimitivesV6AbridgedHrmpChannel]>
}

export type CumulusPalletParachainSystemRelayStateSnapshotRelayDispatchQueueRemainingCapacity = {
  remainingCount: number
  remainingSize: number
}

export type PolkadotPrimitivesV6AbridgedHrmpChannel = {
  maxCapacity: number
  maxTotalSize: number
  maxMessageSize: number
  msgCount: number
  totalSize: number
  mqcHead?: H256 | undefined
}

export type PolkadotPrimitivesV6AbridgedHostConfiguration = {
  maxCodeSize: number
  maxHeadDataSize: number
  maxUpwardQueueCount: number
  maxUpwardQueueSize: number
  maxUpwardMessageSize: number
  maxUpwardMessageNumPerCandidate: number
  hrmpMaxMessageNumPerCandidate: number
  validationUpgradeCooldown: number
  validationUpgradeDelay: number
  asyncBackingParams: PolkadotPrimitivesV6AsyncBackingAsyncBackingParams
}

export type PolkadotPrimitivesV6AsyncBackingAsyncBackingParams = {
  maxCandidateDepth: number
  allowedAncestryLen: number
}

export type CumulusPrimitivesParachainInherentMessageQueueChain = H256

export type PolkadotCorePrimitivesOutboundHrmpMessage = {
  recipient: PolkadotParachainPrimitivesPrimitivesId
  data: Bytes
}

export type CumulusPalletParachainSystemCodeUpgradeAuthorization = { codeHash: H256; checkVersion: boolean }

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletParachainSystemError =
  /**
   * Attempt to upgrade validation function while existing upgrade pending.
   **/
  | 'OverlappingUpgrades'
  /**
   * Polkadot currently prohibits this parachain from upgrading its validation function.
   **/
  | 'ProhibitedByPolkadot'
  /**
   * The supplied validation function has compiled into a blob larger than Polkadot is
   * willing to run.
   **/
  | 'TooBig'
  /**
   * The inherent which supplies the validation data did not run this block.
   **/
  | 'ValidationDataNotAvailable'
  /**
   * The inherent which supplies the host configuration did not run this block.
   **/
  | 'HostConfigurationNotAvailable'
  /**
   * No validation function upgrade is currently scheduled.
   **/
  | 'NotScheduled'
  /**
   * No code upgrade has been authorized.
   **/
  | 'NothingAuthorized'
  /**
   * The given code upgrade has not been authorized.
   **/
  | 'Unauthorized'

export type CumulusPalletXcmpQueueInboundChannelDetails = {
  sender: PolkadotParachainPrimitivesPrimitivesId
  state: CumulusPalletXcmpQueueInboundState
  messageMetadata: Array<[number, PolkadotParachainPrimitivesPrimitivesXcmpMessageFormat]>
}

export type CumulusPalletXcmpQueueInboundState = 'Ok' | 'Suspended'

export type PolkadotParachainPrimitivesPrimitivesXcmpMessageFormat =
  | 'ConcatenatedVersionedXcm'
  | 'ConcatenatedEncodedBlob'
  | 'Signals'

export type CumulusPalletXcmpQueueOutboundChannelDetails = {
  recipient: PolkadotParachainPrimitivesPrimitivesId
  state: CumulusPalletXcmpQueueOutboundState
  signalsExist: boolean
  firstIndex: number
  lastIndex: number
}

export type CumulusPalletXcmpQueueOutboundState = 'Ok' | 'Suspended'

export type CumulusPalletXcmpQueueQueueConfigData = {
  suspendThreshold: number
  dropThreshold: number
  resumeThreshold: number
  thresholdWeight: SpWeightsWeightV2Weight
  weightRestrictDecay: SpWeightsWeightV2Weight
  xcmpMaxIndividualWeight: SpWeightsWeightV2Weight
}

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletXcmpQueueError =
  /**
   * Failed to send XCM message.
   **/
  | 'FailedToSend'
  /**
   * Bad XCM origin.
   **/
  | 'BadXcmOrigin'
  /**
   * Bad XCM data.
   **/
  | 'BadXcm'
  /**
   * Bad overweight index.
   **/
  | 'BadOverweightIndex'
  /**
   * Provided weight is possibly not enough to execute the message.
   **/
  | 'WeightOverLimit'

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletXcmError = null

export type CumulusPalletDmpQueueConfigData = { maxIndividual: SpWeightsWeightV2Weight }

export type CumulusPalletDmpQueuePageIndexData = { beginUsed: number; endUsed: number; overweightCount: bigint }

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletDmpQueueError =
  /**
   * The message index given is unknown.
   **/
  | 'Unknown'
  /**
   * The amount of weight given is possibly not enough for executing the message.
   **/
  | 'OverLimit'

export type PalletXcmQueryStatus =
  | {
      type: 'Pending'
      value: {
        responder: StagingXcmVersionedMultiLocation
        maybeMatchQuerier?: StagingXcmVersionedMultiLocation | undefined
        maybeNotify?: [number, number] | undefined
        timeout: number
      }
    }
  | { type: 'VersionNotifier'; value: { origin: StagingXcmVersionedMultiLocation; isActive: boolean } }
  | { type: 'Ready'; value: { response: StagingXcmVersionedResponse; at: number } }

export type StagingXcmVersionedResponse =
  | { type: 'V2'; value: StagingXcmV2Response }
  | { type: 'V3'; value: StagingXcmV3Response }

export type PalletXcmVersionMigrationStage =
  | { type: 'MigrateSupportedVersion' }
  | { type: 'MigrateVersionNotifiers' }
  | { type: 'NotifyCurrentTargets'; value?: Bytes | undefined }
  | { type: 'MigrateAndNotifyOldTargets' }

export type StagingXcmVersionedAssetId = { type: 'V3'; value: StagingXcmV3MultiassetAssetId }

export type PalletXcmRemoteLockedFungibleRecord = {
  amount: bigint
  owner: StagingXcmVersionedMultiLocation
  locker: StagingXcmVersionedMultiLocation
  consumers: Array<[[], bigint]>
}

/**
 * The `Error` enum of this pallet.
 **/
export type PalletXcmError =
  /**
   * The desired destination was unreachable, generally because there is a no way of routing
   * to it.
   **/
  | 'Unreachable'
  /**
   * There was some other issue (i.e. not to do with routing) in sending the message.
   * Perhaps a lack of space for buffering the message.
   **/
  | 'SendFailure'
  /**
   * The message execution fails the filter.
   **/
  | 'Filtered'
  /**
   * The message's weight could not be determined.
   **/
  | 'UnweighableMessage'
  /**
   * The destination `MultiLocation` provided cannot be inverted.
   **/
  | 'DestinationNotInvertible'
  /**
   * The assets to be sent are empty.
   **/
  | 'Empty'
  /**
   * Could not re-anchor the assets to declare the fees for the destination chain.
   **/
  | 'CannotReanchor'
  /**
   * Too many assets have been attempted for transfer.
   **/
  | 'TooManyAssets'
  /**
   * Origin is invalid for sending.
   **/
  | 'InvalidOrigin'
  /**
   * The version of the `Versioned` value used is not able to be interpreted.
   **/
  | 'BadVersion'
  /**
   * The given location could not be used (e.g. because it cannot be expressed in the
   * desired version of XCM).
   **/
  | 'BadLocation'
  /**
   * The referenced subscription could not be found.
   **/
  | 'NoSubscription'
  /**
   * The location is invalid since it already has a subscription from us.
   **/
  | 'AlreadySubscribed'
  /**
   * Invalid asset for the operation.
   **/
  | 'InvalidAsset'
  /**
   * The owner does not own (all) of the asset that they wish to do the operation on.
   **/
  | 'LowBalance'
  /**
   * The asset owner has too many locks on the asset.
   **/
  | 'TooManyLocks'
  /**
   * The given account is not an identifiable sovereign account for any location.
   **/
  | 'AccountNotSovereign'
  /**
   * The operation required fees to be paid which the initiator could not meet.
   **/
  | 'FeesNotMet'
  /**
   * A remote lock with the corresponding data could not be found.
   **/
  | 'LockNotFound'
  /**
   * The unlock operation cannot succeed because there are still consumers of the lock.
   **/
  | 'InUse'

export type PalletBalancesBalanceLock = { id: FixedBytes<8>; amount: bigint; reasons: PalletBalancesReasons }

export type PalletBalancesReasons = 'Fee' | 'Misc' | 'All'

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint }

export type PalletBalancesIdAmount = { id: PhalaParachainRuntimeRuntimeHoldReason; amount: bigint }

export type PhalaParachainRuntimeRuntimeHoldReason = { type: 'Preimage'; value: PalletPreimageHoldReason }

export type PalletPreimageHoldReason = 'Preimage'

export type PalletBalancesIdAmount002 = { id: []; amount: bigint }

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | 'VestingBalance'
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | 'LiquidityRestrictions'
  /**
   * Balance too low to send value.
   **/
  | 'InsufficientBalance'
  /**
   * Value too low to create account due to existential deposit.
   **/
  | 'ExistentialDeposit'
  /**
   * Transfer/payment would kill account.
   **/
  | 'Expendability'
  /**
   * A vesting schedule already exists for this account.
   **/
  | 'ExistingVestingSchedule'
  /**
   * Beneficiary account must pre-exist.
   **/
  | 'DeadAccount'
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | 'TooManyReserves'
  /**
   * Number of holds exceed `MaxHolds`.
   **/
  | 'TooManyHolds'
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | 'TooManyFreezes'

export type PalletTransactionPaymentReleases = 'V1Ancient' | 'V2'

export type PalletAssetsAssetDetails = {
  owner: AccountId32
  issuer: AccountId32
  admin: AccountId32
  freezer: AccountId32
  supply: bigint
  deposit: bigint
  minBalance: bigint
  isSufficient: boolean
  accounts: number
  sufficients: number
  approvals: number
  status: PalletAssetsAssetStatus
}

export type PalletAssetsAssetStatus = 'Live' | 'Frozen' | 'Destroying'

export type PalletAssetsAssetAccount = {
  balance: bigint
  status: PalletAssetsAccountStatus
  reason: PalletAssetsExistenceReason
  extra: []
}

export type PalletAssetsAccountStatus = 'Liquid' | 'Frozen' | 'Blocked'

export type PalletAssetsExistenceReason =
  | { type: 'Consumer' }
  | { type: 'Sufficient' }
  | { type: 'DepositHeld'; value: bigint }
  | { type: 'DepositRefunded' }
  | { type: 'DepositFrom'; value: [AccountId32, bigint] }

export type PalletAssetsApproval = { amount: bigint; deposit: bigint }

export type PalletAssetsAssetMetadata = {
  deposit: bigint
  name: Bytes
  symbol: Bytes
  decimals: number
  isFrozen: boolean
}

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetsError =
  /**
   * Account balance must be greater than or equal to the transfer amount.
   **/
  | 'BalanceLow'
  /**
   * The account to alter does not exist.
   **/
  | 'NoAccount'
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given asset ID is unknown.
   **/
  | 'Unknown'
  /**
   * The origin account is frozen.
   **/
  | 'Frozen'
  /**
   * The asset ID is already taken.
   **/
  | 'InUse'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * Minimum balance should be non-zero.
   **/
  | 'MinBalanceZero'
  /**
   * Unable to increment the consumer reference counters on the account. Either no provider
   * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
   * fewer then the maximum number of consumers has been reached.
   **/
  | 'UnavailableConsumer'
  /**
   * Invalid metadata given.
   **/
  | 'BadMetadata'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The source account would not survive the transfer and it needs to stay alive.
   **/
  | 'WouldDie'
  /**
   * The asset-account already exists.
   **/
  | 'AlreadyExists'
  /**
   * The asset-account doesn't have an associated deposit.
   **/
  | 'NoDeposit'
  /**
   * The operation would result in funds being burned.
   **/
  | 'WouldBurn'
  /**
   * The asset is a live asset and is actively being used. Usually emit for operations such
   * as `start_destroy` which require the asset to be in a destroying state.
   **/
  | 'LiveAsset'
  /**
   * The asset is not live, and likely being destroyed.
   **/
  | 'AssetNotLive'
  /**
   * The asset status is not the expected status.
   **/
  | 'IncorrectStatus'
  /**
   * The asset should be frozen before the given operation.
   **/
  | 'NotFrozen'
  /**
   * Callback action resulted in error
   **/
  | 'CallbackFailed'

export type PalletCollatorSelectionCandidateInfo = { who: AccountId32; deposit: bigint }

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollatorSelectionError =
  /**
   * The pallet has too many candidates.
   **/
  | 'TooManyCandidates'
  /**
   * Leaving would result in too few candidates.
   **/
  | 'TooFewEligibleCollators'
  /**
   * Account is already a candidate.
   **/
  | 'AlreadyCandidate'
  /**
   * Account is not a candidate.
   **/
  | 'NotCandidate'
  /**
   * There are too many Invulnerables.
   **/
  | 'TooManyInvulnerables'
  /**
   * Account is already an Invulnerable.
   **/
  | 'AlreadyInvulnerable'
  /**
   * Account is not an Invulnerable.
   **/
  | 'NotInvulnerable'
  /**
   * Account has no associated validator ID.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Validator ID is not yet registered.
   **/
  | 'ValidatorNotRegistered'

export type SpCoreCryptoKeyTypeId = FixedBytes<4>

/**
 * Error for the session pallet.
 **/
export type PalletSessionError =
  /**
   * Invalid ownership proof.
   **/
  | 'InvalidProof'
  /**
   * No associated validator ID for account.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Registered duplicate key.
   **/
  | 'DuplicatedKey'
  /**
   * No keys are associated with this account.
   **/
  | 'NoKeys'
  /**
   * Key setting account is not live, so it's impossible to associate keys.
   **/
  | 'NoAccount'

export type SpConsensusSlotsSlot = bigint

export type PalletIdentityRegistration = {
  judgements: Array<[number, PalletIdentityJudgement]>
  deposit: bigint
  info: PalletIdentityIdentityInfo
}

export type PalletIdentityRegistrarInfo = { account: AccountId32; fee: bigint; fields: PalletIdentityBitFlags }

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIdentityError =
  /**
   * Too many subs-accounts.
   **/
  | 'TooManySubAccounts'
  /**
   * Account isn't found.
   **/
  | 'NotFound'
  /**
   * Account isn't named.
   **/
  | 'NotNamed'
  /**
   * Empty index.
   **/
  | 'EmptyIndex'
  /**
   * Fee is changed.
   **/
  | 'FeeChanged'
  /**
   * No identity found.
   **/
  | 'NoIdentity'
  /**
   * Sticky judgement.
   **/
  | 'StickyJudgement'
  /**
   * Judgement given.
   **/
  | 'JudgementGiven'
  /**
   * Invalid judgement.
   **/
  | 'InvalidJudgement'
  /**
   * The index is invalid.
   **/
  | 'InvalidIndex'
  /**
   * The target is invalid.
   **/
  | 'InvalidTarget'
  /**
   * Too many additional fields.
   **/
  | 'TooManyFields'
  /**
   * Maximum amount of registrars reached. Cannot add any more.
   **/
  | 'TooManyRegistrars'
  /**
   * Account ID is already named.
   **/
  | 'AlreadyClaimed'
  /**
   * Sender is not a sub-account.
   **/
  | 'NotSub'
  /**
   * Sub-account isn't owned by sender.
   **/
  | 'NotOwned'
  /**
   * The provided judgement was for a different identity.
   **/
  | 'JudgementForDifferentIdentity'
  /**
   * Error that occurs when there is an issue paying for judgement.
   **/
  | 'JudgementPaymentFailed'

export type PalletDemocracyReferendumInfo =
  | { type: 'Ongoing'; value: PalletDemocracyReferendumStatus }
  | { type: 'Finished'; value: { approved: boolean; end: number } }

export type PalletDemocracyReferendumStatus = {
  end: number
  proposal: FrameSupportPreimagesBounded
  threshold: PalletDemocracyVoteThreshold
  delay: number
  tally: PalletDemocracyTally
}

export type PalletDemocracyTally = { ayes: bigint; nays: bigint; turnout: bigint }

export type PalletDemocracyVoteVoting =
  | {
      type: 'Direct'
      value: {
        votes: Array<[number, PalletDemocracyVoteAccountVote]>
        delegations: PalletDemocracyDelegations
        prior: PalletDemocracyVotePriorLock
      }
    }
  | {
      type: 'Delegating'
      value: {
        balance: bigint
        target: AccountId32
        conviction: PalletDemocracyConviction
        delegations: PalletDemocracyDelegations
        prior: PalletDemocracyVotePriorLock
      }
    }

export type PalletDemocracyDelegations = { votes: bigint; capital: bigint }

export type PalletDemocracyVotePriorLock = [number, bigint]

/**
 * The `Error` enum of this pallet.
 **/
export type PalletDemocracyError =
  /**
   * Value too low
   **/
  | 'ValueLow'
  /**
   * Proposal does not exist
   **/
  | 'ProposalMissing'
  /**
   * Cannot cancel the same proposal twice
   **/
  | 'AlreadyCanceled'
  /**
   * Proposal already made
   **/
  | 'DuplicateProposal'
  /**
   * Proposal still blacklisted
   **/
  | 'ProposalBlacklisted'
  /**
   * Next external proposal not simple majority
   **/
  | 'NotSimpleMajority'
  /**
   * Invalid hash
   **/
  | 'InvalidHash'
  /**
   * No external proposal
   **/
  | 'NoProposal'
  /**
   * Identity may not veto a proposal twice
   **/
  | 'AlreadyVetoed'
  /**
   * Vote given for invalid referendum
   **/
  | 'ReferendumInvalid'
  /**
   * No proposals waiting
   **/
  | 'NoneWaiting'
  /**
   * The given account did not vote on the referendum.
   **/
  | 'NotVoter'
  /**
   * The actor has no permission to conduct the action.
   **/
  | 'NoPermission'
  /**
   * The account is already delegating.
   **/
  | 'AlreadyDelegating'
  /**
   * Too high a balance was provided that the account cannot afford.
   **/
  | 'InsufficientFunds'
  /**
   * The account is not currently delegating.
   **/
  | 'NotDelegating'
  /**
   * The account currently has votes attached to it and the operation cannot succeed until
   * these are removed, either through `unvote` or `reap_vote`.
   **/
  | 'VotesExist'
  /**
   * The instant referendum origin is currently disallowed.
   **/
  | 'InstantNotAllowed'
  /**
   * Delegation to oneself makes no sense.
   **/
  | 'Nonsense'
  /**
   * Invalid upper bound.
   **/
  | 'WrongUpperBound'
  /**
   * Maximum number of votes reached.
   **/
  | 'MaxVotesReached'
  /**
   * Maximum number of items reached.
   **/
  | 'TooMany'
  /**
   * Voting period too low
   **/
  | 'VotingPeriodLow'
  /**
   * The preimage does not exist.
   **/
  | 'PreimageNotExist'

export type PalletCollectiveVotes = {
  index: number
  threshold: number
  ayes: Array<AccountId32>
  nays: Array<AccountId32>
  end: number
}

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollectiveError =
  /**
   * Account is not a member
   **/
  | 'NotMember'
  /**
   * Duplicate proposals not allowed
   **/
  | 'DuplicateProposal'
  /**
   * Proposal must exist
   **/
  | 'ProposalMissing'
  /**
   * Mismatched index
   **/
  | 'WrongIndex'
  /**
   * Duplicate vote ignored
   **/
  | 'DuplicateVote'
  /**
   * Members are already initialized!
   **/
  | 'AlreadyInitialized'
  /**
   * The close call was made too early, before the end of the voting.
   **/
  | 'TooEarly'
  /**
   * There can only be a maximum of `MaxProposals` active proposals.
   **/
  | 'TooManyProposals'
  /**
   * The given weight bound for the proposal was too low.
   **/
  | 'WrongProposalWeight'
  /**
   * The given length bound for the proposal was too low.
   **/
  | 'WrongProposalLength'
  /**
   * Prime account is not a member
   **/
  | 'PrimeAccountNotMember'

export type PalletTreasuryProposal = { proposer: AccountId32; value: bigint; beneficiary: AccountId32; bond: bigint }

export type FrameSupportPalletId = FixedBytes<8>

/**
 * Error for the treasury pallet.
 **/
export type PalletTreasuryError =
  /**
   * Proposer's balance is too low.
   **/
  | 'InsufficientProposersBalance'
  /**
   * No proposal or bounty at that index.
   **/
  | 'InvalidIndex'
  /**
   * Too many approvals in the queue.
   **/
  | 'TooManyApprovals'
  /**
   * The spend origin is valid but the amount it is allowed to spend is lower than the
   * amount to be spent.
   **/
  | 'InsufficientPermission'
  /**
   * Proposal has not been approved.
   **/
  | 'ProposalNotApproved'

export type PalletBountiesBounty = {
  proposer: AccountId32
  value: bigint
  fee: bigint
  curatorDeposit: bigint
  bond: bigint
  status: PalletBountiesBountyStatus
}

export type PalletBountiesBountyStatus =
  | { type: 'Proposed' }
  | { type: 'Approved' }
  | { type: 'Funded' }
  | { type: 'CuratorProposed'; value: { curator: AccountId32 } }
  | { type: 'Active'; value: { curator: AccountId32; updateDue: number } }
  | { type: 'PendingPayout'; value: { curator: AccountId32; beneficiary: AccountId32; unlockAt: number } }

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBountiesError =
  /**
   * Proposer's balance is too low.
   **/
  | 'InsufficientProposersBalance'
  /**
   * No proposal or bounty at that index.
   **/
  | 'InvalidIndex'
  /**
   * The reason given is just too big.
   **/
  | 'ReasonTooBig'
  /**
   * The bounty status is unexpected.
   **/
  | 'UnexpectedStatus'
  /**
   * Require bounty curator.
   **/
  | 'RequireCurator'
  /**
   * Invalid bounty value.
   **/
  | 'InvalidValue'
  /**
   * Invalid bounty fee.
   **/
  | 'InvalidFee'
  /**
   * A bounty payout is pending.
   * To cancel the bounty, you must unassign and slash the curator.
   **/
  | 'PendingPayout'
  /**
   * The bounties cannot be claimed/closed because it's still in the countdown period.
   **/
  | 'Premature'
  /**
   * The bounty cannot be closed because it has active child bounties.
   **/
  | 'HasActiveChildBounty'
  /**
   * Too many approvals are already queued.
   **/
  | 'TooManyQueued'

export type PalletLotteryLotteryConfig = {
  price: bigint
  start: number
  length: number
  delay: number
  repeat: boolean
}

/**
 * The `Error` enum of this pallet.
 **/
export type PalletLotteryError =
  /**
   * A lottery has not been configured.
   **/
  | 'NotConfigured'
  /**
   * A lottery is already in progress.
   **/
  | 'InProgress'
  /**
   * A lottery has already ended.
   **/
  | 'AlreadyEnded'
  /**
   * The call is not valid for an open lottery.
   **/
  | 'InvalidCall'
  /**
   * You are already participating in the lottery with this call.
   **/
  | 'AlreadyParticipating'
  /**
   * Too many calls for a single lottery.
   **/
  | 'TooManyCalls'
  /**
   * Failed to encode calls
   **/
  | 'EncodingFailed'

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMembershipError =
  /**
   * Already a member.
   **/
  | 'AlreadyMember'
  /**
   * Not a member.
   **/
  | 'NotMember'
  /**
   * Too many members.
   **/
  | 'TooManyMembers'

export type PalletElectionsPhragmenSeatHolder = { who: AccountId32; stake: bigint; deposit: bigint }

export type PalletElectionsPhragmenVoter = { votes: Array<AccountId32>; stake: bigint; deposit: bigint }

/**
 * The `Error` enum of this pallet.
 **/
export type PalletElectionsPhragmenError =
  /**
   * Cannot vote when no candidates or members exist.
   **/
  | 'UnableToVote'
  /**
   * Must vote for at least one candidate.
   **/
  | 'NoVotes'
  /**
   * Cannot vote more than candidates.
   **/
  | 'TooManyVotes'
  /**
   * Cannot vote more than maximum allowed.
   **/
  | 'MaximumVotesExceeded'
  /**
   * Cannot vote with stake less than minimum balance.
   **/
  | 'LowBalance'
  /**
   * Voter can not pay voting bond.
   **/
  | 'UnableToPayBond'
  /**
   * Must be a voter.
   **/
  | 'MustBeVoter'
  /**
   * Duplicated candidate submission.
   **/
  | 'DuplicatedCandidate'
  /**
   * Too many candidates have been created.
   **/
  | 'TooManyCandidates'
  /**
   * Member cannot re-submit candidacy.
   **/
  | 'MemberSubmit'
  /**
   * Runner cannot re-submit candidacy.
   **/
  | 'RunnerUpSubmit'
  /**
   * Candidate does not have enough funds.
   **/
  | 'InsufficientCandidateFunds'
  /**
   * Not a member.
   **/
  | 'NotMember'
  /**
   * The provided count of number of candidates is incorrect.
   **/
  | 'InvalidWitnessData'
  /**
   * The provided count of number of votes is incorrect.
   **/
  | 'InvalidVoteCount'
  /**
   * The renouncing origin presented a wrong `Renouncing` parameter.
   **/
  | 'InvalidRenouncing'
  /**
   * Prediction regarding replacement after member removal is wrong.
   **/
  | 'InvalidReplacement'

export type PalletTipsOpenTip = {
  reason: H256
  who: AccountId32
  finder: AccountId32
  deposit: bigint
  closes?: number | undefined
  tips: Array<[AccountId32, bigint]>
  findersFee: boolean
}

/**
 * The `Error` enum of this pallet.
 **/
export type PalletTipsError =
  /**
   * The reason given is just too big.
   **/
  | 'ReasonTooBig'
  /**
   * The tip was already found/started.
   **/
  | 'AlreadyKnown'
  /**
   * The tip hash is unknown.
   **/
  | 'UnknownTip'
  /**
   * The account attempting to retract the tip is not the finder of the tip.
   **/
  | 'NotFinder'
  /**
   * The tip cannot be claimed/closed because there are not enough tippers yet.
   **/
  | 'StillOpen'
  /**
   * The tip cannot be claimed/closed because it's still in the countdown period.
   **/
  | 'Premature'

export type PalletChildBountiesChildBounty = {
  parentBounty: number
  value: bigint
  fee: bigint
  curatorDeposit: bigint
  status: PalletChildBountiesChildBountyStatus
}

export type PalletChildBountiesChildBountyStatus =
  | { type: 'Added' }
  | { type: 'CuratorProposed'; value: { curator: AccountId32 } }
  | { type: 'Active'; value: { curator: AccountId32 } }
  | { type: 'PendingPayout'; value: { curator: AccountId32; beneficiary: AccountId32; unlockAt: number } }

/**
 * The `Error` enum of this pallet.
 **/
export type PalletChildBountiesError =
  /**
   * The parent bounty is not in active state.
   **/
  | 'ParentBountyNotActive'
  /**
   * The bounty balance is not enough to add new child-bounty.
   **/
  | 'InsufficientBountyBalance'
  /**
   * Number of child bounties exceeds limit `MaxActiveChildBountyCount`.
   **/
  | 'TooManyChildBounties'

export type SubbridgePalletsChainbridgePalletProposalVotes = {
  votesFor: Array<AccountId32>
  votesAgainst: Array<AccountId32>
  status: SubbridgePalletsChainbridgePalletProposalStatus
  expiry: number
}

export type SubbridgePalletsChainbridgePalletProposalStatus = 'Initiated' | 'Approved' | 'Rejected'

export type SubbridgePalletsChainbridgePalletBridgeEvent =
  | { type: 'FungibleTransfer'; value: [number, bigint, FixedBytes<32>, U256, Bytes] }
  | { type: 'NonFungibleTransfer'; value: [number, bigint, FixedBytes<32>, Bytes, Bytes, Bytes] }
  | { type: 'GenericTransfer'; value: [number, bigint, FixedBytes<32>, Bytes] }

/**
 * The `Error` enum of this pallet.
 **/
export type SubbridgePalletsChainbridgePalletError =
  /**
   * Relayer threshold not set
   **/
  | 'ThresholdNotSet'
  /**
   * Provided chain Id is not valid
   **/
  | 'InvalidChainId'
  /**
   * Relayer threshold cannot be 0
   **/
  | 'InvalidThreshold'
  /**
   * Interactions with this chain is not permitted
   **/
  | 'ChainNotWhitelisted'
  /**
   * Chain has already been enabled
   **/
  | 'ChainAlreadyWhitelisted'
  /**
   * Resource ID provided isn't mapped to anything
   **/
  | 'ResourceDoesNotExist'
  /**
   * Relayer already in set
   **/
  | 'RelayerAlreadyExists'
  /**
   * Provided accountId is not a relayer
   **/
  | 'RelayerInvalid'
  /**
   * Protected operation, must be performed by relayer
   **/
  | 'MustBeRelayer'
  /**
   * Relayer has already submitted some vote for this proposal
   **/
  | 'RelayerAlreadyVoted'
  /**
   * A proposal with these parameters has already been submitted
   **/
  | 'ProposalAlreadyExists'
  /**
   * No proposal with the ID was found
   **/
  | 'ProposalDoesNotExist'
  /**
   * Cannot complete proposal, needs more votes
   **/
  | 'ProposalNotComplete'
  /**
   * Proposal has either failed or succeeded
   **/
  | 'ProposalAlreadyComplete'
  /**
   * Lifetime of proposal has been exceeded
   **/
  | 'ProposalExpired'
  /**
   * Got wrong paremeter when update fee
   **/
  | 'InvalidFeeOption'
  /**
   * Unkonwn asset
   **/
  | 'ExtractAssetFailed'
  /**
   * Unknown destnation
   **/
  | 'ExtractDestFailed'
  /**
   * Asset can not pay as fee
   **/
  | 'CannotPayAsFee'
  /**
   * Transfer failed
   **/
  | 'TransactFailed'
  /**
   * Infusficient balance to withdraw
   **/
  | 'InsufficientBalance'
  /**
   * Too expensive fee for withdrawn asset
   **/
  | 'FeeTooExpensive'
  /**
   * Can not extract asset reserve location
   **/
  | 'CannotDetermineReservedLocation'
  /**
   * Can not extract dest location
   **/
  | 'DestUnrecognized'
  /**
   * Assets not registered through pallet-assets or pallet-uniques
   **/
  | 'AssetNotRegistered'
  /**
   * Convertion failed from resource id
   **/
  | 'AssetConversionFailed'
  /**
   * Function unimplemented
   **/
  | 'Unimplemented'
  /**
   * Can not transfer assets to dest due to some reasons
   **/
  | 'CannotDepositAsset'
  /**
   * Trying to push bridge event count more than `BridgeEventLimit`
   **/
  | 'BridgeEventOverflow'

/**
 * The `Error` enum of this pallet.
 **/
export type SubbridgePalletsXcmbridgePalletError =
  | 'UnknownError'
  /**
   * Can not reanchor asset location according dest
   **/
  | 'CannotReanchor'
  /**
   * Failed to measure weight of a XCM message
   **/
  | 'UnweighableMessage'
  | 'FeePaymentEmpty'
  /**
   * XCM message executeion failed due to some reasons
   **/
  | 'ExecutionFailed'
  | 'UnknownTransfer'
  /**
   * Asset not been registered or not been supported
   **/
  | 'AssetNotFound'
  | 'LocationInvertFailed'
  /**
   * Extract dest location failed
   **/
  | 'IllegalDestination'
  /**
   * Can not transfer asset to dest
   **/
  | 'CannotDepositAsset'
  /**
   * Transfer type not valid
   **/
  | 'UnknownTransferType'
  /**
   * Unimplemented function
   **/
  | 'Unimplemented'

/**
 * The `Error` enum of this pallet.
 **/
export type SubbridgePalletsXtransferPalletError =
  | 'TransactFailed'
  | 'UnknownAsset'
  | 'UnsupportedDest'
  | 'UnhandledTransfer'

export type AssetsRegistryAssetRegistryInfo = {
  location: StagingXcmV3MultilocationMultiLocation
  reserveLocation?: StagingXcmV3MultilocationMultiLocation | undefined
  enabledBridges: Array<AssetsRegistryXBridge>
  properties: AssetsRegistryAssetProperties
  executionPrice?: bigint | undefined
}

export type AssetsRegistryXBridge = { config: AssetsRegistryXBridgeConfig; metadata: Bytes }

export type AssetsRegistryXBridgeConfig =
  | { type: 'Xcmp' }
  | {
      type: 'ChainBridge'
      value: { chainId: number; resourceId: FixedBytes<32>; reserveAccount: FixedBytes<32>; isMintable: boolean }
    }
  | { type: 'SygmaBridge'; value: { destDomain: number; resourceId: FixedBytes<32>; isMintable: boolean } }

/**
 * The `Error` enum of this pallet.
 **/
export type AssetsRegistryError =
  | 'AssetAlreadyExist'
  | 'AssetNotRegistered'
  | 'BridgeAlreadyEnabled'
  | 'BridgeAlreadyDisabled'
  | 'FailedToTransactAsset'
  | 'DuplictedLocation'
  | 'LocationTooLong'

/**
 * The `Error` enum of this pallet.
 **/
export type PhalaPalletsMqPalletError = 'BadSender' | 'BadSequence' | 'BadDestination'

export type PhalaPalletsRegistryPalletWorkerInfoV2 = {
  pubkey: SpCoreSr25519Public
  ecdhPubkey: SpCoreSr25519Public
  runtimeVersion: number
  lastUpdated: bigint
  operator?: AccountId32 | undefined
  attestationProvider?: PhalaTypesAttestationProvider | undefined
  confidenceLevel: number
  initialScore?: number | undefined
  features: Array<number>
}

export type PhalaPalletsRegistryPalletKnownConsensusVersion = { version: number; count: number }

/**
 * The `Error` enum of this pallet.
 **/
export type PhalaPalletsRegistryPalletError =
  | 'CannotHandleUnknownMessage'
  | 'InvalidSender'
  | 'InvalidPubKey'
  | 'MalformedSignature'
  | 'InvalidSignatureLength'
  | 'InvalidSignature'
  | 'UnknownContract'
  | 'InvalidIASSigningCert'
  | 'InvalidReport'
  | 'InvalidQuoteStatus'
  | 'BadIASReport'
  | 'OutdatedIASReport'
  | 'UnknownQuoteBodyFormat'
  | 'InvalidDCAPQuote'
  | 'InvalidRuntimeInfoHash'
  | 'InvalidRuntimeInfo'
  | 'InvalidInput'
  | 'InvalidBenchReport'
  | 'WorkerNotFound'
  | 'NoneAttestationDisabled'
  | 'InvalidGatekeeper'
  | 'InvalidMasterPubkey'
  | 'MasterKeyMismatch'
  | 'MasterKeyUninitialized'
  | 'GenesisBlockHashRejected'
  | 'GenesisBlockHashAlreadyExists'
  | 'GenesisBlockHashNotFound'
  | 'PRuntimeRejected'
  | 'PRuntimeAlreadyExists'
  | 'PRuntimeNotFound'
  | 'UnknownCluster'
  | 'NotImplemented'
  | 'CannotRemoveLastGatekeeper'
  | 'MasterKeyInRotation'
  | 'InvalidRotatedMasterPubkey'
  | 'InvalidEndpointSigningTime'
  /**
   * Migration root not authorized
   **/
  | 'NotMigrationRoot'
  | 'ParachainIdMismatch'
  | 'InvalidConsensusVersion'
  | 'UnsupportedAttestationType'

export type PhalaPalletsComputeComputationPalletSessionInfo = {
  state: PhalaPalletsComputeComputationPalletWorkerState
  ve: bigint
  v: bigint
  vUpdatedAt: bigint
  benchmark: PhalaPalletsComputeComputationPalletBenchmark
  coolDownStart: bigint
  stats: PhalaPalletsComputeComputationPalletSessionStats
}

export type PhalaPalletsComputeComputationPalletWorkerState =
  | 'Ready'
  | 'WorkerIdle'
  | 'Unused'
  | 'WorkerUnresponsive'
  | 'WorkerCoolingDown'

export type PhalaPalletsComputeComputationPalletBenchmark = {
  pInit: number
  pInstant: number
  iterations: bigint
  workingStartTime: bigint
  challengeTimeLast: bigint
}

export type PhalaPalletsComputeComputationPalletSessionStats = { totalReward: bigint }

/**
 * The `Error` enum of this pallet.
 **/
export type PhalaPalletsComputeComputationPalletError =
  /**
   * The transaction is sent by an unauthorized sender
   **/
  | 'BadSender'
  /**
   * Deprecated.
   **/
  | 'InvalidMessage'
  /**
   * The worker is not registered in the registry.
   **/
  | 'WorkerNotRegistered'
  /**
   * Deprecated
   **/
  | 'GatekeeperNotRegistered'
  /**
   * Not permitted because the session is already bound with another worker.
   **/
  | 'DuplicateBoundSession'
  /**
   * There's no benchmark result on the blockchain.
   **/
  | 'BenchmarkMissing'
  /**
   * session not found.
   **/
  | 'SessionNotFound'
  /**
   * Not permitted because the session is not bound with a worker.
   **/
  | 'SessionNotBound'
  /**
   * Worker is not in `Ready` state to proceed.
   **/
  | 'WorkerNotReady'
  /**
   * Worker is not in `Computation` state to stop computing.
   **/
  | 'WorkerNotComputing'
  /**
   * Not permitted because the worker is not bound with a worker account.
   **/
  | 'WorkerNotBound'
  /**
   * Cannot reclaim the worker because it's still in cooldown period.
   **/
  | 'CoolDownNotReady'
  /**
   * Cannot start computing because there's too little stake.
   **/
  | 'InsufficientStake'
  /**
   * Cannot start computing because there's too much stake (exceeds Vmax).
   **/
  | 'TooMuchStake'
  /**
   * Internal error. The tokenomic parameter is not set.
   **/
  | 'InternalErrorBadTokenomicParameters'
  /**
   * Not permitted because the worker is already bound with another session account.
   **/
  | 'DuplicateBoundWorker'
  /**
   * Indicating the initial benchmark score is too low to start computing.
   **/
  | 'BenchmarkTooLow'
  /**
   * Internal error. A worker should never start with existing stake in the storage.
   **/
  | 'InternalErrorCannotStartWithExistingStake'
  /**
   * Migration root not authorized
   **/
  | 'NotMigrationRoot'
  | 'NonceIndexInvalid'
  | 'BudgetUpdateBlockInvalid'
  | 'BudgetExceedMaxLimit'
  /**
   * The worker need to be re-registered to be added to a pool.
   **/
  | 'WorkerReregisterNeeded'

export type PhalaPalletsStakePoolPalletPoolInfo = {
  pid: bigint
  owner: AccountId32
  payoutCommission?: Permill | undefined
  ownerReward: bigint
  cap?: bigint | undefined
  rewardAcc: PhalaPalletsUtilsFixedPoint
  totalShares: bigint
  totalStake: bigint
  freeStake: bigint
  releasingStake: bigint
  workers: Array<SpCoreSr25519Public>
  withdrawQueue: Array<PhalaPalletsStakePoolPalletWithdrawInfo>
}

export type PhalaPalletsUtilsFixedPoint = bigint

export type PhalaPalletsStakePoolPalletWithdrawInfo = { user: AccountId32; shares: bigint; startTime: bigint }

export type PhalaPalletsStakePoolPalletUserStakeInfo = {
  user: AccountId32
  locked: bigint
  shares: bigint
  availableRewards: bigint
  rewardDebt: bigint
}

/**
 * The `Error` enum of this pallet.
 **/
export type PhalaPalletsStakePoolPalletError = null

/**
 * The `Error` enum of this pallet.
 **/
export type PhalaPalletsComputeStakePoolV2PalletError =
  /**
   * The worker is not registered in the registry when adding to the pool
   **/
  | 'WorkerNotRegistered'
  /**
   * The worker doesn't have a valid benchmark when adding to the pool
   **/
  | 'BenchmarkMissing'
  /**
   * The worker is already added to the pool
   **/
  | 'WorkerExists'
  /**
   * The worker is already in cd_workers
   **/
  | 'WorkerAlreadyStopped'
  /**
   * The target worker is not in the pool
   **/
  | 'WorkerDoesNotExist'
  /**
   * The worker is already added to another pool
   **/
  | 'WorkerInAnotherPool'
  /**
   * The owner of the pool doesn't have the access to the worker
   *
   * The access to a worker is granted by it's `operator` parameter set by `register_worker`
   **/
  | 'UnauthorizedOperator'
  /**
   * The caller is not the owner of the pool
   **/
  | 'UnauthorizedPoolOwner'
  /**
   * The stake capacity is set too low to cover the existing stake
   **/
  | 'InadequateCapacity'
  /**
   * The stake added to a pool exceeds its capacity
   **/
  | 'StakeExceedsCapacity'
  /**
   * The specified pool doesn't exist
   **/
  | 'PoolDoesNotExist'
  | 'PoolIsBusy'
  /**
   * The contributed stake is smaller than the minimum threshold
   **/
  | 'InsufficientContribution'
  /**
   * The caller has no nft to withdraw
   **/
  | 'NoNftToWithdraw'
  /**
   * Trying to contribute more than the available balance
   **/
  | 'InsufficientBalance'
  /**
   * The user doesn't have stake in a pool
   **/
  | 'PoolStakeNotFound'
  /**
   * Cannot start computing because there's no enough free stake
   **/
  | 'InsufficientFreeStake'
  /**
   * The withdrawal amount is too small (considered as dust)
   **/
  | 'InvalidWithdrawalAmount'
  /**
   * Couldn't bind worker and the pool computing subaccount
   **/
  | 'FailedToBindSessionAndWorker'
  /**
   * Internal error: Cannot withdraw from the subsidy pool. This should never happen.
   **/
  | 'InternalSubsidyPoolCannotWithdraw'
  /**
   * The pool has already got all the stake completely slashed.
   *
   * In this case, no more funds can be contributed to the pool until all the pending slash
   * has been resolved.
   **/
  | 'PoolBankrupt'
  /**
   * There's no pending reward to claim
   **/
  | 'NoRewardToClaim'
  /**
   * The StakePool is not enabled yet.
   **/
  | 'FeatureNotEnabled'
  /**
   * Failed to add a worker because the number of the workers exceeds the upper limit.
   **/
  | 'WorkersExceedLimit'
  /**
   * Restarted with a less stake is not allowed in the tokenomic.
   **/
  | 'CannotRestartWithLessStake'
  /**
   * Invalid amount of balance input when force reward.
   **/
  | 'InvalidForceRewardAmount'
  /**
   * Withdraw queue is not empty so that we can't restart computing
   **/
  | 'WithdrawQueueNotEmpty'
  /**
   * Stakepool's collection_id isn't founded
   **/
  | 'MissingCollectionId'
  /**
   * Vault is forced locked for it has some expired withdrawal
   **/
  | 'VaultIsLocked'
  /**
   * The target miner is not in the `miner` storage
   **/
  | 'SessionDoesNotExist'
  /**
   * The target worker is not reclaimed and can not be removed from a pool.
   **/
  | 'WorkerIsNotReady'
  | 'LockAccountStakeError'
  | 'NoLegacyRewardToClaim'

/**
 * The `Error` enum of this pallet.
 **/
export type PhalaPalletsComputeVaultPalletError =
  /**
   * The caller is not the owner of the pool
   **/
  | 'UnauthorizedPoolOwner'
  /**
   * The withdrawal amount is too small or too large
   **/
  | 'NoEnoughShareToClaim'
  /**
   * The vault have no owner shares to claim
   **/
  | 'NoRewardToClaim'
  /**
   * The asset account hasn't been created. It indicates an internal error.
   **/
  | 'AssetAccountNotExist'
  /**
   * Trying to contribute more than the available balance
   **/
  | 'InsufficientBalance'
  /**
   * The contributed stake is smaller than the minimum threshold
   **/
  | 'InsufficientContribution'
  /**
   * The Vault was bankrupt; cannot interact with it unless all the shares are withdrawn.
   **/
  | 'VaultBankrupt'
  /**
   * The caller has no nft to withdraw
   **/
  | 'NoNftToWithdraw'
  /**
   * The commission is not changed
   **/
  | 'CommissionNotChanged'

export type PhalaPalletsComputeWrappedBalancesPalletFinanceAccount = {
  investPools: Array<[bigint, number]>
  locked: bigint
}

/**
 * The `Error` enum of this pallet.
 **/
export type PhalaPalletsComputeWrappedBalancesPalletError =
  /**
   * user's `FinanceAccount` does not exist in storage: `StakerAccounts`
   **/
  | 'StakerAccountNotFound'
  /**
   * Trying to unwrap more than the available balance
   **/
  | 'UnwrapAmountExceedsAvaliableStake'
  /**
   * Trying to vote more than the available balance
   **/
  | 'VoteAmountLargerThanTotalStakes'
  /**
   * The vote is not currently on going
   **/
  | 'ReferendumInvalid'
  /**
   * The vote is now on going and the W-PHA used in voting can not be unlocked
   **/
  | 'ReferendumOngoing'
  /**
   * The Iteration exceed the max limitaion
   **/
  | 'IterationsIsNotVaild'

export type PhalaPalletsComputePoolProxy =
  | { type: 'StakePool'; value: PhalaPalletsComputePoolProxyStakePool }
  | { type: 'Vault'; value: PhalaPalletsComputePoolProxyVault }

export type PhalaPalletsComputePoolProxyStakePool = {
  basepool: PhalaPalletsComputeBasePoolPalletBasePool
  payoutCommission?: Permill | undefined
  cap?: bigint | undefined
  workers: Array<SpCoreSr25519Public>
  cdWorkers: Array<SpCoreSr25519Public>
  lockAccount: AccountId32
  ownerRewardAccount: AccountId32
}

export type PhalaPalletsComputeBasePoolPalletBasePool = {
  pid: bigint
  owner: AccountId32
  totalShares: bigint
  totalValue: bigint
  withdrawQueue: Array<PhalaPalletsComputeBasePoolPalletWithdrawInfo>
  valueSubscribers: Array<bigint>
  cid: number
  poolAccountId: AccountId32
}

export type PhalaPalletsComputeBasePoolPalletWithdrawInfo = { user: AccountId32; startTime: bigint; nftId: number }

export type PhalaPalletsComputePoolProxyVault = {
  basepool: PhalaPalletsComputeBasePoolPalletBasePool
  lastSharePriceCheckpoint: bigint
  commission?: Permill | undefined
  ownerShares: bigint
  investPools: Array<bigint>
}

/**
 * The `Error` enum of this pallet.
 **/
export type PhalaPalletsComputeBasePoolPalletError =
  /**
   * basepool's collection_id isn't founded
   **/
  | 'MissCollectionId'
  /**
   * The pool has already got all the stake completely slashed.
   *
   * In this case, no more funds can be contributed to the pool until all the pending slash
   * has been resolved.
   **/
  | 'PoolBankrupt'
  /**
   * CheckSub less than zero, indicate share amount is invalid
   **/
  | 'InvalidShareToWithdraw'
  /**
   * The withdrawal amount is too small (considered as dust)
   **/
  | 'InvalidWithdrawalAmount'
  /**
   * RMRK errors
   **/
  | 'RmrkError'
  /**
   * The Specified pid does not match to any pool
   **/
  | 'PoolDoesNotExist'
  /**
   * Tried to access a pool type that doesn't match the actual pool type in the storage.
   *
   * E.g. Try to access a vault but it's actually a stake pool.
   **/
  | 'PoolTypeNotMatch'
  /**
   * NftId does not match any nft
   **/
  | 'NftIdNotFound'
  /**
   * Occurs when pool's shares is zero
   **/
  | 'InvalidSharePrice'
  /**
   * Tried to get a `NftGuard` when the nft is locked. It indicates an internal error occured.
   **/
  | 'AttrLocked'
  /**
   * The caller is not the owner of the pool
   **/
  | 'UnauthorizedPoolOwner'
  /**
   * Can not add the staker to whitelist because the staker is already in whitelist.
   **/
  | 'AlreadyInContributeWhitelist'
  /**
   * Invalid staker to contribute because origin isn't in Pool's contribution whitelist.
   **/
  | 'NotInContributeWhitelist'
  /**
   * Too many stakers in contribution whitelist that exceed the limit
   **/
  | 'ExceedWhitelistMaxLen'
  /**
   * The pool hasn't have a whitelist created
   **/
  | 'NoWhitelistCreated'
  /**
   * Too long for pool description length
   **/
  | 'ExceedMaxDescriptionLen'
  /**
   * Migration root not authorized
   **/
  | 'NotMigrationRoot'
  /**
   * Burn nft failed
   **/
  | 'BurnNftFailed'
  | 'DeprecatedTransferSharesAmountInvalid'
  /**
   * No reimbursement to claim
   **/
  | 'NoReimbursementToClaim'
  | 'InternalSubsidyPoolCannotWithdraw'

export type PhalaPalletsPhatPalletBasicContractInfo = { deployer: AccountId32; cluster: H256 }

export type PhalaTypesContractClusterInfo = {
  owner: AccountId32
  permission: PhalaTypesContractClusterPermission
  systemContract: H256
  gasPrice: bigint
  depositPerItem: bigint
  depositPerByte: bigint
}

/**
 * The `Error` enum of this pallet.
 **/
export type PhalaPalletsPhatPalletError =
  | 'CodeNotFound'
  | 'ClusterNotFound'
  | 'ClusterNotDeployed'
  | 'ClusterPermissionDenied'
  | 'DuplicatedContract'
  | 'DuplicatedDeployment'
  | 'NoWorkerSpecified'
  | 'InvalidSender'
  | 'WorkerNotFound'
  | 'PayloadTooLarge'
  | 'NoPinkSystemCode'
  | 'ContractNotFound'
  | 'WorkerIsBusy'

/**
 * The `Error` enum of this pallet.
 **/
export type PhalaPalletsPhatTokenomicPalletError = 'InvalidAmountOfStake'

export type PalletUniquesCollectionDetails = {
  owner: AccountId32
  issuer: AccountId32
  admin: AccountId32
  freezer: AccountId32
  totalDeposit: bigint
  freeHolding: boolean
  items: number
  itemMetadatas: number
  attributes: number
  isFrozen: boolean
}

export type PalletUniquesItemDetails = {
  owner: AccountId32
  approved?: AccountId32 | undefined
  isFrozen: boolean
  deposit: bigint
}

export type PalletUniquesCollectionMetadata = { deposit: bigint; data: Bytes; isFrozen: boolean }

export type PalletUniquesItemMetadata = { deposit: bigint; data: Bytes; isFrozen: boolean }

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUniquesError =
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownCollection'
  /**
   * The item ID has already been used for an item.
   **/
  | 'AlreadyExists'
  /**
   * The owner turned out to be different to what was expected.
   **/
  | 'WrongOwner'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * The item ID is already taken.
   **/
  | 'InUse'
  /**
   * The item or collection is frozen.
   **/
  | 'Frozen'
  /**
   * The delegate turned out to be different to what was expected.
   **/
  | 'WrongDelegate'
  /**
   * There is no delegate approved.
   **/
  | 'NoDelegate'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The named owner has not signed ownership of the collection is acceptable.
   **/
  | 'Unaccepted'
  /**
   * The item is locked.
   **/
  | 'Locked'
  /**
   * All items have been minted.
   **/
  | 'MaxSupplyReached'
  /**
   * The max supply has already been set.
   **/
  | 'MaxSupplyAlreadySet'
  /**
   * The provided max supply is less to the amount of items a collection already has.
   **/
  | 'MaxSupplyTooSmall'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownItem'
  /**
   * Item is not for sale.
   **/
  | 'NotForSale'
  /**
   * The provided bid is too low.
   **/
  | 'BidTooLow'

export type RmrkTraitsCollectionCollectionInfo = {
  issuer: AccountId32
  metadata: Bytes
  max?: number | undefined
  symbol: Bytes
  nftsCount: number
}

export type RmrkTraitsNftNftInfo = {
  owner: RmrkTraitsNftAccountIdOrCollectionNftTuple
  royalty?: RmrkTraitsNftRoyaltyInfo | undefined
  metadata: Bytes
  equipped?: [number, number] | undefined
  pending: boolean
  transferable: boolean
}

export type RmrkTraitsNftRoyaltyInfo = { recipient: AccountId32; amount: Permill }

export type RmrkTraitsResourceResourceInfo = {
  id: number
  resource: RmrkTraitsResourceResourceTypes
  pending: boolean
  pendingRemoval: boolean
}

export type RmrkTraitsNftNftChild = { collectionId: number; nftId: number }

export type PhantomType = FixedArray<RmrkTraitsPropertyPropertyInfo, 0>

export type RmrkTraitsPropertyPropertyInfo = { key: Bytes; value: Bytes }

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRmrkCoreError =
  /**
   * Error names should be descriptive.
   **/
  | 'NoneValue'
  /**
   * Errors should have helpful documentation associated with them.
   **/
  | 'StorageOverflow'
  | 'TooLong'
  | 'NoAvailableCollectionId'
  | 'NoAvailableResourceId'
  | 'MetadataNotSet'
  | 'RecipientNotSet'
  | 'NoAvailableNftId'
  | 'NotInRange'
  | 'RoyaltyNotSet'
  | 'CollectionUnknown'
  | 'NoPermission'
  | 'NoWitness'
  | 'CollectionNotEmpty'
  | 'CollectionFullOrLocked'
  | 'CannotSendToDescendentOrSelf'
  | 'ResourceAlreadyExists'
  | 'NftAlreadyExists'
  | 'EmptyResource'
  /**
   * The recursion limit has been reached.
   **/
  | 'TooManyRecursions'
  | 'NftIsLocked'
  | 'CannotAcceptNonOwnedNft'
  | 'CannotRejectNonOwnedNft'
  | 'CannotRejectNonPendingNft'
  | 'ResourceDoesntExist'
  /**
   * Accepting a resource that is not pending should fail
   **/
  | 'ResourceNotPending'
  | 'NonTransferable'
  | 'CannotSendEquippedItem'
  | 'CannotAcceptToNewOwner'
  | 'FailedTransferHooksPreCheck'
  | 'FailedTransferHooksPostTransfer'

export type RmrkTraitsBaseBaseInfo = { issuer: AccountId32; baseType: Bytes; symbol: Bytes }

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRmrkEquipError =
  | 'PermissionError'
  | 'ItemDoesntExist'
  | 'EquipperDoesntExist'
  | 'NoAvailableBaseId'
  | 'TooManyEquippables'
  | 'NoAvailablePartId'
  | 'MustBeDirectParent'
  | 'PartDoesntExist'
  | 'BaseDoesntExist'
  | 'CantEquipFixedPart'
  | 'NoResourceForThisBaseFoundOnNft'
  | 'CollectionNotEquippable'
  | 'ItemHasNoResourceToEquipThere'
  | 'NoEquippableOnFixedPart'
  | 'NeedsDefaultThemeFirst'
  | 'ItemAlreadyEquipped'
  | 'SlotAlreadyEquipped'
  | 'SlotNotEquipped'
  | 'UnknownError'
  | 'ExceedsMaxPartsPerBase'
  | 'TooManyProperties'
  | 'ItemNotEquipped'
  | 'UnequipperMustOwnEitherItemOrEquipper'
  | 'UnexpectedTryFromIntError'
  | 'UnexpectedVecConversionError'

export type PalletRmrkMarketListInfo = { listedBy: AccountId32; amount: bigint; expires?: number | undefined }

export type PalletRmrkMarketOffer = { maker: AccountId32; amount: bigint; expires?: number | undefined }

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRmrkMarketError =
  /**
   * No permissions for account to interact with NFT
   **/
  | 'NoPermission'
  /**
   * Token cannot be bought
   **/
  | 'TokenNotForSale'
  /**
   * Offer already accepted and cannot withdraw
   **/
  | 'CannotWithdrawOffer'
  /**
   * Cannot unlist NFT as it has already been unlisted or sold
   **/
  | 'CannotUnlistToken'
  /**
   * Cannot make offer on NFT on own NFT
   **/
  | 'CannotOfferOnOwnToken'
  /**
   * Cannot buy NFT that is already owned
   **/
  | 'CannotBuyOwnToken'
  /**
   * Offer is unknown
   **/
  | 'UnknownOffer'
  /**
   * Cannot list NFT owned by a NFT
   **/
  | 'CannotListNftOwnedByNft'
  /**
   * Cannot list a non-existing NFT
   **/
  | 'TokenDoesNotExist'
  /**
   * Offer is below the OfferMinimumAmount threshold
   **/
  | 'OfferTooLow'
  /**
   * Account cannot offer on a NFT again with an active offer
   **/
  | 'AlreadyOffered'
  /**
   * Accepted offer has expired and cannot be accepted
   **/
  | 'OfferHasExpired'
  /**
   * Listing has expired and cannot be bought
   **/
  | 'ListingHasExpired'
  /**
   * Price differs from when `buy` was executed
   **/
  | 'PriceDiffersFromExpected'
  /**
   * Not possible to list non-transferable NFT
   **/
  | 'NonTransferable'
  /**
   * Marketplace owner not configured
   **/
  | 'MarketplaceOwnerNotSet'
  /**
   * Cannot list NFT based on downstream logic implemented for MarketplaceHooks trait
   **/
  | 'CannotListNft'

/**
 * The `Error` enum of this pallet.
 **/
export type SygmaAccessSegregatorError =
  /**
   * Function unimplemented
   **/
  | 'Unimplemented'
  /**
   * Failed to grant extrinsic access permission to an account
   **/
  | 'GrantAccessFailed'

/**
 * The `Error` enum of this pallet.
 **/
export type SygmaBasicFeehandlerError =
  /**
   * Function unimplemented
   **/
  | 'Unimplemented'
  /**
   * Account has not gained access permission
   **/
  | 'AccessDenied'

/**
 * The `Error` enum of this pallet.
 **/
export type SygmaBridgeError =
  /**
   * Account has not gained access permission
   **/
  | 'AccessDenied'
  /**
   * Protected operation, must be performed by relayer
   **/
  | 'BadMpcSignature'
  /**
   * Insufficient balance on sender account
   **/
  | 'InsufficientBalance'
  /**
   * Asset transactor execution failed
   **/
  | 'TransactFailed'
  /**
   * The withdrawn amount can not cover the fee payment
   **/
  | 'FeeTooExpensive'
  /**
   * MPC address not set
   **/
  | 'MissingMpcAddress'
  /**
   * MPC address can not be updated
   **/
  | 'MpcAddrNotUpdatable'
  /**
   * Bridge is paused
   **/
  | 'BridgePaused'
  /**
   * Bridge is unpaused
   **/
  | 'BridgeUnpaused'
  /**
   * Fee config option missing
   **/
  | 'MissingFeeConfig'
  /**
   * Asset not bound to a resource id
   **/
  | 'AssetNotBound'
  /**
   * Proposal has either failed or succeeded
   **/
  | 'ProposalAlreadyComplete'
  /**
   * Proposal list empty
   **/
  | 'EmptyProposalList'
  /**
   * Transactor operation failed
   **/
  | 'TransactorFailed'
  /**
   * Deposit data not correct
   **/
  | 'InvalidDepositData'
  /**
   * Dest domain not supported
   **/
  | 'DestDomainNotSupported'
  /**
   * Dest chain id not match
   **/
  | 'DestChainIDNotMatch'
  /**
   * Failed to extract destination data
   **/
  | 'ExtractDestDataFailed'
  /**
   * Failed on the decimal converter
   **/
  | 'DecimalConversionFail'
  /**
   * Deposit nonce has reached max integer value
   **/
  | 'DepositNonceOverflow'
  /**
   * Asset not bound to a liquidity holder account
   **/
  | 'NoLiquidityHolderAccountBound'
  /**
   * Function unimplemented
   **/
  | 'Unimplemented'

/**
 * The `Error` enum of this pallet.
 **/
export type SygmaFeeHandlerRouterError =
  /**
   * Account has not gained access permission
   **/
  | 'AccessDenied'
  /**
   * Function unimplemented
   **/
  | 'Unimplemented'

/**
 * The `Error` enum of this pallet.
 **/
export type SubbridgePalletsSygmaWrapperPalletError =
  /**
   * Can not transfer asset to dest
   **/
  | 'CannotDepositAsset'
  /**
   * Unimplemented function
   **/
  | 'Unimplemented'

/**
 * The `Error` enum of this pallet.
 **/
export type SygmaPercentageFeehandlerError =
  /**
   * Function unimplemented
   **/
  | 'Unimplemented'
  /**
   * Account has not gained access permission
   **/
  | 'AccessDenied'
  /**
   * Fee rate is out of range [0, 10000)
   **/
  | 'FeeRateOutOfRange'
  /**
   * Percentage fee bound is invalid
   **/
  | 'InvalidFeeBound'

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIndexError =
  | 'AssetNotFound'
  | 'WorkerAlreadySet'
  | 'WorkerNotSet'
  | 'WorkerMismatch'
  | 'TaskAlreadyExist'
  | 'NotFoundInTaskQueue'
  | 'TaskQueueEmpty'
  | 'TransactFailed'
  | 'FeeTooExpensive'

export type SpRuntimeMultiSignature =
  | { type: 'Ed25519'; value: SpCoreEd25519Signature }
  | { type: 'Sr25519'; value: SpCoreSr25519Signature }
  | { type: 'Ecdsa'; value: SpCoreEcdsaSignature }

export type SpCoreEd25519Signature = FixedBytes<64>

export type SpCoreSr25519Signature = FixedBytes<64>

export type SpCoreEcdsaSignature = FixedBytes<65>

export type FrameSystemExtensionsCheckNonZeroSender = {}

export type FrameSystemExtensionsCheckSpecVersion = {}

export type FrameSystemExtensionsCheckTxVersion = {}

export type FrameSystemExtensionsCheckGenesis = {}

export type FrameSystemExtensionsCheckMortality = Era

export type FrameSystemExtensionsCheckNonce = number

export type FrameSystemExtensionsCheckWeight = {}

export type PhalaPalletsMqCheckSeqCheckMqSequence = {}

export type PalletTransactionPaymentChargeTransactionPayment = bigint

export type PhalaParachainRuntimeRuntime = {}

export type SpConsensusSlotsSlotDuration = bigint

export type SpRuntimeBlock = { header: Header; extrinsics: Array<UncheckedExtrinsic> }

export type SpCoreOpaqueMetadata = Bytes

export type SpRuntimeTransactionValidityTransactionValidityError =
  | { type: 'Invalid'; value: SpRuntimeTransactionValidityInvalidTransaction }
  | { type: 'Unknown'; value: SpRuntimeTransactionValidityUnknownTransaction }

export type SpRuntimeTransactionValidityInvalidTransaction =
  | { type: 'Call' }
  | { type: 'Payment' }
  | { type: 'Future' }
  | { type: 'Stale' }
  | { type: 'BadProof' }
  | { type: 'AncientBirthBlock' }
  | { type: 'ExhaustsResources' }
  | { type: 'Custom'; value: number }
  | { type: 'BadMandatory' }
  | { type: 'MandatoryValidation' }
  | { type: 'BadSigner' }

export type SpRuntimeTransactionValidityUnknownTransaction =
  | { type: 'CannotLookup' }
  | { type: 'NoUnsignedValidator' }
  | { type: 'Custom'; value: number }

export type SpInherentsInherentData = { data: Array<[FixedBytes<8>, Bytes]> }

export type SpInherentsCheckInherentsResult = { okay: boolean; fatalError: boolean; errors: SpInherentsInherentData }

export type SpRuntimeTransactionValidityTransactionSource = 'InBlock' | 'Local' | 'External'

export type SpRuntimeTransactionValidityValidTransaction = {
  priority: bigint
  requires: Array<Bytes>
  provides: Array<Bytes>
  longevity: bigint
  propagate: boolean
}

export type PalletTransactionPaymentRuntimeDispatchInfo = {
  weight: SpWeightsWeightV2Weight
  class: FrameSupportDispatchDispatchClass
  partialFee: bigint
}

export type PalletTransactionPaymentFeeDetails = {
  inclusionFee?: PalletTransactionPaymentInclusionFee | undefined
  tip: bigint
}

export type PalletTransactionPaymentInclusionFee = { baseFee: bigint; lenFee: bigint; adjustedWeightFee: bigint }

export type CumulusPrimitivesCoreCollationInfo = {
  upwardMessages: Array<Bytes>
  horizontalMessages: Array<PolkadotCorePrimitivesOutboundHrmpMessage>
  newValidationCode?: PolkadotParachainPrimitivesPrimitivesValidationCode | undefined
  processedDownwardMessages: number
  hrmpWatermark: number
  headData: PolkadotParachainPrimitivesPrimitivesHeadData
}

export type PolkadotParachainPrimitivesPrimitivesValidationCode = Bytes

export type PhalaParachainRuntimeRuntimeError =
  | { pallet: 'System'; palletError: FrameSystemError }
  | { pallet: 'Utility'; palletError: PalletUtilityError }
  | { pallet: 'Multisig'; palletError: PalletMultisigError }
  | { pallet: 'Proxy'; palletError: PalletProxyError }
  | { pallet: 'Vesting'; palletError: PalletVestingError }
  | { pallet: 'Scheduler'; palletError: PalletSchedulerError }
  | { pallet: 'Preimage'; palletError: PalletPreimageError }
  | { pallet: 'ParachainSystem'; palletError: CumulusPalletParachainSystemError }
  | { pallet: 'XcmpQueue'; palletError: CumulusPalletXcmpQueueError }
  | { pallet: 'CumulusXcm'; palletError: CumulusPalletXcmError }
  | { pallet: 'DmpQueue'; palletError: CumulusPalletDmpQueueError }
  | { pallet: 'PolkadotXcm'; palletError: PalletXcmError }
  | { pallet: 'Balances'; palletError: PalletBalancesError }
  | { pallet: 'Assets'; palletError: PalletAssetsError }
  | { pallet: 'CollatorSelection'; palletError: PalletCollatorSelectionError }
  | { pallet: 'Session'; palletError: PalletSessionError }
  | { pallet: 'Identity'; palletError: PalletIdentityError }
  | { pallet: 'Democracy'; palletError: PalletDemocracyError }
  | { pallet: 'Council'; palletError: PalletCollectiveError }
  | { pallet: 'Treasury'; palletError: PalletTreasuryError }
  | { pallet: 'Bounties'; palletError: PalletBountiesError }
  | { pallet: 'Lottery'; palletError: PalletLotteryError }
  | { pallet: 'TechnicalCommittee'; palletError: PalletCollectiveError }
  | { pallet: 'TechnicalMembership'; palletError: PalletMembershipError }
  | { pallet: 'PhragmenElection'; palletError: PalletElectionsPhragmenError }
  | { pallet: 'Tips'; palletError: PalletTipsError }
  | { pallet: 'ChildBounties'; palletError: PalletChildBountiesError }
  | { pallet: 'ChainBridge'; palletError: SubbridgePalletsChainbridgePalletError }
  | { pallet: 'XcmBridge'; palletError: SubbridgePalletsXcmbridgePalletError }
  | { pallet: 'XTransfer'; palletError: SubbridgePalletsXtransferPalletError }
  | { pallet: 'AssetsRegistry'; palletError: AssetsRegistryError }
  | { pallet: 'PhalaMq'; palletError: PhalaPalletsMqPalletError }
  | { pallet: 'PhalaRegistry'; palletError: PhalaPalletsRegistryPalletError }
  | { pallet: 'PhalaComputation'; palletError: PhalaPalletsComputeComputationPalletError }
  | { pallet: 'PhalaStakePool'; palletError: PhalaPalletsStakePoolPalletError }
  | { pallet: 'PhalaStakePoolv2'; palletError: PhalaPalletsComputeStakePoolV2PalletError }
  | { pallet: 'PhalaVault'; palletError: PhalaPalletsComputeVaultPalletError }
  | { pallet: 'PhalaWrappedBalances'; palletError: PhalaPalletsComputeWrappedBalancesPalletError }
  | { pallet: 'PhalaBasePool'; palletError: PhalaPalletsComputeBasePoolPalletError }
  | { pallet: 'PhalaPhatContracts'; palletError: PhalaPalletsPhatPalletError }
  | { pallet: 'PhalaPhatTokenomic'; palletError: PhalaPalletsPhatTokenomicPalletError }
  | { pallet: 'Uniques'; palletError: PalletUniquesError }
  | { pallet: 'RmrkCore'; palletError: PalletRmrkCoreError }
  | { pallet: 'RmrkEquip'; palletError: PalletRmrkEquipError }
  | { pallet: 'RmrkMarket'; palletError: PalletRmrkMarketError }
  | { pallet: 'SygmaAccessSegregator'; palletError: SygmaAccessSegregatorError }
  | { pallet: 'SygmaBasicFeeHandler'; palletError: SygmaBasicFeehandlerError }
  | { pallet: 'SygmaBridge'; palletError: SygmaBridgeError }
  | { pallet: 'SygmaFeeHandlerRouter'; palletError: SygmaFeeHandlerRouterError }
  | { pallet: 'SygmaWrapper'; palletError: SubbridgePalletsSygmaWrapperPalletError }
  | { pallet: 'SygmaPercentageFeeHandler'; palletError: SygmaPercentageFeehandlerError }
  | { pallet: 'PalletIndex'; palletError: PalletIndexError }
